#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BrickRigs

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "BrickRigs_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "FluMoveSync_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CableComponent_classes.hpp"
#include "PhysicsCore_classes.hpp"
#include "Slate_structs.hpp"
#include "InputCore_structs.hpp"
#include "FluUGC_structs.hpp"


namespace SDK
{

// Class BrickRigs.PagedListEntryWidget
// 0x0028 (0x0288 - 0x0260)
class UPagedListEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeEntry();
	void OnClickedEntry();
	void OnDoubleClickedEntry();
	void UpdateButtonSelected(bool bNewSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PagedListEntryWidget">();
	}
	static class UPagedListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPagedListEntryWidget>();
	}
};
static_assert(alignof(UPagedListEntryWidget) == 0x000008, "Wrong alignment on UPagedListEntryWidget");
static_assert(sizeof(UPagedListEntryWidget) == 0x000288, "Wrong size on UPagedListEntryWidget");
static_assert(offsetof(UPagedListEntryWidget, Button) == 0x000270, "Member 'UPagedListEntryWidget::Button' has a wrong offset!");

// Class BrickRigs.KickedPlayerWidget
// 0x0088 (0x0310 - 0x0288)
class UKickedPlayerWidget : public UPagedListEntryWidget
{
public:
	struct FKickedPlayer                          Entry;                                             // 0x0288(0x0060)(Transient, NativeAccessSpecifierPrivate)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        IdTextBlock;                                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        KickTimeTextBlock;                                 // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        KickDurationTextBlock;                             // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        KickTimeRemainingTextBlock;                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickedPlayerWidget">();
	}
	static class UKickedPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickedPlayerWidget>();
	}
};
static_assert(alignof(UKickedPlayerWidget) == 0x000008, "Wrong alignment on UKickedPlayerWidget");
static_assert(sizeof(UKickedPlayerWidget) == 0x000310, "Wrong size on UKickedPlayerWidget");
static_assert(offsetof(UKickedPlayerWidget, Entry) == 0x000288, "Member 'UKickedPlayerWidget::Entry' has a wrong offset!");
static_assert(offsetof(UKickedPlayerWidget, NameTextBlock) == 0x0002E8, "Member 'UKickedPlayerWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UKickedPlayerWidget, IdTextBlock) == 0x0002F0, "Member 'UKickedPlayerWidget::IdTextBlock' has a wrong offset!");
static_assert(offsetof(UKickedPlayerWidget, KickTimeTextBlock) == 0x0002F8, "Member 'UKickedPlayerWidget::KickTimeTextBlock' has a wrong offset!");
static_assert(offsetof(UKickedPlayerWidget, KickDurationTextBlock) == 0x000300, "Member 'UKickedPlayerWidget::KickDurationTextBlock' has a wrong offset!");
static_assert(offsetof(UKickedPlayerWidget, KickTimeRemainingTextBlock) == 0x000308, "Member 'UKickedPlayerWidget::KickTimeRemainingTextBlock' has a wrong offset!");

// Class BrickRigs.BrickEditorObjectStaticInfo
// 0x0068 (0x0090 - 0x0028)
class UBrickEditorObjectStaticInfo : public UObject
{
public:
	TSubclassOf<class UBrickEditorObject>         ObjectClass;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ObjectTypeDisplayName;                             // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMirrorMode                                   MirrorMode;                                        // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         MirrorClassOverride;                               // 0x0068(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MirrorRotationOrigin;                              // 0x0080(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObjectStaticInfo">();
	}
	static class UBrickEditorObjectStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObjectStaticInfo>();
	}
};
static_assert(alignof(UBrickEditorObjectStaticInfo) == 0x000008, "Wrong alignment on UBrickEditorObjectStaticInfo");
static_assert(sizeof(UBrickEditorObjectStaticInfo) == 0x000090, "Wrong size on UBrickEditorObjectStaticInfo");
static_assert(offsetof(UBrickEditorObjectStaticInfo, ObjectClass) == 0x000028, "Member 'UBrickEditorObjectStaticInfo::ObjectClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, ObjectTypeDisplayName) == 0x000030, "Member 'UBrickEditorObjectStaticInfo::ObjectTypeDisplayName' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, Description) == 0x000048, "Member 'UBrickEditorObjectStaticInfo::Description' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, Price) == 0x000060, "Member 'UBrickEditorObjectStaticInfo::Price' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, MirrorMode) == 0x000064, "Member 'UBrickEditorObjectStaticInfo::MirrorMode' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, MirrorClassOverride) == 0x000068, "Member 'UBrickEditorObjectStaticInfo::MirrorClassOverride' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectStaticInfo, MirrorRotationOrigin) == 0x000080, "Member 'UBrickEditorObjectStaticInfo::MirrorRotationOrigin' has a wrong offset!");

// Class BrickRigs.BrickEditorObject
// 0x0060 (0x0088 - 0x0028)
class UBrickEditorObject : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 StaticInfoClass;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FTransform GetBodyTransform() const;
	class ABrickEditor* GetBrickEditor() const;
	struct FVector GetBrickEditorObjectBoundsOrigin() const;
	class FText GetBrickEditorObjectDisplayName() const;
	bool GetBrickEditorObjectLocalBounds(struct FVector* OutBoundsMin, struct FVector* OutBoundsMax) const;
	struct FVector GetBrickEditorObjectSpawnLocation() const;
	struct FRotator GetBrickEditorObjectSpawnRotation() const;
	struct FTransform GetBrickEditorObjectSpawnTransform() const;
	class FText GetBrickEditorObjectTypeDisplayName() const;
	const class UBrickEditorStaticInfo* GetBrickEditorStaticInfo() const;
	class UBrickEditorInterfaceComponent* GetEditorInterface() const;
	const struct FBrickEditorObjectID GetEditorObjectID() const;
	class UPrimitiveComponent* GetRootComponent() const;
	const class UBrickEditorObjectStaticInfo* GetStaticInfo() const;
	class UClass* GetStaticInfoClass() const;
	struct FTransform GetWorldTransform() const;
	bool IsBrickEditorObjectBeingInitialized() const;
	bool IsBrickEditorObjectBeingUninitialized() const;
	bool IsBrickEditorObjectInitialized() const;
	bool IsInEditor() const;
	bool IsInThumbnailRender() const;
	bool IsSpawned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObject">();
	}
	static class UBrickEditorObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObject>();
	}
};
static_assert(alignof(UBrickEditorObject) == 0x000008, "Wrong alignment on UBrickEditorObject");
static_assert(sizeof(UBrickEditorObject) == 0x000088, "Wrong size on UBrickEditorObject");
static_assert(offsetof(UBrickEditorObject, StaticInfoClass) == 0x000030, "Member 'UBrickEditorObject::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.Brick
// 0x0070 (0x00F8 - 0x0088)
class UBrick : public UBrickEditorObject
{
public:
	TArray<class UBrickConnection*>               BrickConnections;                                  // 0x0088(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBrick*                                 BrickPartRoot;                                     // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrick*                                 BrickClusterRoot;                                  // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x16];                                      // 0x00A8(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableBlueprintEvents : 1;                        // 0x00BE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BF[0x1];                                       // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickTickFunction                     PrimaryBrickTick;                                  // 0x00C0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UBrickMaterial*                         BrickMaterial;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 BrickColor;                                        // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickPattern>              BrickPattern;                                      // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGenerateLift;                                     // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlay();
	bool ClusterConsumeFuel(float Amount);
	void EndPlay();
	bool ExtinguishFire();
	void Interact_PickUp(class ABrickPlayerController* OtherPC);
	void MarkBrickBurnt();
	void Repair();
	void SetIsBrickBurnt(bool bNewBurnt);
	void SetIsBrickDamaged(bool bNewDamaged);
	bool SetOnFire();
	void Tick(float DeltaTime);
	bool UpdateBrickTickEnabled();

	bool CanBrickBurn() const;
	bool ClusterRootHasAnyFuel() const;
	class UBrick* GetBrickClusterRoot() const;
	const TArray<class UBrickConnection*> GetBrickConnections() const;
	class UBrick* GetBrickPartRoot() const;
	class ABrickVehicle* GetVehicle() const;
	class UBrickVehicleComponent* GetVehicleComponent() const;
	const class UBrickVehicleStaticInfo* GetVehicleStaticInfo() const;
	bool IsBrickBurnt() const;
	bool IsBrickClusterRoot() const;
	bool IsBrickDamaged() const;
	bool IsBrickPartRoot() const;
	bool IsBrickTickEnabled() const;
	bool IsConnectedToAnyBrick() const;
	bool IsConnectedToRoot() const;
	bool IsControllable() const;
	bool IsOnFire() const;
	bool ShouldTick() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Brick">();
	}
	static class UBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrick>();
	}
};
static_assert(alignof(UBrick) == 0x000008, "Wrong alignment on UBrick");
static_assert(sizeof(UBrick) == 0x0000F8, "Wrong size on UBrick");
static_assert(offsetof(UBrick, BrickConnections) == 0x000088, "Member 'UBrick::BrickConnections' has a wrong offset!");
static_assert(offsetof(UBrick, BrickPartRoot) == 0x000098, "Member 'UBrick::BrickPartRoot' has a wrong offset!");
static_assert(offsetof(UBrick, BrickClusterRoot) == 0x0000A0, "Member 'UBrick::BrickClusterRoot' has a wrong offset!");
static_assert(offsetof(UBrick, PrimaryBrickTick) == 0x0000C0, "Member 'UBrick::PrimaryBrickTick' has a wrong offset!");
static_assert(offsetof(UBrick, BrickMaterial) == 0x0000D8, "Member 'UBrick::BrickMaterial' has a wrong offset!");
static_assert(offsetof(UBrick, BrickColor) == 0x0000E0, "Member 'UBrick::BrickColor' has a wrong offset!");
static_assert(offsetof(UBrick, BrickPattern) == 0x0000E8, "Member 'UBrick::BrickPattern' has a wrong offset!");
static_assert(offsetof(UBrick, bGenerateLift) == 0x0000F0, "Member 'UBrick::bGenerateLift' has a wrong offset!");

// Class BrickRigs.ScalableBrickBase
// 0x0018 (0x0110 - 0x00F8)
class UScalableBrickBase : public UBrick
{
public:
	uint8                                         Pad_F8[0x14];                                      // 0x00F8(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableBrickConnectorSpacing         ConnectorSpacing;                                  // 0x010C(0x0002)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E[0x2];                                      // 0x010E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableBrickBase">();
	}
	static class UScalableBrickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableBrickBase>();
	}
};
static_assert(alignof(UScalableBrickBase) == 0x000008, "Wrong alignment on UScalableBrickBase");
static_assert(sizeof(UScalableBrickBase) == 0x000110, "Wrong size on UScalableBrickBase");
static_assert(offsetof(UScalableBrickBase, ConnectorSpacing) == 0x00010C, "Member 'UScalableBrickBase::ConnectorSpacing' has a wrong offset!");

// Class BrickRigs.BrickBorder
// 0x0010 (0x0280 - 0x0270)
class UBrickBorder final : public UBorder
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUIBrushStyle                            BrushStyle;                                        // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIStyleState                            StyleState;                                        // 0x027A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIPaddingStyle                          PaddingStyle;                                      // 0x027B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBrushStyle(EBrickUIBrushStyle NewStyle);
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetPaddingStyle(EBrickUIPaddingStyle NewStyle);
	void SetStyleState(EBrickUIStyleState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBorder">();
	}
	static class UBrickBorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickBorder>();
	}
};
static_assert(alignof(UBrickBorder) == 0x000008, "Wrong alignment on UBrickBorder");
static_assert(sizeof(UBrickBorder) == 0x000280, "Wrong size on UBrickBorder");
static_assert(offsetof(UBrickBorder, BrushStyle) == 0x000278, "Member 'UBrickBorder::BrushStyle' has a wrong offset!");
static_assert(offsetof(UBrickBorder, ColorStyle) == 0x000279, "Member 'UBrickBorder::ColorStyle' has a wrong offset!");
static_assert(offsetof(UBrickBorder, StyleState) == 0x00027A, "Member 'UBrickBorder::StyleState' has a wrong offset!");
static_assert(offsetof(UBrickBorder, PaddingStyle) == 0x00027B, "Member 'UBrickBorder::PaddingStyle' has a wrong offset!");

// Class BrickRigs.CameraBrickWidget
// 0x0018 (0x0278 - 0x0260)
class UCameraBrickWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0xC];                                      // 0x0260(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateTargetRange;                                // 0x026C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetRangeUpdateInterval;                         // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateTargetRange(bool bHitSomething, float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBrickWidget">();
	}
	static class UCameraBrickWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBrickWidget>();
	}
};
static_assert(alignof(UCameraBrickWidget) == 0x000008, "Wrong alignment on UCameraBrickWidget");
static_assert(sizeof(UCameraBrickWidget) == 0x000278, "Wrong size on UCameraBrickWidget");
static_assert(offsetof(UCameraBrickWidget, bUpdateTargetRange) == 0x00026C, "Member 'UCameraBrickWidget::bUpdateTargetRange' has a wrong offset!");
static_assert(offsetof(UCameraBrickWidget, TargetRangeUpdateInterval) == 0x000270, "Member 'UCameraBrickWidget::TargetRangeUpdateInterval' has a wrong offset!");

// Class BrickRigs.BrickStaticInfo
// 0x00D8 (0x0168 - 0x0090)
class UBrickStaticInfo : public UBrickEditorObjectStaticInfo
{
public:
	float                                         LiftSurfaceRadius;                                 // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LiftSurfaceLocation;                               // 0x0094(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LiftSurfaceNormal;                                 // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            StaticMesh;                                        // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickMaterial*                         DefaultBrickMaterial;                              // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultMaterial;                                   // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TranslucentMaterial;                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HiddenMaterial;                                    // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PhysicsVisualizationMaterial;                      // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ThumbnailBrickColor;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BrickSize;                                         // 0x00E4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendBrickSizeToDisplayName;                     // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PricePerSize;                                      // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConnectorField>                Connectors;                                        // 0x00F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MaxConnectorDist;                                  // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassScale;                                         // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayMassScale;                                  // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InertiaTensorScale;                                // 0x0114(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickPhysicalMaterial*                 PhysicalMaterialOverride;                          // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bGenerateFluidDynamicSurface : 1;                  // 0x0128(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDefaultGenerateLift : 1;                          // 0x0128(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCalculatePhysicsPropertiesFromShapes : 1;         // 0x0128(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Volume;                                            // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterOfMass;                                      // 0x0130(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InertiaTensor0;                                    // 0x013C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InertiaTensor1;                                    // 0x0148(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InertiaTensor2;                                    // 0x0154(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MovementReplicationPriority;                       // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickStaticInfo">();
	}
	static class UBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickStaticInfo>();
	}
};
static_assert(alignof(UBrickStaticInfo) == 0x000008, "Wrong alignment on UBrickStaticInfo");
static_assert(sizeof(UBrickStaticInfo) == 0x000168, "Wrong size on UBrickStaticInfo");
static_assert(offsetof(UBrickStaticInfo, LiftSurfaceRadius) == 0x000090, "Member 'UBrickStaticInfo::LiftSurfaceRadius' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, LiftSurfaceLocation) == 0x000094, "Member 'UBrickStaticInfo::LiftSurfaceLocation' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, LiftSurfaceNormal) == 0x0000A0, "Member 'UBrickStaticInfo::LiftSurfaceNormal' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, StaticMesh) == 0x0000B0, "Member 'UBrickStaticInfo::StaticMesh' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, DefaultBrickMaterial) == 0x0000B8, "Member 'UBrickStaticInfo::DefaultBrickMaterial' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, DefaultMaterial) == 0x0000C0, "Member 'UBrickStaticInfo::DefaultMaterial' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, TranslucentMaterial) == 0x0000C8, "Member 'UBrickStaticInfo::TranslucentMaterial' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, HiddenMaterial) == 0x0000D0, "Member 'UBrickStaticInfo::HiddenMaterial' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, PhysicsVisualizationMaterial) == 0x0000D8, "Member 'UBrickStaticInfo::PhysicsVisualizationMaterial' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, ThumbnailBrickColor) == 0x0000E0, "Member 'UBrickStaticInfo::ThumbnailBrickColor' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, BrickSize) == 0x0000E4, "Member 'UBrickStaticInfo::BrickSize' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, bAppendBrickSizeToDisplayName) == 0x0000F0, "Member 'UBrickStaticInfo::bAppendBrickSizeToDisplayName' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, PricePerSize) == 0x0000F4, "Member 'UBrickStaticInfo::PricePerSize' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, Connectors) == 0x0000F8, "Member 'UBrickStaticInfo::Connectors' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, MaxConnectorDist) == 0x000108, "Member 'UBrickStaticInfo::MaxConnectorDist' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, MassScale) == 0x00010C, "Member 'UBrickStaticInfo::MassScale' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, DisplayMassScale) == 0x000110, "Member 'UBrickStaticInfo::DisplayMassScale' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, InertiaTensorScale) == 0x000114, "Member 'UBrickStaticInfo::InertiaTensorScale' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, PhysicalMaterialOverride) == 0x000120, "Member 'UBrickStaticInfo::PhysicalMaterialOverride' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, Volume) == 0x00012C, "Member 'UBrickStaticInfo::Volume' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, CenterOfMass) == 0x000130, "Member 'UBrickStaticInfo::CenterOfMass' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, InertiaTensor0) == 0x00013C, "Member 'UBrickStaticInfo::InertiaTensor0' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, InertiaTensor1) == 0x000148, "Member 'UBrickStaticInfo::InertiaTensor1' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, InertiaTensor2) == 0x000154, "Member 'UBrickStaticInfo::InertiaTensor2' has a wrong offset!");
static_assert(offsetof(UBrickStaticInfo, MovementReplicationPriority) == 0x000160, "Member 'UBrickStaticInfo::MovementReplicationPriority' has a wrong offset!");

// Class BrickRigs.BrickBuildingDebris
// 0x0050 (0x0270 - 0x0220)
class ABrickBuildingDebris : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          DebrisMeshComponent;                               // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               CollapsePSC;                                       // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CollapseAC;                                        // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            DebrisMesh;                                        // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebrisSpacing;                                     // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DebrisLocationJitter;                              // 0x024C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebrisRotationJitter;                              // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             CollapseSound;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        CollapseEmitter;                                   // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBuildingDebris">();
	}
	static class ABrickBuildingDebris* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickBuildingDebris>();
	}
};
static_assert(alignof(ABrickBuildingDebris) == 0x000008, "Wrong alignment on ABrickBuildingDebris");
static_assert(sizeof(ABrickBuildingDebris) == 0x000270, "Wrong size on ABrickBuildingDebris");
static_assert(offsetof(ABrickBuildingDebris, DebrisMeshComponent) == 0x000228, "Member 'ABrickBuildingDebris::DebrisMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, CollapsePSC) == 0x000230, "Member 'ABrickBuildingDebris::CollapsePSC' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, CollapseAC) == 0x000238, "Member 'ABrickBuildingDebris::CollapseAC' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, DebrisMesh) == 0x000240, "Member 'ABrickBuildingDebris::DebrisMesh' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, DebrisSpacing) == 0x000248, "Member 'ABrickBuildingDebris::DebrisSpacing' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, DebrisLocationJitter) == 0x00024C, "Member 'ABrickBuildingDebris::DebrisLocationJitter' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, DebrisRotationJitter) == 0x000258, "Member 'ABrickBuildingDebris::DebrisRotationJitter' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, CollapseSound) == 0x000260, "Member 'ABrickBuildingDebris::CollapseSound' has a wrong offset!");
static_assert(offsetof(ABrickBuildingDebris, CollapseEmitter) == 0x000268, "Member 'ABrickBuildingDebris::CollapseEmitter' has a wrong offset!");

// Class BrickRigs.HUDIconWidget
// 0x0028 (0x0288 - 0x0260)
class UHUDIconWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickImage*                            IconImage;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              IconSize;                                          // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void InitializeIcon();
	void PostInitializeIcon();
	void SetIconColorStyle(EBrickUIColorStyle NewColorStyle);
	void SetIconSlot(const struct FBrickUIIconSlot& NewSlot);
	void UninitializeIcon();
	void UpdateIconRotation(float NewRotation);
	void UpdateIconStyle(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InStyleState);
	void UpdateNameText();

	class FText GetIconDisplayName() const;
	bool GetIconWorldRotation(float* OutRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDIconWidget">();
	}
	static class UHUDIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDIconWidget>();
	}
};
static_assert(alignof(UHUDIconWidget) == 0x000008, "Wrong alignment on UHUDIconWidget");
static_assert(sizeof(UHUDIconWidget) == 0x000288, "Wrong size on UHUDIconWidget");
static_assert(offsetof(UHUDIconWidget, IconImage) == 0x000278, "Member 'UHUDIconWidget::IconImage' has a wrong offset!");
static_assert(offsetof(UHUDIconWidget, IconSize) == 0x000280, "Member 'UHUDIconWidget::IconSize' has a wrong offset!");

// Class BrickRigs.InteractionIconWidget
// 0x0000 (0x0288 - 0x0288)
class UInteractionIconWidget : public UHUDIconWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionIconWidget">();
	}
	static class UInteractionIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionIconWidget>();
	}
};
static_assert(alignof(UInteractionIconWidget) == 0x000008, "Wrong alignment on UInteractionIconWidget");
static_assert(sizeof(UInteractionIconWidget) == 0x000288, "Wrong size on UInteractionIconWidget");

// Class BrickRigs.ActuatorBrickBaseStaticInfo
// 0x0010 (0x0178 - 0x0168)
class UActuatorBrickBaseStaticInfo : public UBrickStaticInfo
{
public:
	EAxis                                         ActuationAxis;                                     // 0x0168(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearActuationOffset;                             // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinearActuationRange;                              // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActuatorBrickBaseStaticInfo">();
	}
	static class UActuatorBrickBaseStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActuatorBrickBaseStaticInfo>();
	}
};
static_assert(alignof(UActuatorBrickBaseStaticInfo) == 0x000008, "Wrong alignment on UActuatorBrickBaseStaticInfo");
static_assert(sizeof(UActuatorBrickBaseStaticInfo) == 0x000178, "Wrong size on UActuatorBrickBaseStaticInfo");
static_assert(offsetof(UActuatorBrickBaseStaticInfo, ActuationAxis) == 0x000168, "Member 'UActuatorBrickBaseStaticInfo::ActuationAxis' has a wrong offset!");
static_assert(offsetof(UActuatorBrickBaseStaticInfo, LinearActuationOffset) == 0x00016C, "Member 'UActuatorBrickBaseStaticInfo::LinearActuationOffset' has a wrong offset!");
static_assert(offsetof(UActuatorBrickBaseStaticInfo, LinearActuationRange) == 0x000170, "Member 'UActuatorBrickBaseStaticInfo::LinearActuationRange' has a wrong offset!");

// Class BrickRigs.CameraBrickStaticInfo
// 0x05D8 (0x0740 - 0x0168)
#pragma pack(push, 0x1)
class alignas(0x10) UCameraBrickStaticInfo : public UBrickStaticInfo
{
public:
	struct FVector                                LenseOffset;                                       // 0x0168(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetZoomParams                  ZoomParams;                                        // 0x0174(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bViewRotationInWorldSpace;                         // 0x018C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateViewWhenInteracting;                        // 0x018D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0190(0x0560)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     NotConnectedPostProcessMaterial;                   // 0x06F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HUDWidgetClass;                                    // 0x06F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetRange;                                    // 0x0720(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewPitchRange;                                    // 0x0724(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewYawRange;                                      // 0x072C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_734[0x4];                                      // 0x0734(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBrickStaticInfo">();
	}
	static class UCameraBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBrickStaticInfo>();
	}
};
#pragma pack(pop)
static_assert(alignof(UCameraBrickStaticInfo) == 0x000010, "Wrong alignment on UCameraBrickStaticInfo");
static_assert(sizeof(UCameraBrickStaticInfo) == 0x000740, "Wrong size on UCameraBrickStaticInfo");
static_assert(offsetof(UCameraBrickStaticInfo, LenseOffset) == 0x000168, "Member 'UCameraBrickStaticInfo::LenseOffset' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, ZoomParams) == 0x000174, "Member 'UCameraBrickStaticInfo::ZoomParams' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, bViewRotationInWorldSpace) == 0x00018C, "Member 'UCameraBrickStaticInfo::bViewRotationInWorldSpace' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, bRotateViewWhenInteracting) == 0x00018D, "Member 'UCameraBrickStaticInfo::bRotateViewWhenInteracting' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, PostProcessSettings) == 0x000190, "Member 'UCameraBrickStaticInfo::PostProcessSettings' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, NotConnectedPostProcessMaterial) == 0x0006F0, "Member 'UCameraBrickStaticInfo::NotConnectedPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, HUDWidgetClass) == 0x0006F8, "Member 'UCameraBrickStaticInfo::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, MaxTargetRange) == 0x000720, "Member 'UCameraBrickStaticInfo::MaxTargetRange' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, ViewPitchRange) == 0x000724, "Member 'UCameraBrickStaticInfo::ViewPitchRange' has a wrong offset!");
static_assert(offsetof(UCameraBrickStaticInfo, ViewYawRange) == 0x00072C, "Member 'UCameraBrickStaticInfo::ViewYawRange' has a wrong offset!");

// Class BrickRigs.BaseCharacterMovementComponent
// 0x0010 (0x0B00 - 0x0AF0)
class UBaseCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_AF0[0xC];                                      // 0x0AF0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSprintSpeed;                                    // 0x0AFC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacterMovementComponent">();
	}
	static class UBaseCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCharacterMovementComponent>();
	}
};
static_assert(alignof(UBaseCharacterMovementComponent) == 0x000010, "Wrong alignment on UBaseCharacterMovementComponent");
static_assert(sizeof(UBaseCharacterMovementComponent) == 0x000B00, "Wrong size on UBaseCharacterMovementComponent");
static_assert(offsetof(UBaseCharacterMovementComponent, MaxSprintSpeed) == 0x000AFC, "Member 'UBaseCharacterMovementComponent::MaxSprintSpeed' has a wrong offset!");

// Class BrickRigs.BrickCharacterMovementComponent
// 0x0000 (0x0B00 - 0x0B00)
class UBrickCharacterMovementComponent final : public UBaseCharacterMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickCharacterMovementComponent">();
	}
	static class UBrickCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickCharacterMovementComponent>();
	}
};
static_assert(alignof(UBrickCharacterMovementComponent) == 0x000010, "Wrong alignment on UBrickCharacterMovementComponent");
static_assert(sizeof(UBrickCharacterMovementComponent) == 0x000B00, "Wrong size on UBrickCharacterMovementComponent");

// Class BrickRigs.AdminLoginWidget
// 0x0038 (0x0298 - 0x0260)
class UAdminLoginWidget : public UUserWidget
{
public:
	class UBrickTextBoxWidget*                    TextBox;                                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   EnterPasswordText;                                 // 0x0268(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   LoggedInText;                                      // 0x0280(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnTextChanged(const class FText& Text, EValueChangedEventType EventType);
	void UpdateCanEverBeAdmin(bool bCanBeAdmin);
	void UpdateIsAdmin(bool bNewIsAdmin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdminLoginWidget">();
	}
	static class UAdminLoginWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdminLoginWidget>();
	}
};
static_assert(alignof(UAdminLoginWidget) == 0x000008, "Wrong alignment on UAdminLoginWidget");
static_assert(sizeof(UAdminLoginWidget) == 0x000298, "Wrong size on UAdminLoginWidget");
static_assert(offsetof(UAdminLoginWidget, TextBox) == 0x000260, "Member 'UAdminLoginWidget::TextBox' has a wrong offset!");
static_assert(offsetof(UAdminLoginWidget, EnterPasswordText) == 0x000268, "Member 'UAdminLoginWidget::EnterPasswordText' has a wrong offset!");
static_assert(offsetof(UAdminLoginWidget, LoggedInText) == 0x000280, "Member 'UAdminLoginWidget::LoggedInText' has a wrong offset!");

// Class BrickRigs.BrickBuilding
// 0x00A0 (0x02C0 - 0x0220)
class alignas(0x10) ABrickBuilding : public AActor
{
public:
	uint8                                         Pad_220[0x30];                                     // 0x0220(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BuildingBoundsOrigin;                              // 0x0250(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BuildingBoundsExtent;                              // 0x025C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0xC];                                      // 0x0268(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bCollapsed : 1;                                    // 0x0274(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         CollapseAxisCompressed;                            // 0x0275(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_276[0xA];                                      // 0x0276(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickBuildingDebris*                   DebrisActor;                                       // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            StaticMesh;                                        // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInterface*>             RandomMaterials;                                   // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRandomStream                          RandomStream;                                      // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxDamage;                                         // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABrickBuildingDebris>       DebrisClass;                                       // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_bCollapsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBuilding">();
	}
	static class ABrickBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickBuilding>();
	}
};
static_assert(alignof(ABrickBuilding) == 0x000010, "Wrong alignment on ABrickBuilding");
static_assert(sizeof(ABrickBuilding) == 0x0002C0, "Wrong size on ABrickBuilding");
static_assert(offsetof(ABrickBuilding, BuildingBoundsOrigin) == 0x000250, "Member 'ABrickBuilding::BuildingBoundsOrigin' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, BuildingBoundsExtent) == 0x00025C, "Member 'ABrickBuilding::BuildingBoundsExtent' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, CollapseAxisCompressed) == 0x000275, "Member 'ABrickBuilding::CollapseAxisCompressed' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, DebrisActor) == 0x000280, "Member 'ABrickBuilding::DebrisActor' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, StaticMeshComponent) == 0x000288, "Member 'ABrickBuilding::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, StaticMesh) == 0x000290, "Member 'ABrickBuilding::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, RandomMaterials) == 0x000298, "Member 'ABrickBuilding::RandomMaterials' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, RandomStream) == 0x0002A8, "Member 'ABrickBuilding::RandomStream' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, MaxDamage) == 0x0002B0, "Member 'ABrickBuilding::MaxDamage' has a wrong offset!");
static_assert(offsetof(ABrickBuilding, DebrisClass) == 0x0002B8, "Member 'ABrickBuilding::DebrisClass' has a wrong offset!");

// Class BrickRigs.ActuatorBrickStaticInfo
// 0x0020 (0x0198 - 0x0178)
class UActuatorBrickStaticInfo : public UActuatorBrickBaseStaticInfo
{
public:
	bool                                          bIsAngularActuator;                                // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActuationSpeed;                                    // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLegacyLinearSlider;                             // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ActuatorSound;                                     // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReplicationErrorSmoothTime;                        // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActuatorBrickStaticInfo">();
	}
	static class UActuatorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActuatorBrickStaticInfo>();
	}
};
static_assert(alignof(UActuatorBrickStaticInfo) == 0x000008, "Wrong alignment on UActuatorBrickStaticInfo");
static_assert(sizeof(UActuatorBrickStaticInfo) == 0x000198, "Wrong size on UActuatorBrickStaticInfo");
static_assert(offsetof(UActuatorBrickStaticInfo, bIsAngularActuator) == 0x000178, "Member 'UActuatorBrickStaticInfo::bIsAngularActuator' has a wrong offset!");
static_assert(offsetof(UActuatorBrickStaticInfo, ActuationSpeed) == 0x00017C, "Member 'UActuatorBrickStaticInfo::ActuationSpeed' has a wrong offset!");
static_assert(offsetof(UActuatorBrickStaticInfo, bIsLegacyLinearSlider) == 0x000180, "Member 'UActuatorBrickStaticInfo::bIsLegacyLinearSlider' has a wrong offset!");
static_assert(offsetof(UActuatorBrickStaticInfo, ActuatorSound) == 0x000188, "Member 'UActuatorBrickStaticInfo::ActuatorSound' has a wrong offset!");
static_assert(offsetof(UActuatorBrickStaticInfo, ReplicationErrorSmoothTime) == 0x000190, "Member 'UActuatorBrickStaticInfo::ReplicationErrorSmoothTime' has a wrong offset!");

// Class BrickRigs.ButtonWidgetBase
// 0x0020 (0x0280 - 0x0260)
class UButtonWidgetBase : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickBorder*                           Border;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIBrushStyle                            BrushStyle;                                        // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenWhileUnfocused;                             // 0x027A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x027B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateContentStyle(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InStyleState);
	void SetBrushStyle(EBrickUIBrushStyle NewBrushStyle);
	void SetColorStyle(EBrickUIColorStyle NewColorStyle);
	void SetCustomFocus(bool bNewUseCustomFocus, bool bNewFocused);
	void SetHiddenWhileUnfocused(bool bNewHidden);
	void SetIsSelected(bool bNewSelected);
	void UpdateContentStyle();

	EBrickUIStyleState GetButtonStyleState() const;
	EBrickUIStyleState GetContentStyleState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonWidgetBase">();
	}
	static class UButtonWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButtonWidgetBase>();
	}
};
static_assert(alignof(UButtonWidgetBase) == 0x000008, "Wrong alignment on UButtonWidgetBase");
static_assert(sizeof(UButtonWidgetBase) == 0x000280, "Wrong size on UButtonWidgetBase");
static_assert(offsetof(UButtonWidgetBase, Border) == 0x000270, "Member 'UButtonWidgetBase::Border' has a wrong offset!");
static_assert(offsetof(UButtonWidgetBase, ColorStyle) == 0x000278, "Member 'UButtonWidgetBase::ColorStyle' has a wrong offset!");
static_assert(offsetof(UButtonWidgetBase, BrushStyle) == 0x000279, "Member 'UButtonWidgetBase::BrushStyle' has a wrong offset!");
static_assert(offsetof(UButtonWidgetBase, bHiddenWhileUnfocused) == 0x00027A, "Member 'UButtonWidgetBase::bHiddenWhileUnfocused' has a wrong offset!");
static_assert(offsetof(UButtonWidgetBase, bIsSelected) == 0x00027B, "Member 'UButtonWidgetBase::bIsSelected' has a wrong offset!");

// Class BrickRigs.ScalableBrick
// 0x0010 (0x0120 - 0x0110)
class UScalableBrick : public UScalableBrickBase
{
public:
	uint8                                         Pad_110[0x4];                                      // 0x0110(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BrickSize;                                         // 0x0114(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableBrick">();
	}
	static class UScalableBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableBrick>();
	}
};
static_assert(alignof(UScalableBrick) == 0x000008, "Wrong alignment on UScalableBrick");
static_assert(sizeof(UScalableBrick) == 0x000120, "Wrong size on UScalableBrick");
static_assert(offsetof(UScalableBrick, BrickSize) == 0x000114, "Member 'UScalableBrick::BrickSize' has a wrong offset!");

// Class BrickRigs.DisplayBrick
// 0x0038 (0x0158 - 0x0120)
class UDisplayBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0128(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 DisplayColor;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         NumFractionalDigits;                               // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayBrick">();
	}
	static class UDisplayBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayBrick>();
	}
};
static_assert(alignof(UDisplayBrick) == 0x000008, "Wrong alignment on UDisplayBrick");
static_assert(sizeof(UDisplayBrick) == 0x000158, "Wrong size on UDisplayBrick");
static_assert(offsetof(UDisplayBrick, InputChannel) == 0x000128, "Member 'UDisplayBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UDisplayBrick, DisplayColor) == 0x000150, "Member 'UDisplayBrick::DisplayColor' has a wrong offset!");
static_assert(offsetof(UDisplayBrick, NumFractionalDigits) == 0x000154, "Member 'UDisplayBrick::NumFractionalDigits' has a wrong offset!");

// Class BrickRigs.BrickButtonWidget
// 0x0090 (0x0310 - 0x0280)
class UBrickButtonWidget : public UButtonWidgetBase
{
public:
	struct FMargin                                ContentPadding;                                    // 0x0280(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBrickUIPaddingStyle                          ContentPaddingStyle;                               // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          ContentHorizontalAlignment;                        // 0x0291(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            ContentVerticalAlignment;                          // 0x0292(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293[0x5];                                      // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamedSlot*                             ContentSlot;                                       // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnClickedDelegate;                                 // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPressedDelegate;                                 // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReleasedDelegate;                                // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDoubleClickedDelegate;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)> OnDraggedDelegate; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bNewIsFocused)> OnIsFocusedChangedDelegate;                   // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InContentStyleState)> OnUpdateContentStyleDelegate; // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddContentWidget(class UWidget* InWidget);
	void SetContentHorizontalAlignment(EHorizontalAlignment InAlignment);
	void SetContentPadding(const struct FMargin& InPadding);
	void SetContentPaddingStyle(EBrickUIPaddingStyle InStyle);
	void SetContentVerticalAlignment(EVerticalAlignment InAlignment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickButtonWidget">();
	}
	static class UBrickButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickButtonWidget>();
	}
};
static_assert(alignof(UBrickButtonWidget) == 0x000008, "Wrong alignment on UBrickButtonWidget");
static_assert(sizeof(UBrickButtonWidget) == 0x000310, "Wrong size on UBrickButtonWidget");
static_assert(offsetof(UBrickButtonWidget, ContentPadding) == 0x000280, "Member 'UBrickButtonWidget::ContentPadding' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, ContentPaddingStyle) == 0x000290, "Member 'UBrickButtonWidget::ContentPaddingStyle' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, ContentHorizontalAlignment) == 0x000291, "Member 'UBrickButtonWidget::ContentHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, ContentVerticalAlignment) == 0x000292, "Member 'UBrickButtonWidget::ContentVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, ContentSlot) == 0x000298, "Member 'UBrickButtonWidget::ContentSlot' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnClickedDelegate) == 0x0002A0, "Member 'UBrickButtonWidget::OnClickedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnPressedDelegate) == 0x0002B0, "Member 'UBrickButtonWidget::OnPressedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnReleasedDelegate) == 0x0002C0, "Member 'UBrickButtonWidget::OnReleasedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnDoubleClickedDelegate) == 0x0002D0, "Member 'UBrickButtonWidget::OnDoubleClickedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnDraggedDelegate) == 0x0002E0, "Member 'UBrickButtonWidget::OnDraggedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnIsFocusedChangedDelegate) == 0x0002F0, "Member 'UBrickButtonWidget::OnIsFocusedChangedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickButtonWidget, OnUpdateContentStyleDelegate) == 0x000300, "Member 'UBrickButtonWidget::OnUpdateContentStyleDelegate' has a wrong offset!");

// Class BrickRigs.CapturePointIconWidget
// 0x0040 (0x02C8 - 0x0288)
class UCapturePointIconWidget : public UHUDIconWidget
{
public:
	class ABaseCharacter*                         PlayerCharacter;                                   // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACapturePoint*                          CapturePoint;                                      // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickImage*                            CaptureProgressImage;                              // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        CharTextBlock;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapturePointIconWidget">();
	}
	static class UCapturePointIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapturePointIconWidget>();
	}
};
static_assert(alignof(UCapturePointIconWidget) == 0x000008, "Wrong alignment on UCapturePointIconWidget");
static_assert(sizeof(UCapturePointIconWidget) == 0x0002C8, "Wrong size on UCapturePointIconWidget");
static_assert(offsetof(UCapturePointIconWidget, PlayerCharacter) == 0x000288, "Member 'UCapturePointIconWidget::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UCapturePointIconWidget, CapturePoint) == 0x000290, "Member 'UCapturePointIconWidget::CapturePoint' has a wrong offset!");
static_assert(offsetof(UCapturePointIconWidget, Mid) == 0x0002A8, "Member 'UCapturePointIconWidget::Mid' has a wrong offset!");
static_assert(offsetof(UCapturePointIconWidget, CaptureProgressImage) == 0x0002B8, "Member 'UCapturePointIconWidget::CaptureProgressImage' has a wrong offset!");
static_assert(offsetof(UCapturePointIconWidget, CharTextBlock) == 0x0002C0, "Member 'UCapturePointIconWidget::CharTextBlock' has a wrong offset!");

// Class BrickRigs.PopupWidget
// 0x0038 (0x0298 - 0x0260)
class UPopupWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TitleText;                                         // 0x0270(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EPopupSizeRule                                PopupSizeRule;                                     // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CloseActionName;                                   // 0x028C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelPopup();
	void ClosePopup(EPopupResult Result);
	bool ConfirmPopup();
	class UPopupParams* GetPopupParams(TSubclassOf<class UPopupParams> Class_0);
	class UWidget* GetWidgetToFocus();
	bool StepBack();
	void UpdatePopupTitle();

	bool CanPopupBeClosed() const;
	class UMenuButtonPanelWidget* GetButtonPanel() const;
	class UPopupContainerWidget* GetPopupContainer() const;
	EPopupSizeRule GetPopupSizeRule() const;
	class FText GetPopupTitle() const;
	bool ShouldBeVisibleInPopupContainer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupWidget">();
	}
	static class UPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupWidget>();
	}
};
static_assert(alignof(UPopupWidget) == 0x000008, "Wrong alignment on UPopupWidget");
static_assert(sizeof(UPopupWidget) == 0x000298, "Wrong size on UPopupWidget");
static_assert(offsetof(UPopupWidget, TitleText) == 0x000270, "Member 'UPopupWidget::TitleText' has a wrong offset!");
static_assert(offsetof(UPopupWidget, PopupSizeRule) == 0x000288, "Member 'UPopupWidget::PopupSizeRule' has a wrong offset!");
static_assert(offsetof(UPopupWidget, CloseActionName) == 0x00028C, "Member 'UPopupWidget::CloseActionName' has a wrong offset!");

// Class BrickRigs.InventoryPopupWidget
// 0x0058 (0x02F0 - 0x0298)
class UInventoryPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventorySlotWidget*                   DragWidget;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           DragCanvasPanel;                                   // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryContainerWidget*              OwnInventoryContainerWidget;                       // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryContainerWidget*              OtherInventoryContainerWidget;                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickButtonWidget*                     DropButton;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInventorySlotWidget>       SlotWidgetClass;                                   // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInventoryContainerWidget>  SubInvetoryContainerWidgetClass;                   // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDropButtonClicked();
	void UpdateDropArea(bool bInIsDragging, bool bInCanDrop, bool bInIsDragOver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPopupWidget">();
	}
	static class UInventoryPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryPopupWidget>();
	}
};
static_assert(alignof(UInventoryPopupWidget) == 0x000008, "Wrong alignment on UInventoryPopupWidget");
static_assert(sizeof(UInventoryPopupWidget) == 0x0002F0, "Wrong size on UInventoryPopupWidget");
static_assert(offsetof(UInventoryPopupWidget, DragWidget) == 0x0002A8, "Member 'UInventoryPopupWidget::DragWidget' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, DragCanvasPanel) == 0x0002C0, "Member 'UInventoryPopupWidget::DragCanvasPanel' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, OwnInventoryContainerWidget) == 0x0002C8, "Member 'UInventoryPopupWidget::OwnInventoryContainerWidget' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, OtherInventoryContainerWidget) == 0x0002D0, "Member 'UInventoryPopupWidget::OtherInventoryContainerWidget' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, DropButton) == 0x0002D8, "Member 'UInventoryPopupWidget::DropButton' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, SlotWidgetClass) == 0x0002E0, "Member 'UInventoryPopupWidget::SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UInventoryPopupWidget, SubInvetoryContainerWidgetClass) == 0x0002E8, "Member 'UInventoryPopupWidget::SubInvetoryContainerWidgetClass' has a wrong offset!");

// Class BrickRigs.ActuatorBrick
// 0x00E8 (0x01E0 - 0x00F8)
class UActuatorBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActuatorState                         RepActuatorState;                                  // 0x0108(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x70];                                     // 0x0118(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickPlayerController*                 InteractingPC;                                     // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x15];                                     // 0x0190(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	EActuatorMode                                 ActuatorMode;                                      // 0x01A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A6[0x2];                                      // 0x01A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpeedFactor;                                       // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxLimit;                                          // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinLimit;                                          // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_Actuate(class ABrickPlayerController* OtherPC, float Val);
	void OnRep_ActuatorState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActuatorBrick">();
	}
	static class UActuatorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActuatorBrick>();
	}
};
static_assert(alignof(UActuatorBrick) == 0x000008, "Wrong alignment on UActuatorBrick");
static_assert(sizeof(UActuatorBrick) == 0x0001E0, "Wrong size on UActuatorBrick");
static_assert(offsetof(UActuatorBrick, RepActuatorState) == 0x000108, "Member 'UActuatorBrick::RepActuatorState' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, InteractingPC) == 0x000188, "Member 'UActuatorBrick::InteractingPC' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, ActuatorMode) == 0x0001A5, "Member 'UActuatorBrick::ActuatorMode' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, InputChannel) == 0x0001A8, "Member 'UActuatorBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, SpeedFactor) == 0x0001D0, "Member 'UActuatorBrick::SpeedFactor' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, MaxLimit) == 0x0001D4, "Member 'UActuatorBrick::MaxLimit' has a wrong offset!");
static_assert(offsetof(UActuatorBrick, MinLimit) == 0x0001D8, "Member 'UActuatorBrick::MinLimit' has a wrong offset!");

// Class BrickRigs.MenuSequence
// 0x0020 (0x0240 - 0x0220)
class AMenuSequence : public AActor
{
public:
	struct FMenuSequenceProperties                MenuSequenceProperties;                            // 0x0220(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSequence">();
	}
	static class AMenuSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuSequence>();
	}
};
static_assert(alignof(AMenuSequence) == 0x000008, "Wrong alignment on AMenuSequence");
static_assert(sizeof(AMenuSequence) == 0x000240, "Wrong size on AMenuSequence");
static_assert(offsetof(AMenuSequence, MenuSequenceProperties) == 0x000220, "Member 'AMenuSequence::MenuSequenceProperties' has a wrong offset!");

// Class BrickRigs.MenuPageWidget
// 0x0010 (0x0270 - 0x0260)
class UMenuPageWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EMenuPageSize                                 MenuPageSize;                                      // 0x0268(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool StepBack();

	class UMenuWidget* GetMenuWidget() const;
	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPageWidget">();
	}
	static class UMenuPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPageWidget>();
	}
};
static_assert(alignof(UMenuPageWidget) == 0x000008, "Wrong alignment on UMenuPageWidget");
static_assert(sizeof(UMenuPageWidget) == 0x000270, "Wrong size on UMenuPageWidget");
static_assert(offsetof(UMenuPageWidget, MenuPageSize) == 0x000268, "Member 'UMenuPageWidget::MenuPageSize' has a wrong offset!");

// Class BrickRigs.BaseInputComponent
// 0x0038 (0x0170 - 0x0138)
class UBaseInputComponent : public UInputComponent
{
public:
	class ABasePlayerController*                  BasePlayerController;                              // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABrickPlayerController*                 PlayerController;                                  // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x24];                                     // 0x0148(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bShowInInputHelp : 1;                              // 0x016C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceConsumeInput : 1;                            // 0x016C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookRight(float Val);
	void LookUp(float Val);
	void MouseMoveRight(float Val);
	void MouseMoveUp(float Val);
	void OnPressedCycleHUDVisibility();
	void OnPressedPivotCamera();
	void OnPressedSpeedDownStep();
	void OnPressedSpeedUpStep();
	void OnPressedZoomInStep();
	void OnPressedZoomOutStep();
	void OnReleasedPivotCamera();
	void SpeedUp(float Val);
	void ZoomIn(float Val);

	class FText GetCycleHUDVisibilityValueText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseInputComponent">();
	}
	static class UBaseInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseInputComponent>();
	}
};
static_assert(alignof(UBaseInputComponent) == 0x000008, "Wrong alignment on UBaseInputComponent");
static_assert(sizeof(UBaseInputComponent) == 0x000170, "Wrong size on UBaseInputComponent");
static_assert(offsetof(UBaseInputComponent, BasePlayerController) == 0x000138, "Member 'UBaseInputComponent::BasePlayerController' has a wrong offset!");
static_assert(offsetof(UBaseInputComponent, PlayerController) == 0x000140, "Member 'UBaseInputComponent::PlayerController' has a wrong offset!");

// Class BrickRigs.PawnInputComponent
// 0x0060 (0x01D0 - 0x0170)
class UPawnInputComponent : public UBaseInputComponent
{
public:
	uint8                                         Pad_170[0x60];                                     // 0x0170(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeldCycleCharacters();
	void OnHeldCycleVehicles();
	void OnHeldDestroyPawn();
	void OnHeldFreeCamera();
	void OnHeldOpenVehicle();
	void OnHeldRecover();
	void OnHeldRecoverDummies();
	void OnHeldScrapAllVehicles();
	void OnHeldSlomoSpeedDown();
	void OnHeldSlomoSpeedUp();
	void OnHeldSlowMotion();
	void OnHeldToggleInvincible();
	void OnPressedCycleCharacters();
	void OnPressedCycleVehicles();
	void OnPressedDestroyPawn();
	void OnPressedFreeCamera();
	void OnPressedInventory();
	void OnPressedMap();
	void OnPressedOpenVehicle();
	void OnPressedProjectileCamera();
	void OnPressedRecover();
	void OnPressedRecoverDummies();
	void OnPressedScrapAllVehicles();
	void OnPressedSlomoSpeedDown();
	void OnPressedSlomoSpeedUp();
	void OnPressedSlowMotion();
	void OnPressedToggleInvincible();
	void OnReleasedCycleCharacters();
	void OnReleasedCycleVehicles();
	void OnReleasedDestroyPawn();
	void OnReleasedFreeCamera();
	void OnReleasedOpenVehicle();
	void OnReleasedRecover();
	void OnReleasedRecoverDummies();
	void OnReleasedScrapAllVehicles();
	void OnReleasedSlomoSpeedDown();
	void OnReleasedSlomoSpeedUp();
	void OnReleasedSlowMotion();
	void OnReleasedToggleInvincible();
	void OnTappedCycleCharacters();
	void OnTappedCycleVehicles();
	void OnTappedDestroyPawn();
	void OnTappedFreeCamera();
	void OnTappedOpenVehicle();
	void OnTappedRecover();
	void OnTappedRecoverDummies();
	void OnTappedScrapAllVehicles();
	void OnTappedSlomoSpeedDown();
	void OnTappedSlomoSpeedUp();
	void OnTappedSlowMotion();
	void OnTappedToggleInvincible();

	bool GetDestroyPawnEnabled(bool bInSecondaryAction) const;
	bool GetInventoryEnabled(bool bInSecondaryAction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnInputComponent">();
	}
	static class UPawnInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnInputComponent>();
	}
};
static_assert(alignof(UPawnInputComponent) == 0x000008, "Wrong alignment on UPawnInputComponent");
static_assert(sizeof(UPawnInputComponent) == 0x0001D0, "Wrong size on UPawnInputComponent");

// Class BrickRigs.BrickCheatManager
// 0x0100 (0x0188 - 0x0088)
class UBrickCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_88[0xC];                                       // 0x0088(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFPS;                                            // 0x0094(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowStatUnit;                                     // 0x0098(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGodMode;                                    // 0x0099(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUGCFileInfo                           VehicleToSpawn;                                    // 0x00A0(0x00E8)(Config, NativeAccessSpecifierPublic)

public:
	void AddMoney(float Amount);
	void AddScore(float Amount);
	void ForceSpectate();
	void SetTargetOnFire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickCheatManager">();
	}
	static class UBrickCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickCheatManager>();
	}
};
static_assert(alignof(UBrickCheatManager) == 0x000008, "Wrong alignment on UBrickCheatManager");
static_assert(sizeof(UBrickCheatManager) == 0x000188, "Wrong size on UBrickCheatManager");
static_assert(offsetof(UBrickCheatManager, MaxFPS) == 0x000094, "Member 'UBrickCheatManager::MaxFPS' has a wrong offset!");
static_assert(offsetof(UBrickCheatManager, bShowStatUnit) == 0x000098, "Member 'UBrickCheatManager::bShowStatUnit' has a wrong offset!");
static_assert(offsetof(UBrickCheatManager, bEnableGodMode) == 0x000099, "Member 'UBrickCheatManager::bEnableGodMode' has a wrong offset!");
static_assert(offsetof(UBrickCheatManager, VehicleToSpawn) == 0x0000A0, "Member 'UBrickCheatManager::VehicleToSpawn' has a wrong offset!");

// Class BrickRigs.AdminMenuWidget
// 0x0048 (0x02B8 - 0x0270)
class UAdminMenuWidget : public UMenuPageWidget
{
public:
	uint8                                         Pad_270[0x28];                                     // 0x0270(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPagedListWidget*                       PagedList;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKickedPlayerSortMethod                       KickedPlayerSortMethod;                            // 0x02A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 KickedPlayerSearchText;                            // 0x02A8(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EditKick();
	void KickPlayerById();
	void OnListEntrySelected(class UPagedListEntryWidget* Widget, bool bDoubleClick);
	void OnLoadListPage(int32 NewPage);
	void RefreshPlayerList();
	void ShowPlayerProfile();
	void UpdateCanViewAndEditKicks(bool bNewCanViewAndEdit);
	void UpdateHasSelectedKick(bool bNewSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdminMenuWidget">();
	}
	static class UAdminMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdminMenuWidget>();
	}
};
static_assert(alignof(UAdminMenuWidget) == 0x000008, "Wrong alignment on UAdminMenuWidget");
static_assert(sizeof(UAdminMenuWidget) == 0x0002B8, "Wrong size on UAdminMenuWidget");
static_assert(offsetof(UAdminMenuWidget, PagedList) == 0x000298, "Member 'UAdminMenuWidget::PagedList' has a wrong offset!");
static_assert(offsetof(UAdminMenuWidget, KickedPlayerSortMethod) == 0x0002A0, "Member 'UAdminMenuWidget::KickedPlayerSortMethod' has a wrong offset!");
static_assert(offsetof(UAdminMenuWidget, KickedPlayerSearchText) == 0x0002A8, "Member 'UAdminMenuWidget::KickedPlayerSearchText' has a wrong offset!");

// Class BrickRigs.KickPlayerPopupWidget
// 0x0010 (0x02A8 - 0x0298)
class UKickPlayerPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RevokeKick();
	void UpdateCanConfirmKick(bool bNewCanConfirm);
	void UpdateCanRevokeKick(bool bCanRevoke);
	void UpdateIsLoadingKick(bool bNewLoading);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickPlayerPopupWidget">();
	}
	static class UKickPlayerPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickPlayerPopupWidget>();
	}
};
static_assert(alignof(UKickPlayerPopupWidget) == 0x000008, "Wrong alignment on UKickPlayerPopupWidget");
static_assert(sizeof(UKickPlayerPopupWidget) == 0x0002A8, "Wrong size on UKickPlayerPopupWidget");
static_assert(offsetof(UKickPlayerPopupWidget, PropertiesPanel) == 0x0002A0, "Member 'UKickPlayerPopupWidget::PropertiesPanel' has a wrong offset!");

// Class BrickRigs.BrickUserWidget
// 0x0010 (0x0270 - 0x0260)
class UBrickUserWidget : public UUserWidget
{
public:
	TDelegate<void(struct FTooltipContent* OutContent)> GetTooltipContentDelegate;                   // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	bool GetTooltipContent(struct FTooltipContent* OutContent);
	void InitializeTooltip(class UTooltipWidget* Tooltip);

	class UClass* GetTooltipClass() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickUserWidget">();
	}
	static class UBrickUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickUserWidget>();
	}
};
static_assert(alignof(UBrickUserWidget) == 0x000008, "Wrong alignment on UBrickUserWidget");
static_assert(sizeof(UBrickUserWidget) == 0x000270, "Wrong size on UBrickUserWidget");
static_assert(offsetof(UBrickUserWidget, GetTooltipContentDelegate) == 0x000260, "Member 'UBrickUserWidget::GetTooltipContentDelegate' has a wrong offset!");

// Class BrickRigs.GunBrickStaticInfo
// 0x0138 (0x02A0 - 0x0168)
class UGunBrickStaticInfo : public UBrickStaticInfo
{
public:
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeMuzzleTransform;                           // 0x0170(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FFirearmProperties                     FirearmProperties;                                 // 0x01A0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint16                                        SupportedAmmoTypes;                                // 0x0230(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x6];                                      // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventoryLoadoutSlot                  InventoryAmmoSlot;                                 // 0x0238(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ReloadTime;                                        // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilImpulse;                                     // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBarrelLength;                                   // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpreadRadiusScale;                              // 0x0264(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinMuzzleVelocityScale;                            // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamageScale;                                    // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         ShellEmitter;                                      // 0x0270(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   ShellEmitterDetailMode;                            // 0x0298(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxShellEmitterDrawDistance;                       // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunBrickStaticInfo">();
	}
	static class UGunBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunBrickStaticInfo>();
	}
};
static_assert(alignof(UGunBrickStaticInfo) == 0x000010, "Wrong alignment on UGunBrickStaticInfo");
static_assert(sizeof(UGunBrickStaticInfo) == 0x0002A0, "Wrong size on UGunBrickStaticInfo");
static_assert(offsetof(UGunBrickStaticInfo, RelativeMuzzleTransform) == 0x000170, "Member 'UGunBrickStaticInfo::RelativeMuzzleTransform' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, FirearmProperties) == 0x0001A0, "Member 'UGunBrickStaticInfo::FirearmProperties' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, SupportedAmmoTypes) == 0x000230, "Member 'UGunBrickStaticInfo::SupportedAmmoTypes' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, InventoryAmmoSlot) == 0x000238, "Member 'UGunBrickStaticInfo::InventoryAmmoSlot' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, ReloadTime) == 0x000258, "Member 'UGunBrickStaticInfo::ReloadTime' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, RecoilImpulse) == 0x00025C, "Member 'UGunBrickStaticInfo::RecoilImpulse' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, MaxBarrelLength) == 0x000260, "Member 'UGunBrickStaticInfo::MaxBarrelLength' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, MinSpreadRadiusScale) == 0x000264, "Member 'UGunBrickStaticInfo::MinSpreadRadiusScale' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, MinMuzzleVelocityScale) == 0x000268, "Member 'UGunBrickStaticInfo::MinMuzzleVelocityScale' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, MinDamageScale) == 0x00026C, "Member 'UGunBrickStaticInfo::MinDamageScale' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, ShellEmitter) == 0x000270, "Member 'UGunBrickStaticInfo::ShellEmitter' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, ShellEmitterDetailMode) == 0x000298, "Member 'UGunBrickStaticInfo::ShellEmitterDetailMode' has a wrong offset!");
static_assert(offsetof(UGunBrickStaticInfo, MaxShellEmitterDrawDistance) == 0x00029C, "Member 'UGunBrickStaticInfo::MaxShellEmitterDrawDistance' has a wrong offset!");

// Class BrickRigs.InventoryItem
// 0x0048 (0x0270 - 0x0228)
class AInventoryItem : public AFluMoveSyncActor
{
public:
	uint8                                         Pad_228[0x10];                                     // 0x0228(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  InteractionComponent;                              // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventoryComponent*                    InventoryComponent;                                // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CollisionAudioComponent;                           // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UItemStaticInfo>            StaticInfoClass;                                   // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetInteractionOptions(class ABrickPlayerController* PC, struct FInteractionOptions* OutOptions);
	void Interact_PickUp(class ABrickPlayerController* PC);
	void OnDropped();
	void OnEquipped();
	void OnPickedUp();
	void OnStaticMeshSleep(class UPrimitiveComponent* Primitive, class FName BoneName);
	void OnUnequipped();
	void SetIsFiring(bool bNewFiring);
	void SetNumItems(int32 Num);

	bool CanBePickedUp() const;
	class ABrickCharacter* GetCharacter() const;
	class FText GetDisplayName() const;
	class UInventoryComponent* GetInventoryComponent() const;
	float GetItemPrice() const;
	int32 GetNumDefaultItems() const;
	int32 GetNumItems() const;
	class UInventoryComponent* GetOwningInventory() const;
	const class UItemStaticInfo* GetStaticInfo() const;
	class APlayerController* GetViewingPlayer() const;
	bool IsDropped() const;
	bool NeedsThumbnailMID() const;
	void UpdateThumbnailMID(class UMaterialInstanceDynamic* InMID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItem">();
	}
	static class AInventoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventoryItem>();
	}
};
static_assert(alignof(AInventoryItem) == 0x000008, "Wrong alignment on AInventoryItem");
static_assert(sizeof(AInventoryItem) == 0x000270, "Wrong size on AInventoryItem");
static_assert(offsetof(AInventoryItem, Mid) == 0x000238, "Member 'AInventoryItem::Mid' has a wrong offset!");
static_assert(offsetof(AInventoryItem, StaticMeshComponent) == 0x000240, "Member 'AInventoryItem::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItem, SkeletalMeshComponent) == 0x000248, "Member 'AInventoryItem::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItem, InteractionComponent) == 0x000250, "Member 'AInventoryItem::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItem, InventoryComponent) == 0x000258, "Member 'AInventoryItem::InventoryComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItem, CollisionAudioComponent) == 0x000260, "Member 'AInventoryItem::CollisionAudioComponent' has a wrong offset!");
static_assert(offsetof(AInventoryItem, StaticInfoClass) == 0x000268, "Member 'AInventoryItem::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.BrickComboBoxItemContainerWidget
// 0x0020 (0x0290 - 0x0270)
class UBrickComboBoxItemContainerWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComboBoxItemWidget*               ItemWidget;                                        // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddItemWidget(class UBrickComboBoxItemWidget* Widget);
	void OnUpdateButtonContentStyle(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InContentStyleState);
	void SelectItem();
	void UpdateIsSelected(bool bNewSelected);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComboBoxItemContainerWidget">();
	}
	static class UBrickComboBoxItemContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComboBoxItemContainerWidget>();
	}
};
static_assert(alignof(UBrickComboBoxItemContainerWidget) == 0x000008, "Wrong alignment on UBrickComboBoxItemContainerWidget");
static_assert(sizeof(UBrickComboBoxItemContainerWidget) == 0x000290, "Wrong size on UBrickComboBoxItemContainerWidget");
static_assert(offsetof(UBrickComboBoxItemContainerWidget, ItemWidget) == 0x000278, "Member 'UBrickComboBoxItemContainerWidget::ItemWidget' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxItemContainerWidget, Button) == 0x000288, "Member 'UBrickComboBoxItemContainerWidget::Button' has a wrong offset!");

// Class BrickRigs.AmmoBox
// 0x0008 (0x0278 - 0x0270)
class AAmmoBox : public AInventoryItem
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoBox">();
	}
	static class AAmmoBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAmmoBox>();
	}
};
static_assert(alignof(AAmmoBox) == 0x000008, "Wrong alignment on AAmmoBox");
static_assert(sizeof(AAmmoBox) == 0x000278, "Wrong size on AAmmoBox");

// Class BrickRigs.BrickComboBoxItemWidget
// 0x0058 (0x02C8 - 0x0270)
class UBrickComboBoxItemWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x48];                                     // 0x0270(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBlock*                        TextBlock;                                         // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            IconImage;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeItem(int32 InItem, const struct FBrickComboBoxItemParams& Params_0);
	void SetNoItemBrush();
	void UpdateIconVisibility(bool bNewVisible);
	void UpdateItemStyle(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InStyleState);
	void UpdateTextVisibility(bool bNewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComboBoxItemWidget">();
	}
	static class UBrickComboBoxItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComboBoxItemWidget>();
	}
};
static_assert(alignof(UBrickComboBoxItemWidget) == 0x000008, "Wrong alignment on UBrickComboBoxItemWidget");
static_assert(sizeof(UBrickComboBoxItemWidget) == 0x0002C8, "Wrong size on UBrickComboBoxItemWidget");
static_assert(offsetof(UBrickComboBoxItemWidget, TextBlock) == 0x0002B8, "Member 'UBrickComboBoxItemWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxItemWidget, IconImage) == 0x0002C0, "Member 'UBrickComboBoxItemWidget::IconImage' has a wrong offset!");

// Class BrickRigs.MatchEndWidget
// 0x0008 (0x0268 - 0x0260)
class UMatchEndWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickedContinue();
	void UpdateContinueButton(int32 TimeRemaining, bool bIsHost);
	void UpdateMatchWinner(class UBrickTeam* WinnerTeam, ETeamAttitude TeamAttitude);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchEndWidget">();
	}
	static class UMatchEndWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchEndWidget>();
	}
};
static_assert(alignof(UMatchEndWidget) == 0x000008, "Wrong alignment on UMatchEndWidget");
static_assert(sizeof(UMatchEndWidget) == 0x000268, "Wrong size on UMatchEndWidget");

// Class BrickRigs.ItemStaticInfo
// 0x0368 (0x0390 - 0x0028)
class UItemStaticInfo : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ItemIdleTransform;                                 // 0x0030(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            StaticMesh;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ThumbnailStaticMesh;                               // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrawDistance;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              AnimInstanceClass;                                 // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCanBeEquipped;                                    // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortOrder;                                         // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ItemTags;                                          // 0x00E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  SlotTags;                                          // 0x0100(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0xC];                                      // 0x0124(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemAimParams                         AimParams;                                         // 0x0130(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CharacterSocketRelativeLoc;                        // 0x0170(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CharacterSocketRelativeRot;                        // 0x017C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USoundBase*                             CollisionSound;                                    // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      IdleSequence;                                      // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SprintSequence;                                    // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FEquipAnimation                        EquipAnimation;                                    // 0x01A0(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FUnequipAnimation                      UnequipAnimation;                                  // 0x0268(0x00C8)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTransform                             IdlePoseOffsetFP;                                  // 0x0330(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             IdlePoseOffsetTP;                                  // 0x0360(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStaticInfo">();
	}
	static class UItemStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemStaticInfo>();
	}
};
static_assert(alignof(UItemStaticInfo) == 0x000010, "Wrong alignment on UItemStaticInfo");
static_assert(sizeof(UItemStaticInfo) == 0x000390, "Wrong size on UItemStaticInfo");
static_assert(offsetof(UItemStaticInfo, ItemIdleTransform) == 0x000030, "Member 'UItemStaticInfo::ItemIdleTransform' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, StaticMesh) == 0x000060, "Member 'UItemStaticInfo::StaticMesh' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, SkeletalMesh) == 0x000068, "Member 'UItemStaticInfo::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, MaterialOverride) == 0x000090, "Member 'UItemStaticInfo::MaterialOverride' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, ThumbnailStaticMesh) == 0x000098, "Member 'UItemStaticInfo::ThumbnailStaticMesh' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, MaxDrawDistance) == 0x0000A0, "Member 'UItemStaticInfo::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, AnimInstanceClass) == 0x0000A8, "Member 'UItemStaticInfo::AnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, PhysicalMaterial) == 0x0000B0, "Member 'UItemStaticInfo::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, DisplayName) == 0x0000B8, "Member 'UItemStaticInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, bCanBeEquipped) == 0x0000D0, "Member 'UItemStaticInfo::bCanBeEquipped' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, SortOrder) == 0x0000D8, "Member 'UItemStaticInfo::SortOrder' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, ItemTags) == 0x0000E0, "Member 'UItemStaticInfo::ItemTags' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, SlotTags) == 0x000100, "Member 'UItemStaticInfo::SlotTags' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, Price) == 0x000120, "Member 'UItemStaticInfo::Price' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, AimParams) == 0x000130, "Member 'UItemStaticInfo::AimParams' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, CharacterSocketRelativeLoc) == 0x000170, "Member 'UItemStaticInfo::CharacterSocketRelativeLoc' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, CharacterSocketRelativeRot) == 0x00017C, "Member 'UItemStaticInfo::CharacterSocketRelativeRot' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, CollisionSound) == 0x000188, "Member 'UItemStaticInfo::CollisionSound' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, IdleSequence) == 0x000190, "Member 'UItemStaticInfo::IdleSequence' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, SprintSequence) == 0x000198, "Member 'UItemStaticInfo::SprintSequence' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, EquipAnimation) == 0x0001A0, "Member 'UItemStaticInfo::EquipAnimation' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, UnequipAnimation) == 0x000268, "Member 'UItemStaticInfo::UnequipAnimation' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, IdlePoseOffsetFP) == 0x000330, "Member 'UItemStaticInfo::IdlePoseOffsetFP' has a wrong offset!");
static_assert(offsetof(UItemStaticInfo, IdlePoseOffsetTP) == 0x000360, "Member 'UItemStaticInfo::IdlePoseOffsetTP' has a wrong offset!");

// Class BrickRigs.InventoryComponent
// 0x01E8 (0x0298 - 0x00B0)
class UInventoryComponent : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInventory                             Inventory;                                         // 0x00C0(0x0120)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x10];                                     // 0x01E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        AudioComponent;                                    // 0x01F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInventoryProperties                   InventoryProperties;                               // 0x01F8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x40];                                     // 0x0258(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsSlotCompatible(const struct FInventorySlot& InSlot, const struct FInventoryItemRef& InItem);
	static int32 MoveItems(const struct FMoveInventoryItemParams& Params_0, TArray<class AInventoryItem*>* OutDroppedItems);

	int32 ConsumeAmmo(const struct FAmmoInfo& InAmmo, int32 NumRequired);
	int32 ConsumeItems(const struct FInventorySlotID& SlotID, int32 Amount);
	void DebugSpawnItems(TSubclassOf<class AInventoryItem> ItemClass, int32 Amount);
	void EmptyInventory(bool bCallDelegates);
	void Interact_Inventory(class ABrickPlayerController* PC);
	void MulticastOnPickedUpItems();
	void SetContentHidden(bool bHidden);
	void SetInventoryProperties(const struct FInventoryProperties& InProps);
	void SetSpecialSlotAttachParent(class USceneComponent* NewAttachParent);
	void SpawnInventoryLoadout(const struct FInventoryLoadout& Loadout);
	int32 SpawnItems(TSubclassOf<class AInventoryItem> ItemClass, int32 Amount);

	bool DoesSpecialSlotSupportItem(const class AInventoryItem* InItem, int32 SlotIndex) const;
	struct FInventorySlotID FindFreeSlotID(const struct FInventoryItemRef& InItem, bool bTryToReplace) const;
	struct FInventorySlotID FindFreeSpecialSlotID(const struct FInventoryItemRef& InItem, const TSet<struct FInventorySlotID>& InSlotIDs) const;
	struct FInventorySlotID FindFreeWildcardSlotID(const struct FInventoryItemRef& InItem) const;
	int32 GetAmmo(const TArray<struct FAmmoInfo>& InAmmoTypes) const;
	class FText GetDisplayName() const;
	const struct FInventory GetInventory() const;
	const TArray<struct FInventorySlot> GetInventorySlots() const;
	int32 GetNumItemsOfClass(class UClass* InClass) const;
	struct FInventorySlotID GetSpecialSlotID(int32 Index_0) const;
	struct FInventorySlotID GetWildcardSlotID(int32 Index_0) const;
	bool HasInfiniteAmmo() const;
	bool HasInventorySlot(const struct FInventorySlotID& InSlotID) const;
	bool IsContentHidden() const;
	bool IsEmpty() const;
	bool IsSlotFreeOrCompatible(const struct FInventorySlotID& InSlotID, const struct FInventoryItemRef& InItem) const;
	bool IsSpecialSlotID(const struct FInventorySlotID& InSlotID) const;
	bool IsValidSlotID(const struct FInventorySlotID& InSlotID) const;
	bool IsWildcardSlotID(const struct FInventorySlotID& InSlotID) const;
	bool RequiresSpecialSlot(const class AInventoryItem* InItem, TSet<struct FInventorySlotID>* OutSlots) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000298, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, Inventory) == 0x0000C0, "Member 'UInventoryComponent::Inventory' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, AudioComponent) == 0x0001F0, "Member 'UInventoryComponent::AudioComponent' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryProperties) == 0x0001F8, "Member 'UInventoryComponent::InventoryProperties' has a wrong offset!");

// Class BrickRigs.CharacterInventoryComponent
// 0x0000 (0x0298 - 0x0298)
class UCharacterInventoryComponent final : public UInventoryComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInventoryComponent">();
	}
	static class UCharacterInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInventoryComponent>();
	}
};
static_assert(alignof(UCharacterInventoryComponent) == 0x000008, "Wrong alignment on UCharacterInventoryComponent");
static_assert(sizeof(UCharacterInventoryComponent) == 0x000298, "Wrong size on UCharacterInventoryComponent");

// Class BrickRigs.MenuAnchorWidget
// 0x0008 (0x0268 - 0x0260)
class UMenuAnchorWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMenu();

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAnchorWidget">();
	}
	static class UMenuAnchorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAnchorWidget>();
	}
};
static_assert(alignof(UMenuAnchorWidget) == 0x000008, "Wrong alignment on UMenuAnchorWidget");
static_assert(sizeof(UMenuAnchorWidget) == 0x000268, "Wrong size on UMenuAnchorWidget");

// Class BrickRigs.AmmoBoxStaticInfo
// 0x0030 (0x03C0 - 0x0390)
class UAmmoBoxStaticInfo : public UItemStaticInfo
{
public:
	int32                                         AmmoCapacity;                                      // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  CompatibleCalibers;                                // 0x0398(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoBoxStaticInfo">();
	}
	static class UAmmoBoxStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoBoxStaticInfo>();
	}
};
static_assert(alignof(UAmmoBoxStaticInfo) == 0x000010, "Wrong alignment on UAmmoBoxStaticInfo");
static_assert(sizeof(UAmmoBoxStaticInfo) == 0x0003C0, "Wrong size on UAmmoBoxStaticInfo");
static_assert(offsetof(UAmmoBoxStaticInfo, AmmoCapacity) == 0x000390, "Member 'UAmmoBoxStaticInfo::AmmoCapacity' has a wrong offset!");
static_assert(offsetof(UAmmoBoxStaticInfo, CompatibleCalibers) == 0x000398, "Member 'UAmmoBoxStaticInfo::CompatibleCalibers' has a wrong offset!");

// Class BrickRigs.LegacyBuilding
// 0x0050 (0x0310 - 0x02C0)
class ALegacyBuilding : public ABrickBuilding
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDestructibleInstancesComponent*        DestructibleInstancesComponent;                    // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBuildingMesh>                  BuildingMeshes;                                    // 0x02D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBuildingMaterialOverride>      MaterialOverrides;                                 // 0x02E8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         NumWallsX;                                         // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumWallsY;                                         // 0x02FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumFloors;                                         // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0xC];                                      // 0x0304(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBuildingPart* ConstructBuildingPart(int32 NumX, int32 NumY, int32 Floors, const struct FVector& Location);
	void ConstructFlatRoof(class UBuildingPart* Part, uint8 Mesh);
	void ConstructIndustrialRoof(class UBuildingPart* Part, uint8 RoofSlopeMesh, uint8 RoofMesh, uint8 WallMesh);
	void ConstructRoof(class UBuildingPart* Part, uint8 RoofGableMesh, uint8 RoofMesh, bool bRotate);
	void SpawnBuildingPart(class UBuildingPart* Part);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegacyBuilding">();
	}
	static class ALegacyBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALegacyBuilding>();
	}
};
static_assert(alignof(ALegacyBuilding) == 0x000010, "Wrong alignment on ALegacyBuilding");
static_assert(sizeof(ALegacyBuilding) == 0x000310, "Wrong size on ALegacyBuilding");
static_assert(offsetof(ALegacyBuilding, DestructibleInstancesComponent) == 0x0002D0, "Member 'ALegacyBuilding::DestructibleInstancesComponent' has a wrong offset!");
static_assert(offsetof(ALegacyBuilding, BuildingMeshes) == 0x0002D8, "Member 'ALegacyBuilding::BuildingMeshes' has a wrong offset!");
static_assert(offsetof(ALegacyBuilding, MaterialOverrides) == 0x0002E8, "Member 'ALegacyBuilding::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(ALegacyBuilding, NumWallsX) == 0x0002F8, "Member 'ALegacyBuilding::NumWallsX' has a wrong offset!");
static_assert(offsetof(ALegacyBuilding, NumWallsY) == 0x0002FC, "Member 'ALegacyBuilding::NumWallsY' has a wrong offset!");
static_assert(offsetof(ALegacyBuilding, NumFloors) == 0x000300, "Member 'ALegacyBuilding::NumFloors' has a wrong offset!");

// Class BrickRigs.BrickComboBoxMenuWidget
// 0x0010 (0x0278 - 0x0268)
class UBrickComboBoxMenuWidget : public UMenuAnchorWidget
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComboBoxWidget*                   ComboBox;                                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComboBoxMenuWidget">();
	}
	static class UBrickComboBoxMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComboBoxMenuWidget>();
	}
};
static_assert(alignof(UBrickComboBoxMenuWidget) == 0x000008, "Wrong alignment on UBrickComboBoxMenuWidget");
static_assert(sizeof(UBrickComboBoxMenuWidget) == 0x000278, "Wrong size on UBrickComboBoxMenuWidget");
static_assert(offsetof(UBrickComboBoxMenuWidget, ComboBox) == 0x000270, "Member 'UBrickComboBoxMenuWidget::ComboBox' has a wrong offset!");

// Class BrickRigs.PropertyWidget
// 0x0020 (0x0280 - 0x0260)
class UPropertyWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x1A];                                     // 0x0260(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSupportsReadOnly;                                 // 0x027A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsWritable;                                 // 0x027B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateIsReadOnly(bool bNewReadOnly);

	class FName GetFocusedSubProperty(const struct FWidgetPathWrapper& WidgetPath) const;
	class UPropertyContainerWidget* GetPropertyContainerWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyWidget">();
	}
	static class UPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyWidget>();
	}
};
static_assert(alignof(UPropertyWidget) == 0x000008, "Wrong alignment on UPropertyWidget");
static_assert(sizeof(UPropertyWidget) == 0x000280, "Wrong size on UPropertyWidget");
static_assert(offsetof(UPropertyWidget, bSupportsReadOnly) == 0x00027A, "Member 'UPropertyWidget::bSupportsReadOnly' has a wrong offset!");
static_assert(offsetof(UPropertyWidget, bSupportsWritable) == 0x00027B, "Member 'UPropertyWidget::bSupportsWritable' has a wrong offset!");

// Class BrickRigs.ObjectPropertyWidget
// 0x0018 (0x0298 - 0x0280)
class UObjectPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComboBoxWidget*                   BrickComboBox;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconSize;                                          // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void OnItemSelected(int32 Item, EValueChangedEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPropertyWidget">();
	}
	static class UObjectPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPropertyWidget>();
	}
};
static_assert(alignof(UObjectPropertyWidget) == 0x000008, "Wrong alignment on UObjectPropertyWidget");
static_assert(sizeof(UObjectPropertyWidget) == 0x000298, "Wrong size on UObjectPropertyWidget");
static_assert(offsetof(UObjectPropertyWidget, BrickComboBox) == 0x000288, "Member 'UObjectPropertyWidget::BrickComboBox' has a wrong offset!");
static_assert(offsetof(UObjectPropertyWidget, IconSize) == 0x000290, "Member 'UObjectPropertyWidget::IconSize' has a wrong offset!");

// Class BrickRigs.FlashSequencePropertyWidget
// 0x0000 (0x0298 - 0x0298)
class UFlashSequencePropertyWidget : public UObjectPropertyWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashSequencePropertyWidget">();
	}
	static class UFlashSequencePropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashSequencePropertyWidget>();
	}
};
static_assert(alignof(UFlashSequencePropertyWidget) == 0x000008, "Wrong alignment on UFlashSequencePropertyWidget");
static_assert(sizeof(UFlashSequencePropertyWidget) == 0x000298, "Wrong size on UFlashSequencePropertyWidget");

// Class BrickRigs.AntennaBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UAntennaBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntennaBrickStaticInfo">();
	}
	static class UAntennaBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAntennaBrickStaticInfo>();
	}
};
static_assert(alignof(UAntennaBrickStaticInfo) == 0x000008, "Wrong alignment on UAntennaBrickStaticInfo");
static_assert(sizeof(UAntennaBrickStaticInfo) == 0x000168, "Wrong size on UAntennaBrickStaticInfo");

// Class BrickRigs.WheelBrickStaticInfo
// 0x0020 (0x0188 - 0x0168)
class UWheelBrickStaticInfo : public UBrickStaticInfo
{
public:
	float                                         WheelRadius;                                       // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         WheelWidthRange;                                   // 0x016C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColliderRadius;                                    // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWheelRadius;                                    // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWheelRadiusScale;                               // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWheelWidth;                                     // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWheelWidthScale;                                // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheelBrickStaticInfo">();
	}
	static class UWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheelBrickStaticInfo>();
	}
};
static_assert(alignof(UWheelBrickStaticInfo) == 0x000008, "Wrong alignment on UWheelBrickStaticInfo");
static_assert(sizeof(UWheelBrickStaticInfo) == 0x000188, "Wrong size on UWheelBrickStaticInfo");
static_assert(offsetof(UWheelBrickStaticInfo, WheelRadius) == 0x000168, "Member 'UWheelBrickStaticInfo::WheelRadius' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, WheelWidthRange) == 0x00016C, "Member 'UWheelBrickStaticInfo::WheelWidthRange' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, ColliderRadius) == 0x000174, "Member 'UWheelBrickStaticInfo::ColliderRadius' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, MinWheelRadius) == 0x000178, "Member 'UWheelBrickStaticInfo::MinWheelRadius' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, MaxWheelRadiusScale) == 0x00017C, "Member 'UWheelBrickStaticInfo::MaxWheelRadiusScale' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, MinWheelWidth) == 0x000180, "Member 'UWheelBrickStaticInfo::MinWheelWidth' has a wrong offset!");
static_assert(offsetof(UWheelBrickStaticInfo, MaxWheelWidthScale) == 0x000184, "Member 'UWheelBrickStaticInfo::MaxWheelWidthScale' has a wrong offset!");

// Class BrickRigs.CarWheelBrickStaticInfo
// 0x0020 (0x01A8 - 0x0188)
class UCarWheelBrickStaticInfo : public UWheelBrickStaticInfo
{
public:
	float                                         RimRadius;                                         // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTireThickness;                                  // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTirePopDamage;                                  // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TirePopEmitter;                                    // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TirePopSound;                                      // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarWheelBrickStaticInfo">();
	}
	static class UCarWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCarWheelBrickStaticInfo>();
	}
};
static_assert(alignof(UCarWheelBrickStaticInfo) == 0x000008, "Wrong alignment on UCarWheelBrickStaticInfo");
static_assert(sizeof(UCarWheelBrickStaticInfo) == 0x0001A8, "Wrong size on UCarWheelBrickStaticInfo");
static_assert(offsetof(UCarWheelBrickStaticInfo, RimRadius) == 0x000188, "Member 'UCarWheelBrickStaticInfo::RimRadius' has a wrong offset!");
static_assert(offsetof(UCarWheelBrickStaticInfo, MinTireThickness) == 0x00018C, "Member 'UCarWheelBrickStaticInfo::MinTireThickness' has a wrong offset!");
static_assert(offsetof(UCarWheelBrickStaticInfo, MinTirePopDamage) == 0x000190, "Member 'UCarWheelBrickStaticInfo::MinTirePopDamage' has a wrong offset!");
static_assert(offsetof(UCarWheelBrickStaticInfo, TirePopEmitter) == 0x000198, "Member 'UCarWheelBrickStaticInfo::TirePopEmitter' has a wrong offset!");
static_assert(offsetof(UCarWheelBrickStaticInfo, TirePopSound) == 0x0001A0, "Member 'UCarWheelBrickStaticInfo::TirePopSound' has a wrong offset!");

// Class BrickRigs.BrickComboBoxWidget
// 0x0090 (0x02F0 - 0x0260)
class UBrickComboBoxWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComboBoxItemWidget*               SelectedItemWidget;                                // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBrickComboBoxItemContainerWidget*> ItemContainerWidgets;                           // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBrickComboBoxMenuWidget*               MenuWidget;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickButtonWidget*                     Button;                                            // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickGridPanel*                        ItemsPanel;                                        // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBrickComboBoxItemWidget>   ItemWidgetClass;                                   // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickComboBoxItemContainerWidget> ItemContainerWidgetClass;                   // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickComboBoxMenuWidget>   MenuWidgetClass;                                   // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxListItems;                                      // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxItemsPerRow;                                    // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(int32 Item, struct FBrickComboBoxItemParams* OutParams)> OnInitializeItemDelegate; // 0x02D0(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Item, EValueChangedEventType EventType)> OnItemSelectedDelegate; // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddItemContainerWidget(class UBrickComboBoxItemContainerWidget* Widget, int32 Index_0);
	void AddSelectedItemWidget(class UBrickComboBoxItemWidget* Widget);
	void InitItems(int32 InNumItems, int32 InSelectedItem);
	void InitItemsComplex(const TArray<int32>& InItems, int32 InSelectedItem);
	void OnComboBoxMenuItemSelected(int32 Item, EValueChangedEventType EventType);
	void SetComboBoxExpanded(bool bNewExpanded);
	void SetMaxItemsPerRow(int32 InMaxItemsPerRow);
	void SetMaxListItems(int32 InMaxListItems);
	void SetSelectedItem(int32 InItem);
	void ToggleComboBoxExpanded();
	void UpdateIsExpanded(bool bInIsExpanded);
	void UpdateUseItemList(bool bInUseItemList);

	int32 GetNumItems() const;
	int32 GetSelectedItem() const;
	class UWidget* GetWidgetToFocus() const;
	bool IsComboBoxExpanded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComboBoxWidget">();
	}
	static class UBrickComboBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComboBoxWidget>();
	}
};
static_assert(alignof(UBrickComboBoxWidget) == 0x000008, "Wrong alignment on UBrickComboBoxWidget");
static_assert(sizeof(UBrickComboBoxWidget) == 0x0002F0, "Wrong size on UBrickComboBoxWidget");
static_assert(offsetof(UBrickComboBoxWidget, SelectedItemWidget) == 0x000280, "Member 'UBrickComboBoxWidget::SelectedItemWidget' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, ItemContainerWidgets) == 0x000288, "Member 'UBrickComboBoxWidget::ItemContainerWidgets' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, MenuWidget) == 0x000298, "Member 'UBrickComboBoxWidget::MenuWidget' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, Button) == 0x0002A0, "Member 'UBrickComboBoxWidget::Button' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, ItemsPanel) == 0x0002A8, "Member 'UBrickComboBoxWidget::ItemsPanel' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, ItemWidgetClass) == 0x0002B0, "Member 'UBrickComboBoxWidget::ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, ItemContainerWidgetClass) == 0x0002B8, "Member 'UBrickComboBoxWidget::ItemContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, MenuWidgetClass) == 0x0002C0, "Member 'UBrickComboBoxWidget::MenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, MaxListItems) == 0x0002C8, "Member 'UBrickComboBoxWidget::MaxListItems' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, MaxItemsPerRow) == 0x0002CC, "Member 'UBrickComboBoxWidget::MaxItemsPerRow' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, OnInitializeItemDelegate) == 0x0002D0, "Member 'UBrickComboBoxWidget::OnInitializeItemDelegate' has a wrong offset!");
static_assert(offsetof(UBrickComboBoxWidget, OnItemSelectedDelegate) == 0x0002E0, "Member 'UBrickComboBoxWidget::OnItemSelectedDelegate' has a wrong offset!");

// Class BrickRigs.ArchBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UArchBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchBrickStaticInfo">();
	}
	static class UArchBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchBrickStaticInfo>();
	}
};
static_assert(alignof(UArchBrickStaticInfo) == 0x000008, "Wrong alignment on UArchBrickStaticInfo");
static_assert(sizeof(UArchBrickStaticInfo) == 0x000168, "Wrong size on UArchBrickStaticInfo");

// Class BrickRigs.BrickVehicle
// 0x07F0 (0x0A70 - 0x0280)
class alignas(0x10) ABrickVehicle : public APawn
{
public:
	uint8                                         Pad_280[0xF8];                                     // 0x0280(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUGCFileInfo                           VehicleFileInfo;                                   // 0x0378(0x00E8)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FPawnRestartTransform                  RestartTransform;                                  // 0x0460(0x001C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepVehicleMovement                    RepVehicleMovement;                                // 0x0480(0x0120)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A0[0x38];                                     // 0x05A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickPlayerState*                      SpawningPlayerState;                               // 0x05D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 OriginalSpawnPoint;                                // 0x05E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickVehicleDownloadReplicator*        DownloadReplicator;                                // 0x05E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBrickConnection*>               BrickConnections;                                  // 0x05F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickConnection*>               DynamicBrickConnections;                           // 0x0600(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickConnection*>               ExternalBrickConnections;                          // 0x0610(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickConnection*>               BrickConnectionsToBreak;                           // 0x0620(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FRepBrickConnectionDamage              RepBrickConnectionDamage;                          // 0x0630(0x0120)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_750[0x10];                                     // 0x0750(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRepBrickDamage                        RepBrickDamage;                                    // 0x0760(0x0120)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_880[0x4];                                      // 0x0880(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        RepFuelLevelRatio;                                 // 0x0884(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_886[0x6];                                      // 0x0886(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	EVehiclePinMode                               PinMode;                                           // 0x088C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88D[0x3];                                      // 0x088D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGenericTeamId>                 PassengerTeamIds;                                  // 0x0890(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A0[0x10];                                     // 0x08A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrick*                                 RootBrick;                                         // 0x08B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USeatBrick*                             DriverSeat;                                        // 0x08B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C0[0x70];                                     // 0x08C0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMotorBrick*                            MotorBrick;                                        // 0x0930(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_938[0x88];                                     // 0x0938(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickVehicleComponent*                 VehicleComponent;                                  // 0x09C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        HandlingAudioComponent;                            // 0x09C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHUDIconComponent*                      HUDIconComponent;                                  // 0x09D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UFirearmComponent*>              FirearmComponents;                                 // 0x09D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UInventoryComponent*                    InventoryComponent;                                // 0x09E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F0[0x78];                                     // 0x09F0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickVehicleStaticInfo>    StaticInfoClass;                                   // 0x0A68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ConstructVehicle(const struct FUGCFileInfo& InFileInfo, class AActor* InSpawnPoint, class ABrickPlayerController* InSpawningPC, bool bAvoidCollision);
	void DebugVehicleClusters();
	void EjectAllCharacters();
	void ExplodeVehicle();
	void Interact_EnterVehicle(class ABrickPlayerController* OtherPC);
	void Interact_ScrapVehicleFromInteraction(class ABrickPlayerController* OtherPC);
	void Interact_ScrapVehicleFromMap(class ABrickPlayerController* OtherPC);
	void OnRep_PassengerTeamIds();
	void OnRep_PinMode();
	void OnRep_RepFuelLevelRatio();
	void OnRep_RestartTransform();
	void PlayHandlingSound(class USoundBase* Sound);
	void RepairVehicle(const struct FVector& InLocation, const struct FRotator& InRotation, class AActor* InSpawnPoint, bool bAvoidCollision);
	void ScrapVehicle();
	void ServerApplySeatCollisionDamage(const struct FBrickEditorObjectID& SeatID, float DamageAmount, const struct FRestartTransformVersion& ComparisonIndex);
	void ServerExplodeTankBricks(const TArray<struct FBrickEditorObjectID>& Tanks, const struct FRestartTransformVersion& ComparisonIndex);
	void ServerOnBrokeDestructibleInstances(class UDestructibleInstancesComponent* Comp, const TArray<uint16>& Instances, const struct FRestartTransformVersion& ComparisonIndex);
	void SetFuelLevel(float NewLevel);
	void SetPinMode(EVehiclePinMode NewMode);
	void SetRelativeFuelLevel(const float NewLevel);

	int32 GetAmmo() const;
	int32 GetAmmoCapacity() const;
	const TArray<struct FBrickEditorObjectID> GetCameras() const;
	float GetCurrentRPM() const;
	class ABrickCharacter* GetDriverCharacter() const;
	class USeatBrick* GetDriverSeat() const;
	float GetFuelCapacity() const;
	float GetFuelLevel() const;
	const TArray<struct FBrickEditorObjectID> GetGuns() const;
	class UInventoryComponent* GetInventoryComponent() const;
	float GetMaxRPM() const;
	class UMotorBrick* GetMotor() const;
	int32 GetNumPassengers() const;
	void GetPassengers(TArray<class ABrickCharacter*>* OutPassengers) const;
	EVehiclePinMode GetPinMode() const;
	class UBrick* GetRootBrick() const;
	const TArray<struct FBrickEditorObjectID> GetSeats() const;
	class ABrickPlayerState* GetSpawningPlayerState() const;
	const class UBrickVehicleStaticInfo* GetStaticInfo() const;
	class UBrickVehicleComponent* GetVehicleComponent() const;
	class FText GetVehicleDisplayName() const;
	const struct FUGCFileInfo GetVehicleFileInfo() const;
	class USeatBrick* GetViewedSeat() const;
	class UCameraBrick* GetViewTargetCamera() const;
	bool HasVisibleSeat() const;
	bool IsInteracting() const;
	bool IsVehicleConstructed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickVehicle">();
	}
	static class ABrickVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickVehicle>();
	}
};
static_assert(alignof(ABrickVehicle) == 0x000010, "Wrong alignment on ABrickVehicle");
static_assert(sizeof(ABrickVehicle) == 0x000A70, "Wrong size on ABrickVehicle");
static_assert(offsetof(ABrickVehicle, VehicleFileInfo) == 0x000378, "Member 'ABrickVehicle::VehicleFileInfo' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RestartTransform) == 0x000460, "Member 'ABrickVehicle::RestartTransform' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RepVehicleMovement) == 0x000480, "Member 'ABrickVehicle::RepVehicleMovement' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, SpawningPlayerState) == 0x0005D8, "Member 'ABrickVehicle::SpawningPlayerState' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, OriginalSpawnPoint) == 0x0005E0, "Member 'ABrickVehicle::OriginalSpawnPoint' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, DownloadReplicator) == 0x0005E8, "Member 'ABrickVehicle::DownloadReplicator' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, BrickConnections) == 0x0005F0, "Member 'ABrickVehicle::BrickConnections' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, DynamicBrickConnections) == 0x000600, "Member 'ABrickVehicle::DynamicBrickConnections' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, ExternalBrickConnections) == 0x000610, "Member 'ABrickVehicle::ExternalBrickConnections' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, BrickConnectionsToBreak) == 0x000620, "Member 'ABrickVehicle::BrickConnectionsToBreak' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RepBrickConnectionDamage) == 0x000630, "Member 'ABrickVehicle::RepBrickConnectionDamage' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RepBrickDamage) == 0x000760, "Member 'ABrickVehicle::RepBrickDamage' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RepFuelLevelRatio) == 0x000884, "Member 'ABrickVehicle::RepFuelLevelRatio' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, PinMode) == 0x00088C, "Member 'ABrickVehicle::PinMode' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, PassengerTeamIds) == 0x000890, "Member 'ABrickVehicle::PassengerTeamIds' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, RootBrick) == 0x0008B0, "Member 'ABrickVehicle::RootBrick' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, DriverSeat) == 0x0008B8, "Member 'ABrickVehicle::DriverSeat' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, MotorBrick) == 0x000930, "Member 'ABrickVehicle::MotorBrick' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, VehicleComponent) == 0x0009C0, "Member 'ABrickVehicle::VehicleComponent' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, HandlingAudioComponent) == 0x0009C8, "Member 'ABrickVehicle::HandlingAudioComponent' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, HUDIconComponent) == 0x0009D0, "Member 'ABrickVehicle::HUDIconComponent' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, FirearmComponents) == 0x0009D8, "Member 'ABrickVehicle::FirearmComponents' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, InventoryComponent) == 0x0009E8, "Member 'ABrickVehicle::InventoryComponent' has a wrong offset!");
static_assert(offsetof(ABrickVehicle, StaticInfoClass) == 0x000A68, "Member 'ABrickVehicle::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.MyUserSettings
// 0x0038 (0x0158 - 0x0120)
class UMyUserSettings final : public UGameUserSettings
{
public:
	uint8                                         Pad_120[0x9];                                      // 0x0120(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableDepthOfField;                               // 0x0129(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableRayTracing;                                 // 0x012A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableHDR;                                        // 0x012B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MotionBlurScale;                                   // 0x012C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAntiAliasingMethod                           AntiAliasingMethod;                                // 0x0130(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x1F];                                     // 0x0131(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	EDLSSMode                                     DLSSMode;                                          // 0x0150(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UMyUserSettings* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MyUserSettings">();
	}
	static class UMyUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMyUserSettings>();
	}
};
static_assert(alignof(UMyUserSettings) == 0x000008, "Wrong alignment on UMyUserSettings");
static_assert(sizeof(UMyUserSettings) == 0x000158, "Wrong size on UMyUserSettings");
static_assert(offsetof(UMyUserSettings, bEnableDepthOfField) == 0x000129, "Member 'UMyUserSettings::bEnableDepthOfField' has a wrong offset!");
static_assert(offsetof(UMyUserSettings, bEnableRayTracing) == 0x00012A, "Member 'UMyUserSettings::bEnableRayTracing' has a wrong offset!");
static_assert(offsetof(UMyUserSettings, bEnableHDR) == 0x00012B, "Member 'UMyUserSettings::bEnableHDR' has a wrong offset!");
static_assert(offsetof(UMyUserSettings, MotionBlurScale) == 0x00012C, "Member 'UMyUserSettings::MotionBlurScale' has a wrong offset!");
static_assert(offsetof(UMyUserSettings, AntiAliasingMethod) == 0x000130, "Member 'UMyUserSettings::AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UMyUserSettings, DLSSMode) == 0x000150, "Member 'UMyUserSettings::DLSSMode' has a wrong offset!");

// Class BrickRigs.Attachment
// 0x0000 (0x0270 - 0x0270)
class AAttachment : public AInventoryItem
{
public:
	class AFirearm* GetFirearm() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Attachment">();
	}
	static class AAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAttachment>();
	}
};
static_assert(alignof(AAttachment) == 0x000008, "Wrong alignment on AAttachment");
static_assert(sizeof(AAttachment) == 0x000270, "Wrong size on AAttachment");

// Class BrickRigs.ChatWidget
// 0x0050 (0x02B0 - 0x0260)
class UChatWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UChatMessageWidget*>             ChatMessageWidgets;                                // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickScrollBox*                        ChatScrollBox;                                     // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UControlHintWidget*                     ChatContextControlHint;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBoxWidget*                    TextBox;                                           // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutDelay;                                      // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UChatMessageWidget>         ChatMessageWidgetClass;                            // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UWidget* GetWidgetToFocus();
	void OnTextChanged(const class FText& Text, EValueChangedEventType EventType);
	void UpdateIsFocused(bool bNewFocused);
	void UpdateIsTyping(bool bNewTyping);
	void UpdateScrollBoxVisibility(bool bNewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatWidget">();
	}
	static class UChatWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatWidget>();
	}
};
static_assert(alignof(UChatWidget) == 0x000008, "Wrong alignment on UChatWidget");
static_assert(sizeof(UChatWidget) == 0x0002B0, "Wrong size on UChatWidget");
static_assert(offsetof(UChatWidget, ChatMessageWidgets) == 0x000270, "Member 'UChatWidget::ChatMessageWidgets' has a wrong offset!");
static_assert(offsetof(UChatWidget, ChatScrollBox) == 0x000288, "Member 'UChatWidget::ChatScrollBox' has a wrong offset!");
static_assert(offsetof(UChatWidget, ChatContextControlHint) == 0x000290, "Member 'UChatWidget::ChatContextControlHint' has a wrong offset!");
static_assert(offsetof(UChatWidget, TextBox) == 0x000298, "Member 'UChatWidget::TextBox' has a wrong offset!");
static_assert(offsetof(UChatWidget, FadeOutDelay) == 0x0002A0, "Member 'UChatWidget::FadeOutDelay' has a wrong offset!");
static_assert(offsetof(UChatWidget, ChatMessageWidgetClass) == 0x0002A8, "Member 'UChatWidget::ChatMessageWidgetClass' has a wrong offset!");

// Class BrickRigs.BrickConnection
// 0x0038 (0x0060 - 0x0028)
class UBrickConnection : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrick*                                 Brick0;                                            // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrick*                                 Brick1;                                            // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBrickEditorObjectID                   BrickID0;                                          // 0x0040(0x0002)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBrickEditorObjectID                   BrickID1;                                          // 0x0042(0x0002)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickVehicle*                          OtherVehicle;                                      // 0x0048(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBrickConnectionParams                 Params_0;                                          // 0x0050(0x0008)(Net, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickConnection">();
	}
	static class UBrickConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickConnection>();
	}
};
static_assert(alignof(UBrickConnection) == 0x000008, "Wrong alignment on UBrickConnection");
static_assert(sizeof(UBrickConnection) == 0x000060, "Wrong size on UBrickConnection");
static_assert(offsetof(UBrickConnection, Brick0) == 0x000030, "Member 'UBrickConnection::Brick0' has a wrong offset!");
static_assert(offsetof(UBrickConnection, Brick1) == 0x000038, "Member 'UBrickConnection::Brick1' has a wrong offset!");
static_assert(offsetof(UBrickConnection, BrickID0) == 0x000040, "Member 'UBrickConnection::BrickID0' has a wrong offset!");
static_assert(offsetof(UBrickConnection, BrickID1) == 0x000042, "Member 'UBrickConnection::BrickID1' has a wrong offset!");
static_assert(offsetof(UBrickConnection, OtherVehicle) == 0x000048, "Member 'UBrickConnection::OtherVehicle' has a wrong offset!");
static_assert(offsetof(UBrickConnection, Params_0) == 0x000050, "Member 'UBrickConnection::Params_0' has a wrong offset!");

// Class BrickRigs.AttachmentStaticInfo
// 0x0000 (0x0390 - 0x0390)
class UAttachmentStaticInfo : public UItemStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachmentStaticInfo">();
	}
	static class UAttachmentStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachmentStaticInfo>();
	}
};
static_assert(alignof(UAttachmentStaticInfo) == 0x000010, "Wrong alignment on UAttachmentStaticInfo");
static_assert(sizeof(UAttachmentStaticInfo) == 0x000390, "Wrong size on UAttachmentStaticInfo");

// Class BrickRigs.MainWidgetBase
// 0x0018 (0x0278 - 0x0260)
class UMainWidgetBase : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UFadingPanelWidget*                     FadingPanel;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonPanelWidget*                 ButtonPanel;                                       // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnFadedOut();

	class UMenuButtonPanelWidget* GetButtonPanel() const;
	class UWidget* GetWidgetToFocus() const;
	class UWindowManagerWidget* GetWindowManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainWidgetBase">();
	}
	static class UMainWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainWidgetBase>();
	}
};
static_assert(alignof(UMainWidgetBase) == 0x000008, "Wrong alignment on UMainWidgetBase");
static_assert(sizeof(UMainWidgetBase) == 0x000278, "Wrong size on UMainWidgetBase");
static_assert(offsetof(UMainWidgetBase, FadingPanel) == 0x000268, "Member 'UMainWidgetBase::FadingPanel' has a wrong offset!");
static_assert(offsetof(UMainWidgetBase, ButtonPanel) == 0x000270, "Member 'UMainWidgetBase::ButtonPanel' has a wrong offset!");

// Class BrickRigs.LoadingScreenWidget
// 0x0000 (0x0278 - 0x0278)
class ULoadingScreenWidget : public UMainWidgetBase
{
public:
	void SetBackgroundColor(const struct FLinearColor& InColor);
	void SetLoadingText(const class FText& Text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreenWidget">();
	}
	static class ULoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreenWidget>();
	}
};
static_assert(alignof(ULoadingScreenWidget) == 0x000008, "Wrong alignment on ULoadingScreenWidget");
static_assert(sizeof(ULoadingScreenWidget) == 0x000278, "Wrong size on ULoadingScreenWidget");

// Class BrickRigs.PhysicsConstraintConnection
// 0x0070 (0x00D0 - 0x0060)
class UPhysicsConstraintConnection : public UBrickConnection
{
public:
	uint8                                         Pad_60[0x70];                                      // 0x0060(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConstraintBroken(int32 ConstraintIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsConstraintConnection">();
	}
	static class UPhysicsConstraintConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsConstraintConnection>();
	}
};
static_assert(alignof(UPhysicsConstraintConnection) == 0x000008, "Wrong alignment on UPhysicsConstraintConnection");
static_assert(sizeof(UPhysicsConstraintConnection) == 0x0000D0, "Wrong size on UPhysicsConstraintConnection");

// Class BrickRigs.StaticMeshProp
// 0x0020 (0x0240 - 0x0220)
class AStaticMeshProp : public AActor
{
public:
	class UMaterialInterface*                     SelectedMaterial;                                  // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0228(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            StaticMesh;                                        // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDrawDistance;                                   // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsClimbable;                                      // 0x023C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshProp">();
	}
	static class AStaticMeshProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshProp>();
	}
};
static_assert(alignof(AStaticMeshProp) == 0x000008, "Wrong alignment on AStaticMeshProp");
static_assert(sizeof(AStaticMeshProp) == 0x000240, "Wrong size on AStaticMeshProp");
static_assert(offsetof(AStaticMeshProp, SelectedMaterial) == 0x000220, "Member 'AStaticMeshProp::SelectedMaterial' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, StaticMeshComponent) == 0x000228, "Member 'AStaticMeshProp::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, StaticMesh) == 0x000230, "Member 'AStaticMeshProp::StaticMesh' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, MaxDrawDistance) == 0x000238, "Member 'AStaticMeshProp::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(AStaticMeshProp, bIsClimbable) == 0x00023C, "Member 'AStaticMeshProp::bIsClimbable' has a wrong offset!");

// Class BrickRigs.FuelTank
// 0x0040 (0x0280 - 0x0240)
class AFuelTank : public AStaticMeshProp
{
public:
	uint8                                         Pad_240[0x14];                                     // 0x0240(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasExploded;                                      // 0x0254(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDamage;                                         // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ExplodedStaticMesh;                                // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UExplosiveMaterial>         FuelType;                                          // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FuelVolume;                                        // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        LeakEmitter;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_bHasExploded();
	bool ShouldSpawnLeakOnHit(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FuelTank">();
	}
	static class AFuelTank* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFuelTank>();
	}
};
static_assert(alignof(AFuelTank) == 0x000008, "Wrong alignment on AFuelTank");
static_assert(sizeof(AFuelTank) == 0x000280, "Wrong size on AFuelTank");
static_assert(offsetof(AFuelTank, bHasExploded) == 0x000254, "Member 'AFuelTank::bHasExploded' has a wrong offset!");
static_assert(offsetof(AFuelTank, MaxDamage) == 0x000258, "Member 'AFuelTank::MaxDamage' has a wrong offset!");
static_assert(offsetof(AFuelTank, ExplodedStaticMesh) == 0x000260, "Member 'AFuelTank::ExplodedStaticMesh' has a wrong offset!");
static_assert(offsetof(AFuelTank, FuelType) == 0x000268, "Member 'AFuelTank::FuelType' has a wrong offset!");
static_assert(offsetof(AFuelTank, FuelVolume) == 0x000270, "Member 'AFuelTank::FuelVolume' has a wrong offset!");
static_assert(offsetof(AFuelTank, LeakEmitter) == 0x000278, "Member 'AFuelTank::LeakEmitter' has a wrong offset!");

// Class BrickRigs.AxleBrickStaticInfo
// 0x0008 (0x0170 - 0x0168)
class UAxleBrickStaticInfo : public UBrickStaticInfo
{
public:
	float                                         SuspensionStiffness;                               // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspensionDamping;                                 // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxleBrickStaticInfo">();
	}
	static class UAxleBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxleBrickStaticInfo>();
	}
};
static_assert(alignof(UAxleBrickStaticInfo) == 0x000008, "Wrong alignment on UAxleBrickStaticInfo");
static_assert(sizeof(UAxleBrickStaticInfo) == 0x000170, "Wrong size on UAxleBrickStaticInfo");
static_assert(offsetof(UAxleBrickStaticInfo, SuspensionStiffness) == 0x000168, "Member 'UAxleBrickStaticInfo::SuspensionStiffness' has a wrong offset!");
static_assert(offsetof(UAxleBrickStaticInfo, SuspensionDamping) == 0x00016C, "Member 'UAxleBrickStaticInfo::SuspensionDamping' has a wrong offset!");

// Class BrickRigs.BrickViewportClient
// 0x0020 (0x0380 - 0x0360)
class UBrickViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_360[0x20];                                     // 0x0360(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickViewportClient* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickViewportClient">();
	}
	static class UBrickViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickViewportClient>();
	}
};
static_assert(alignof(UBrickViewportClient) == 0x000008, "Wrong alignment on UBrickViewportClient");
static_assert(sizeof(UBrickViewportClient) == 0x000380, "Wrong size on UBrickViewportClient");

// Class BrickRigs.WheelConnection
// 0x0020 (0x00F0 - 0x00D0)
class UWheelConnection final : public UPhysicsConstraintConnection
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheelConnection">();
	}
	static class UWheelConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheelConnection>();
	}
};
static_assert(alignof(UWheelConnection) == 0x000008, "Wrong alignment on UWheelConnection");
static_assert(sizeof(UWheelConnection) == 0x0000F0, "Wrong size on UWheelConnection");

// Class BrickRigs.AxleBrick
// 0x0090 (0x0188 - 0x00F8)
class UAxleBrick final : public UBrick
{
public:
	TArray<class UWheelConnection*>               WheelConnections;                                  // 0x00F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   BrakeInputChannel;                                 // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVehicleInputChannel                   SteeringInputChannel;                              // 0x0140(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SuspensionLength;                                  // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspensionStiffness;                               // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuspensionDamping;                                 // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDriven;                                           // 0x0174(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertDrive;                                      // 0x0175(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBrake;                                         // 0x0176(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHandBrake;                                     // 0x0177(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrakeStrength;                                     // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringAngle;                                     // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringSpeed;                                     // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanDisableSteering;                               // 0x0184(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanInvertSteering;                                // 0x0185(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AxleBrick">();
	}
	static class UAxleBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAxleBrick>();
	}
};
static_assert(alignof(UAxleBrick) == 0x000008, "Wrong alignment on UAxleBrick");
static_assert(sizeof(UAxleBrick) == 0x000188, "Wrong size on UAxleBrick");
static_assert(offsetof(UAxleBrick, WheelConnections) == 0x0000F8, "Member 'UAxleBrick::WheelConnections' has a wrong offset!");
static_assert(offsetof(UAxleBrick, BrakeInputChannel) == 0x000118, "Member 'UAxleBrick::BrakeInputChannel' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SteeringInputChannel) == 0x000140, "Member 'UAxleBrick::SteeringInputChannel' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SuspensionLength) == 0x000168, "Member 'UAxleBrick::SuspensionLength' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SuspensionStiffness) == 0x00016C, "Member 'UAxleBrick::SuspensionStiffness' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SuspensionDamping) == 0x000170, "Member 'UAxleBrick::SuspensionDamping' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bDriven) == 0x000174, "Member 'UAxleBrick::bDriven' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bInvertDrive) == 0x000175, "Member 'UAxleBrick::bInvertDrive' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bHasBrake) == 0x000176, "Member 'UAxleBrick::bHasBrake' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bHasHandBrake) == 0x000177, "Member 'UAxleBrick::bHasHandBrake' has a wrong offset!");
static_assert(offsetof(UAxleBrick, BrakeStrength) == 0x000178, "Member 'UAxleBrick::BrakeStrength' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SteeringAngle) == 0x00017C, "Member 'UAxleBrick::SteeringAngle' has a wrong offset!");
static_assert(offsetof(UAxleBrick, SteeringSpeed) == 0x000180, "Member 'UAxleBrick::SteeringSpeed' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bCanDisableSteering) == 0x000184, "Member 'UAxleBrick::bCanDisableSteering' has a wrong offset!");
static_assert(offsetof(UAxleBrick, bCanInvertSteering) == 0x000185, "Member 'UAxleBrick::bCanInvertSteering' has a wrong offset!");

// Class BrickRigs.ActuatorConnection
// 0x0010 (0x00E0 - 0x00D0)
class UActuatorConnection final : public UPhysicsConstraintConnection
{
public:
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActuatorConnection">();
	}
	static class UActuatorConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActuatorConnection>();
	}
};
static_assert(alignof(UActuatorConnection) == 0x000008, "Wrong alignment on UActuatorConnection");
static_assert(sizeof(UActuatorConnection) == 0x0000E0, "Wrong size on UActuatorConnection");

// Class BrickRigs.MenuButtonWidget
// 0x0028 (0x0298 - 0x0270)
class UMenuButtonWidget : public UBrickUserWidget
{
public:
	class UBrickButtonWidget* Button;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock* TextBlock;                                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage* IconImage;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void()>                             OnClickedDelegate;                                      // 0x0288(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
public:
	void OnClicked();
	void SetColorStyle(EBrickUIColorStyle InColorStyle);
	void SetDisplayIcon(int32 InIconIndex);
	void SetDisplayText(const class FText& InText);
	void UpdateDisplayText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonWidget">();
	}
	static class UMenuButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonWidget>();
	}
};
static_assert(alignof(UMenuButtonWidget) == 0x000008, "Wrong alignment on UMenuButtonWidget");
static_assert(sizeof(UMenuButtonWidget) == 0x000298, "Wrong size on UMenuButtonWidget");
static_assert(offsetof(UMenuButtonWidget, Button) == 0x000270, "Member 'UMenuButtonWidget::Button' has a wrong offset!");
static_assert(offsetof(UMenuButtonWidget, TextBlock) == 0x000278, "Member 'UMenuButtonWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UMenuButtonWidget, IconImage) == 0x000280, "Member 'UMenuButtonWidget::IconImage' has a wrong offset!");

// Class BrickRigs.BarrelAttachment
// 0x0000 (0x0270 - 0x0270)
class ABarrelAttachment : public AAttachment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrelAttachment">();
	}
	static class ABarrelAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABarrelAttachment>();
	}
};
static_assert(alignof(ABarrelAttachment) == 0x000008, "Wrong alignment on ABarrelAttachment");
static_assert(sizeof(ABarrelAttachment) == 0x000270, "Wrong size on ABarrelAttachment");

// Class BrickRigs.BarrelBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UBarrelBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrelBrickStaticInfo">();
	}
	static class UBarrelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarrelBrickStaticInfo>();
	}
};
static_assert(alignof(UBarrelBrickStaticInfo) == 0x000008, "Wrong alignment on UBarrelBrickStaticInfo");
static_assert(sizeof(UBarrelBrickStaticInfo) == 0x000168, "Wrong size on UBarrelBrickStaticInfo");

// Class BrickRigs.MapPopupWidget
// 0x0008 (0x02A0 - 0x0298)
class UMapPopupWidget : public UPopupWidget
{
public:
	class UMapWidget*                             MapWidget;                                         // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapPopupWidget">();
	}
	static class UMapPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapPopupWidget>();
	}
};
static_assert(alignof(UMapPopupWidget) == 0x000008, "Wrong alignment on UMapPopupWidget");
static_assert(sizeof(UMapPopupWidget) == 0x0002A0, "Wrong size on UMapPopupWidget");
static_assert(offsetof(UMapPopupWidget, MapWidget) == 0x000298, "Member 'UMapPopupWidget::MapWidget' has a wrong offset!");

// Class BrickRigs.BarrelBrick
// 0x0000 (0x00F8 - 0x00F8)
class UBarrelBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrelBrick">();
	}
	static class UBarrelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarrelBrick>();
	}
};
static_assert(alignof(UBarrelBrick) == 0x000008, "Wrong alignment on UBarrelBrick");
static_assert(sizeof(UBarrelBrick) == 0x0000F8, "Wrong size on UBarrelBrick");

// Class BrickRigs.BarrelStaticInfo
// 0x0060 (0x03F0 - 0x0390)
class UBarrelStaticInfo : public UAttachmentStaticInfo
{
public:
	struct FMuzzleEffect                          MuzzleEffect;                                      // 0x0390(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         InitialSpeedScale;                                 // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeScale;                                        // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrelStaticInfo">();
	}
	static class UBarrelStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarrelStaticInfo>();
	}
};
static_assert(alignof(UBarrelStaticInfo) == 0x000010, "Wrong alignment on UBarrelStaticInfo");
static_assert(sizeof(UBarrelStaticInfo) == 0x0003F0, "Wrong size on UBarrelStaticInfo");
static_assert(offsetof(UBarrelStaticInfo, MuzzleEffect) == 0x000390, "Member 'UBarrelStaticInfo::MuzzleEffect' has a wrong offset!");
static_assert(offsetof(UBarrelStaticInfo, InitialSpeedScale) == 0x0003E0, "Member 'UBarrelStaticInfo::InitialSpeedScale' has a wrong offset!");
static_assert(offsetof(UBarrelStaticInfo, RangeScale) == 0x0003E4, "Member 'UBarrelStaticInfo::RangeScale' has a wrong offset!");
static_assert(offsetof(UBarrelStaticInfo, DamageScale) == 0x0003E8, "Member 'UBarrelStaticInfo::DamageScale' has a wrong offset!");

// Class BrickRigs.MatchStateWidget
// 0x0018 (0x0278 - 0x0260)
class UMatchStateWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadedOut();
	void UpdateMatchState(const class FText& NewDisplayText, EBrickUIColorStyle NewColorStyle, bool bFadeOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchStateWidget">();
	}
	static class UMatchStateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchStateWidget>();
	}
};
static_assert(alignof(UMatchStateWidget) == 0x000008, "Wrong alignment on UMatchStateWidget");
static_assert(sizeof(UMatchStateWidget) == 0x000278, "Wrong size on UMatchStateWidget");

// Class BrickRigs.BaseCharacter
// 0x0300 (0x07C0 - 0x04C0)
class ABaseCharacter : public ACharacter
{
public:
	uint8                                         Pad_4C0[0xE0];                                     // 0x04C0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         TeamID;                                            // 0x05A0(0x0001)(Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         RemoteViewYaw;                                     // 0x05A1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsAiming : 1;                                     // 0x05A2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsSprinting : 1;                                  // 0x05A2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5A3[0x5];                                      // 0x05A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RepHealth;                                         // 0x05A8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterStateOfHealth                       StateOfHealth;                                     // 0x05A9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterHealingState                        HealingState;                                      // 0x05AA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5AB[0x1];                                      // 0x05AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastHitBone;                                       // 0x05AC(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector_NetQuantize100                 LastDamageImpulse;                                 // 0x05B4(0x000C)(Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x70];                                     // 0x05C0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsOnFire;                                         // 0x0630(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  FireInstigator;                                    // 0x0638(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCharacterAction*>               ActiveActions;                                     // 0x0640(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_650[0x50];                                     // 0x0650(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPawnRestartTransform                  RestartTransform;                                  // 0x06A0(0x001C)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BC[0x4];                                      // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x06C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x10];                                     // 0x06C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInventoryComponent*           InventoryComponent;                                // 0x06D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                FootstepACs;                                       // 0x06E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                FoleyACs;                                          // 0x06F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        CollisionAC;                                       // 0x0700(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUDIconComponent*                      HUDIconComponent;                                  // 0x0708(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  InteractionComponent;                              // 0x0710(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               FirePSC;                                           // 0x0718(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FireAC;                                            // 0x0720(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x90];                                     // 0x0728(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCharacterStaticInfo>       StaticInfoClass;                                   // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClientOnReceivedDamage(const struct FCharacterDamageInfo& DamageInfo);
	void GiveTestLoadout();
	void Interact_Possess(class ABrickPlayerController* OtherPC);
	bool IsPerformingMeleeAction();
	void OnHealingStateChanged();
	void OnHealthChanged();
	void OnIsOnFireChanged();
	void OnMeshHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnRep_RepHealth();
	void OnRep_RestartTransform();
	void OnRep_TeamId();
	void OnStateOfHealthChanged();
	bool PerformMeleeAction();
	void ServerAcknowledgeRestartTransform(const struct FRestartTransformVersion& ComparisonIndex);
	void ServerMoveInventoryItems(const struct FMoveInventoryItemParams& Params_0, const struct FPlayerViewPoint& ViewPoint);
	void ServerPerformMeleeAction();

	bool IsConscious() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacter">();
	}
	static class ABaseCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseCharacter>();
	}
};
static_assert(alignof(ABaseCharacter) == 0x000010, "Wrong alignment on ABaseCharacter");
static_assert(sizeof(ABaseCharacter) == 0x0007C0, "Wrong size on ABaseCharacter");
static_assert(offsetof(ABaseCharacter, TeamID) == 0x0005A0, "Member 'ABaseCharacter::TeamID' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, RemoteViewYaw) == 0x0005A1, "Member 'ABaseCharacter::RemoteViewYaw' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, RepHealth) == 0x0005A8, "Member 'ABaseCharacter::RepHealth' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, StateOfHealth) == 0x0005A9, "Member 'ABaseCharacter::StateOfHealth' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, HealingState) == 0x0005AA, "Member 'ABaseCharacter::HealingState' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, LastHitBone) == 0x0005AC, "Member 'ABaseCharacter::LastHitBone' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, LastDamageImpulse) == 0x0005B4, "Member 'ABaseCharacter::LastDamageImpulse' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, bIsOnFire) == 0x000630, "Member 'ABaseCharacter::bIsOnFire' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, FireInstigator) == 0x000638, "Member 'ABaseCharacter::FireInstigator' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, ActiveActions) == 0x000640, "Member 'ABaseCharacter::ActiveActions' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, RestartTransform) == 0x0006A0, "Member 'ABaseCharacter::RestartTransform' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, Mid) == 0x0006C0, "Member 'ABaseCharacter::Mid' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, InventoryComponent) == 0x0006D8, "Member 'ABaseCharacter::InventoryComponent' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, FootstepACs) == 0x0006E0, "Member 'ABaseCharacter::FootstepACs' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, FoleyACs) == 0x0006F0, "Member 'ABaseCharacter::FoleyACs' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, CollisionAC) == 0x000700, "Member 'ABaseCharacter::CollisionAC' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, HUDIconComponent) == 0x000708, "Member 'ABaseCharacter::HUDIconComponent' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, InteractionComponent) == 0x000710, "Member 'ABaseCharacter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, FirePSC) == 0x000718, "Member 'ABaseCharacter::FirePSC' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, FireAC) == 0x000720, "Member 'ABaseCharacter::FireAC' has a wrong offset!");
static_assert(offsetof(ABaseCharacter, StaticInfoClass) == 0x0007B8, "Member 'ABaseCharacter::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.NumericPropertyWidget
// 0x0030 (0x02B0 - 0x0280)
class UNumericPropertyWidget : public UPropertyWidget
{
public:
	TArray<class UBrickSliderWidget*>             Sliders;                                           // 0x0280(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickSliderWidget>         SliderClass;                                       // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSliderWidget(class UBrickSliderWidget* Slider);
	void LockAxes(const bool bLock);
	void OnSliderValueChanged(const float NewValue, const EValueChangedEventType EventType, const int32 Index_0);
	void UpdateNumericProperty(const ENumericValueType ValueType, const int32 NumAxes);

	bool AreAxesLocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NumericPropertyWidget">();
	}
	static class UNumericPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNumericPropertyWidget>();
	}
};
static_assert(alignof(UNumericPropertyWidget) == 0x000008, "Wrong alignment on UNumericPropertyWidget");
static_assert(sizeof(UNumericPropertyWidget) == 0x0002B0, "Wrong size on UNumericPropertyWidget");
static_assert(offsetof(UNumericPropertyWidget, Sliders) == 0x000280, "Member 'UNumericPropertyWidget::Sliders' has a wrong offset!");
static_assert(offsetof(UNumericPropertyWidget, SliderClass) == 0x0002A8, "Member 'UNumericPropertyWidget::SliderClass' has a wrong offset!");

// Class BrickRigs.BasePlayerController
// 0x0088 (0x05F8 - 0x0570)
class ABasePlayerController : public APlayerController
{
public:
	uint8                                         Pad_570[0x50];                                     // 0x0570(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPlayerControllerStaticInfo> StaticInfoClass;                                  // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x30];                                     // 0x05C8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientOnKickedPlayerListChanged();
	void ClientReceiveKickedPlayerList(const struct FKickedPlayerList& PlayerList, uint8 RequestID);
	void KickPlayer(const struct FUniqueNetIdRepl& OtherPlayerId, const class FString& OtherPlayerName, const class FString& KickReason, const struct FTimespan& KickDuration);
	void OpenKickPlayerPopup(const struct FUniqueNetIdRepl& OtherPlayerId, const class FString& OtherPlayerName);
	void RevokeKick(const struct FUniqueNetIdRepl& OtherPlayerId);
	void ServerKickPlayer(const struct FUniqueNetIdRepl& OtherPlayerId, const class FString& OtherPlayerName, const class FString& KickReason, const struct FTimespan& KickDuration);
	void ServerRequestKickedPlayerList(const struct FKickedPlayerListRequest& Request, uint8 RequestID);
	void ServerRevokeKick(const struct FUniqueNetIdRepl& OtherPlayerId);
	void ToggleCheatMenuOpen();
	void UpdateViewTarget();

	bool CanKickPlayer(const struct FUniqueNetIdRepl& OtherPlayerId) const;
	bool CanViewAndEditKicks() const;
	class AActor* GetDesiredViewTarget(struct FViewTargetTransitionParams* OutTransitionParams) const;
	struct FUniqueNetIdRepl GetPlayerId() const;
	const class UPlayerControllerStaticInfo* GetStaticInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerController">();
	}
	static class ABasePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABasePlayerController>();
	}
};
static_assert(alignof(ABasePlayerController) == 0x000008, "Wrong alignment on ABasePlayerController");
static_assert(sizeof(ABasePlayerController) == 0x0005F8, "Wrong size on ABasePlayerController");
static_assert(offsetof(ABasePlayerController, StaticInfoClass) == 0x0005C0, "Member 'ABasePlayerController::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.BrickGameMode
// 0x00F0 (0x03F8 - 0x0308)
class ABrickGameMode : public AGameMode
{
public:
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_318_0 : 2;                                  // 0x0318(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bMovePlayersToDefaultTeam : 1;                     // 0x0318(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanJoinZombieTeam : 1;                            // 0x0318(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCanJoinDummyTeam : 1;                             // 0x0318(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickTeam>                 DefaultTeam;                                       // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickTeam>                 ZombieTeam;                                        // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickTeam>                 DummyTeam;                                         // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<TSubclassOf<class UBrickTeam>>           Teams;                                             // 0x0338(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ABrickVehicle>              VehicleClass;                                      // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InactiveCharacterLifeSpan;                         // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinUnpossessDelay;                                 // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAutoRestartPlayers : 1;                           // 0x0398(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSpawnCharactersInvincible : 1;                    // 0x0398(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetMoneyOnDeath : 1;                            // 0x0398(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableMovementDuringWaitingToStart : 1;          // 0x0398(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoBalanceTeamsThreshold;                         // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpawnPlayerRelevanceDistance;                   // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLocalChatDistance;                              // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamScore;                                      // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillTeamScore;                                     // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddScoreMoneyRatio;                                // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillScore;                                         // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZombieKillScore;                                   // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointCapturedScore;                                // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointNeutralizedScore;                             // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RoundWinScore;                                     // 0x03C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermissionRoundWinScore;                         // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowMatchScore;                                   // 0x03CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WarmupTime;                                        // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundStartTime;                                    // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RoundEndTime;                                      // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntermissionTime;                                  // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchEndTime;                                      // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSkipWarmup : 1;                                   // 0x03E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxRoundsPerMatch;                                 // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRoundsToIntermission;                           // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEndRoundWhenTeamEliminated : 1;                   // 0x03F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEndMatchWhenTeamEliminated : 1;                   // 0x03F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRestartDuringRound : 1;                      // 0x03F0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRestartWhilePlaying : 1;                     // 0x03F0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bResetLevelAndPlayersEveryRound : 1;               // 0x03F0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRespawnLoadoutOnRestart : 1;                      // 0x03F0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowInteractionWhileUnconscious : 1;             // 0x03F0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowTeleporting : 1;                             // 0x03F0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpawnOnGarages : 1;                          // 0x03F1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpawnOnNeutralVehicles : 1;                  // 0x03F1(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpawnOnHostileVehicles : 1;                  // 0x03F1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpawnVehicleWhileUnconscious : 1;            // 0x03F1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSlowMotion : 1;                              // 0x03F1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowVehicleEditor : 1;                           // 0x03F1(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowAdminsToScrapAllVehicles : 1;                // 0x03F1(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowRemoteScrapVehicles : 1;                     // 0x03F1(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowExplodeVehicle : 1;                          // 0x03F2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowEnterHostileVehicle : 1;                     // 0x03F2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowInfiniteMoney : 1;                           // 0x03F2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowFriendlyFire : 1;                            // 0x03F2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowChangeTeamWhileAlive : 1;                    // 0x03F2(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowProjectileCamera : 1;                        // 0x03F2(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowPossessAbandonedCharacters : 1;              // 0x03F2(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowSpawnDummies : 1;                            // 0x03F2(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3F3[0x5];                                      // 0x03F3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABrickGameMode* Get(const class UObject* WorldContextObject);
	static const class ABrickGameMode* GetDefaultGameMode(const class UObject* WorldContextObject);

	void AddPlayerMoney(class ABrickPlayerController* PC, float Amount, bool bAdd);
	void AddPlayerScore(class ABrickPlayerController* PC, float Score, bool bAdd);
	void AddScoreToAllPlayers(float Score);
	void AddScoreToAllPlayersOfTeam(const struct FGenericTeamId& TeamID, float Score);
	void AddTeamScore(const struct FGenericTeamId& TeamID, int32 Score);
	void EndMatchWithWinner(const struct FMatchWinner& InWinner);
	void EndRound(const struct FMatchWinner& InWinner, bool bEndMatch);
	void ForceEndMatch();
	void MovePlayerToTeam(class ABrickPlayerController* PC, const struct FGenericTeamId& TeamID);
	void OnCapturePointCaptured(class ACapturePoint* CapturePoint, const struct FGenericTeamId& Team, const TSet<class ABaseCharacter*>& Characters);
	void OnCapturePointNeutralized(class ACapturePoint* CapturePoint, const struct FGenericTeamId& Team, const TSet<class ABaseCharacter*>& Characters);
	void OnCharacterBeginPlay(class ABaseCharacter* Character);
	void OnCharacterDied(class ABaseCharacter* Character, class AController* EventInstigator, class AActor* DamageCauser);
	void OnCharacterEndPlay(class ABaseCharacter* Character);
	void OnCharacterRevived(class ABaseCharacter* Character, class AController* EventInstigator);
	void RestartAllPlayers(bool bIncludeAlive);

	float CalcDamage(float DamageAmount, class ABaseCharacter* Character, class AController* EventInstigator, class AActor* DamageCauser) const;
	int32 GetNumPlayersAlive() const;
	bool IsReadyToEndRound(struct FMatchWinner* OutWinner, bool* bOutEndMatch) const;
	bool IsReadyToStartWarmup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGameMode">();
	}
	static class ABrickGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGameMode>();
	}
};
static_assert(alignof(ABrickGameMode) == 0x000008, "Wrong alignment on ABrickGameMode");
static_assert(sizeof(ABrickGameMode) == 0x0003F8, "Wrong size on ABrickGameMode");
static_assert(offsetof(ABrickGameMode, DefaultTeam) == 0x000320, "Member 'ABrickGameMode::DefaultTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, ZombieTeam) == 0x000328, "Member 'ABrickGameMode::ZombieTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, DummyTeam) == 0x000330, "Member 'ABrickGameMode::DummyTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, Teams) == 0x000338, "Member 'ABrickGameMode::Teams' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, VehicleClass) == 0x000388, "Member 'ABrickGameMode::VehicleClass' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, InactiveCharacterLifeSpan) == 0x000390, "Member 'ABrickGameMode::InactiveCharacterLifeSpan' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MinUnpossessDelay) == 0x000394, "Member 'ABrickGameMode::MinUnpossessDelay' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, AutoBalanceTeamsThreshold) == 0x00039C, "Member 'ABrickGameMode::AutoBalanceTeamsThreshold' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MaxSpawnPlayerRelevanceDistance) == 0x0003A0, "Member 'ABrickGameMode::MaxSpawnPlayerRelevanceDistance' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MaxLocalChatDistance) == 0x0003A4, "Member 'ABrickGameMode::MaxLocalChatDistance' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MaxTeamScore) == 0x0003A8, "Member 'ABrickGameMode::MaxTeamScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, KillTeamScore) == 0x0003AC, "Member 'ABrickGameMode::KillTeamScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, AddScoreMoneyRatio) == 0x0003B0, "Member 'ABrickGameMode::AddScoreMoneyRatio' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, KillScore) == 0x0003B4, "Member 'ABrickGameMode::KillScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, ZombieKillScore) == 0x0003B8, "Member 'ABrickGameMode::ZombieKillScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, PointCapturedScore) == 0x0003BC, "Member 'ABrickGameMode::PointCapturedScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, PointNeutralizedScore) == 0x0003C0, "Member 'ABrickGameMode::PointNeutralizedScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, RoundWinScore) == 0x0003C4, "Member 'ABrickGameMode::RoundWinScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, IntermissionRoundWinScore) == 0x0003C8, "Member 'ABrickGameMode::IntermissionRoundWinScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, bShowMatchScore) == 0x0003CC, "Member 'ABrickGameMode::bShowMatchScore' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, WarmupTime) == 0x0003D0, "Member 'ABrickGameMode::WarmupTime' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, RoundStartTime) == 0x0003D4, "Member 'ABrickGameMode::RoundStartTime' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, RoundEndTime) == 0x0003D8, "Member 'ABrickGameMode::RoundEndTime' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, IntermissionTime) == 0x0003DC, "Member 'ABrickGameMode::IntermissionTime' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MatchEndTime) == 0x0003E0, "Member 'ABrickGameMode::MatchEndTime' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, MaxRoundsPerMatch) == 0x0003E8, "Member 'ABrickGameMode::MaxRoundsPerMatch' has a wrong offset!");
static_assert(offsetof(ABrickGameMode, NumRoundsToIntermission) == 0x0003EC, "Member 'ABrickGameMode::NumRoundsToIntermission' has a wrong offset!");

// Class BrickRigs.BrickTeam
// 0x00A0 (0x00C8 - 0x0028)
class UBrickTeam : public UObject
{
public:
	uint8                                         Pad_28[0x2];                                       // 0x0028(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Score;                                             // 0x002A(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        MaxScore;                                          // 0x002C(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E[0xA];                                       // 0x002E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              BadgeTexture;                                      // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TeamColor;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryLoadout                      DefaultLoadout;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x30];                                      // 0x0098(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_MaxScore();
	void OnRep_Score();
	void SetMaxScore(int32 NewMaxScore);
	void SetScore(int32 NewScore);

	int32 GetMaxScore() const;
	int32 GetScore() const;
	class FText GetTeamDisplayName() const;
	const struct FGenericTeamId GetTeamId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTeam">();
	}
	static class UBrickTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTeam>();
	}
};
static_assert(alignof(UBrickTeam) == 0x000008, "Wrong alignment on UBrickTeam");
static_assert(sizeof(UBrickTeam) == 0x0000C8, "Wrong size on UBrickTeam");
static_assert(offsetof(UBrickTeam, Score) == 0x00002A, "Member 'UBrickTeam::Score' has a wrong offset!");
static_assert(offsetof(UBrickTeam, MaxScore) == 0x00002C, "Member 'UBrickTeam::MaxScore' has a wrong offset!");
static_assert(offsetof(UBrickTeam, DisplayName) == 0x000038, "Member 'UBrickTeam::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickTeam, BadgeTexture) == 0x000050, "Member 'UBrickTeam::BadgeTexture' has a wrong offset!");
static_assert(offsetof(UBrickTeam, TeamColor) == 0x000078, "Member 'UBrickTeam::TeamColor' has a wrong offset!");
static_assert(offsetof(UBrickTeam, DefaultLoadout) == 0x000088, "Member 'UBrickTeam::DefaultLoadout' has a wrong offset!");

// Class BrickRigs.BattleGameMode
// 0x0000 (0x03F8 - 0x03F8)
class ABattleGameMode : public ABrickGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleGameMode">();
	}
	static class ABattleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleGameMode>();
	}
};
static_assert(alignof(ABattleGameMode) == 0x000008, "Wrong alignment on ABattleGameMode");
static_assert(sizeof(ABattleGameMode) == 0x0003F8, "Wrong size on ABattleGameMode");

// Class BrickRigs.BillboardImage
// 0x0030 (0x0060 - 0x0030)
class UBillboardImage final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BillboardImage">();
	}
	static class UBillboardImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBillboardImage>();
	}
};
static_assert(alignof(UBillboardImage) == 0x000008, "Wrong alignment on UBillboardImage");
static_assert(sizeof(UBillboardImage) == 0x000060, "Wrong size on UBillboardImage");
static_assert(offsetof(UBillboardImage, Texture) == 0x000030, "Member 'UBillboardImage::Texture' has a wrong offset!");
static_assert(offsetof(UBillboardImage, Probability) == 0x000058, "Member 'UBillboardImage::Probability' has a wrong offset!");

// Class BrickRigs.BrickThumbnailSubsystem
// 0x0050 (0x0090 - 0x0040)
class UBrickThumbnailSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 ThumbnailRenderTarget;                             // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               TextureRenderMID;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               InventoryItemMID;                                  // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               CaptureComponent;                                  // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   CaptureStaticMeshComponent;                        // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickEditorInterfaceComponent*         EditorInterfaceComponent;                          // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickThumbnailSubsystem">();
	}
	static class UBrickThumbnailSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickThumbnailSubsystem>();
	}
};
static_assert(alignof(UBrickThumbnailSubsystem) == 0x000008, "Wrong alignment on UBrickThumbnailSubsystem");
static_assert(sizeof(UBrickThumbnailSubsystem) == 0x000090, "Wrong size on UBrickThumbnailSubsystem");
static_assert(offsetof(UBrickThumbnailSubsystem, ThumbnailRenderTarget) == 0x000050, "Member 'UBrickThumbnailSubsystem::ThumbnailRenderTarget' has a wrong offset!");
static_assert(offsetof(UBrickThumbnailSubsystem, TextureRenderMID) == 0x000058, "Member 'UBrickThumbnailSubsystem::TextureRenderMID' has a wrong offset!");
static_assert(offsetof(UBrickThumbnailSubsystem, InventoryItemMID) == 0x000060, "Member 'UBrickThumbnailSubsystem::InventoryItemMID' has a wrong offset!");
static_assert(offsetof(UBrickThumbnailSubsystem, CaptureComponent) == 0x000078, "Member 'UBrickThumbnailSubsystem::CaptureComponent' has a wrong offset!");
static_assert(offsetof(UBrickThumbnailSubsystem, CaptureStaticMeshComponent) == 0x000080, "Member 'UBrickThumbnailSubsystem::CaptureStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UBrickThumbnailSubsystem, EditorInterfaceComponent) == 0x000088, "Member 'UBrickThumbnailSubsystem::EditorInterfaceComponent' has a wrong offset!");

// Class BrickRigs.Billboard
// 0x0018 (0x0258 - 0x0240)
class ABillboard : public AStaticMeshProp
{
public:
	uint8                                         BillboardRandSeed;                                 // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_241[0x17];                                     // 0x0241(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Billboard">();
	}
	static class ABillboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABillboard>();
	}
};
static_assert(alignof(ABillboard) == 0x000008, "Wrong alignment on ABillboard");
static_assert(sizeof(ABillboard) == 0x000258, "Wrong size on ABillboard");
static_assert(offsetof(ABillboard, BillboardRandSeed) == 0x000240, "Member 'ABillboard::BillboardRandSeed' has a wrong offset!");

// Class BrickRigs.BrickSpacer
// 0x0010 (0x0220 - 0x0210)
class UBrickSpacer final : public UImage
{
public:
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorStyle(EBrickUIColorStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSpacer">();
	}
	static class UBrickSpacer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSpacer>();
	}
};
static_assert(alignof(UBrickSpacer) == 0x000008, "Wrong alignment on UBrickSpacer");
static_assert(sizeof(UBrickSpacer) == 0x000220, "Wrong size on UBrickSpacer");
static_assert(offsetof(UBrickSpacer, ColorStyle) == 0x000218, "Member 'UBrickSpacer::ColorStyle' has a wrong offset!");

// Class BrickRigs.PopupParams
// 0x0040 (0x0068 - 0x0028)
class UPopupParams : public UObject
{
public:
	class ABasePlayerController*                  OwningPC;                                          // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PopupClass;                                        // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindOnPopupClosedDelegate(TDelegate<void(EPopupResult Result)> Delegate);
	void OnPopupClosed(const EPopupResult Result);
	void OnPopupOpened();

	class ABasePlayerController* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupParams">();
	}
	static class UPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupParams>();
	}
};
static_assert(alignof(UPopupParams) == 0x000008, "Wrong alignment on UPopupParams");
static_assert(sizeof(UPopupParams) == 0x000068, "Wrong size on UPopupParams");
static_assert(offsetof(UPopupParams, OwningPC) == 0x000028, "Member 'UPopupParams::OwningPC' has a wrong offset!");
static_assert(offsetof(UPopupParams, PopupClass) == 0x000040, "Member 'UPopupParams::PopupClass' has a wrong offset!");

// Class BrickRigs.BindKeyPopupParams
// 0x0138 (0x01A0 - 0x0068)
class UBindKeyPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x138];                                     // 0x0068(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BindKeyPopupParams">();
	}
	static class UBindKeyPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBindKeyPopupParams>();
	}
};
static_assert(alignof(UBindKeyPopupParams) == 0x000008, "Wrong alignment on UBindKeyPopupParams");
static_assert(sizeof(UBindKeyPopupParams) == 0x0001A0, "Wrong size on UBindKeyPopupParams");

// Class BrickRigs.BrickVehicleDownloadReplicator
// 0x0030 (0x0250 - 0x0220)
class ABrickVehicleDownloadReplicator final : public AActor
{
public:
	class ABrickVehicle*                          Vehicle;                                           // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickPlayerController*                 SpawningPC;                                        // 0x0228(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   VehicleDisplayName;                                // 0x0230(0x0018)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         DownloadProgress;                                  // 0x0248(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DownloadProgress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickVehicleDownloadReplicator">();
	}
	static class ABrickVehicleDownloadReplicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickVehicleDownloadReplicator>();
	}
};
static_assert(alignof(ABrickVehicleDownloadReplicator) == 0x000008, "Wrong alignment on ABrickVehicleDownloadReplicator");
static_assert(sizeof(ABrickVehicleDownloadReplicator) == 0x000250, "Wrong size on ABrickVehicleDownloadReplicator");
static_assert(offsetof(ABrickVehicleDownloadReplicator, Vehicle) == 0x000220, "Member 'ABrickVehicleDownloadReplicator::Vehicle' has a wrong offset!");
static_assert(offsetof(ABrickVehicleDownloadReplicator, SpawningPC) == 0x000228, "Member 'ABrickVehicleDownloadReplicator::SpawningPC' has a wrong offset!");
static_assert(offsetof(ABrickVehicleDownloadReplicator, VehicleDisplayName) == 0x000230, "Member 'ABrickVehicleDownloadReplicator::VehicleDisplayName' has a wrong offset!");
static_assert(offsetof(ABrickVehicleDownloadReplicator, DownloadProgress) == 0x000248, "Member 'ABrickVehicleDownloadReplicator::DownloadProgress' has a wrong offset!");

// Class BrickRigs.BindKeyPopupWidget
// 0x0090 (0x0328 - 0x0298)
class UBindKeyPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x68];                                     // 0x0298(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UControlHintWidget*                     ClearKeyControlHint;                               // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputChordWidget*                      InputChordWidget;                                  // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonWidget*                      ConfirmButton;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonWidget*                      CancelButton;                                      // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonWidget*                      RetryButton;                                       // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickedRetry();
	void UpdateConflictedMappings(bool bIsConflicted, const TArray<class FText>& ConflictedMappingNames);
	void UpdateIsBindingKey(bool bNewIsBinding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BindKeyPopupWidget">();
	}
	static class UBindKeyPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBindKeyPopupWidget>();
	}
};
static_assert(alignof(UBindKeyPopupWidget) == 0x000008, "Wrong alignment on UBindKeyPopupWidget");
static_assert(sizeof(UBindKeyPopupWidget) == 0x000328, "Wrong size on UBindKeyPopupWidget");
static_assert(offsetof(UBindKeyPopupWidget, ClearKeyControlHint) == 0x000300, "Member 'UBindKeyPopupWidget::ClearKeyControlHint' has a wrong offset!");
static_assert(offsetof(UBindKeyPopupWidget, InputChordWidget) == 0x000308, "Member 'UBindKeyPopupWidget::InputChordWidget' has a wrong offset!");
static_assert(offsetof(UBindKeyPopupWidget, ConfirmButton) == 0x000310, "Member 'UBindKeyPopupWidget::ConfirmButton' has a wrong offset!");
static_assert(offsetof(UBindKeyPopupWidget, CancelButton) == 0x000318, "Member 'UBindKeyPopupWidget::CancelButton' has a wrong offset!");
static_assert(offsetof(UBindKeyPopupWidget, RetryButton) == 0x000320, "Member 'UBindKeyPopupWidget::RetryButton' has a wrong offset!");

// Class BrickRigs.BladeHolderBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UBladeHolderBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BladeHolderBrickStaticInfo">();
	}
	static class UBladeHolderBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBladeHolderBrickStaticInfo>();
	}
};
static_assert(alignof(UBladeHolderBrickStaticInfo) == 0x000008, "Wrong alignment on UBladeHolderBrickStaticInfo");
static_assert(sizeof(UBladeHolderBrickStaticInfo) == 0x000168, "Wrong size on UBladeHolderBrickStaticInfo");

// Class BrickRigs.DestructibleISMComponent
// 0x0020 (0x0610 - 0x05F0)
class UDestructibleISMComponent final : public UInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_5F0[0x20];                                     // 0x05F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleISMComponent">();
	}
	static class UDestructibleISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleISMComponent>();
	}
};
static_assert(alignof(UDestructibleISMComponent) == 0x000010, "Wrong alignment on UDestructibleISMComponent");
static_assert(sizeof(UDestructibleISMComponent) == 0x000610, "Wrong size on UDestructibleISMComponent");

// Class BrickRigs.BoolPropertyWidget
// 0x0008 (0x0288 - 0x0280)
class UBoolPropertyWidget : public UPropertyWidget
{
public:
	class UBrickComboBoxWidget*                   ComboBox;                                          // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void OnItemSelected(int32 Item, EValueChangedEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoolPropertyWidget">();
	}
	static class UBoolPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoolPropertyWidget>();
	}
};
static_assert(alignof(UBoolPropertyWidget) == 0x000008, "Wrong alignment on UBoolPropertyWidget");
static_assert(sizeof(UBoolPropertyWidget) == 0x000288, "Wrong size on UBoolPropertyWidget");
static_assert(offsetof(UBoolPropertyWidget, ComboBox) == 0x000280, "Member 'UBoolPropertyWidget::ComboBox' has a wrong offset!");

// Class BrickRigs.BrickTextBlock
// 0x0010 (0x02B8 - 0x02A8)
class UBrickTextBlock final : public UTextBlock
{
public:
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUIColorStyle                            ColorStyle;                                        // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIStyleState                            StyleState;                                        // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUITextStyle                             TextStyle;                                         // 0x02B2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B3[0x5];                                      // 0x02B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetStyleState(EBrickUIStyleState NewState);
	void SetTextStyle(EBrickUITextStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTextBlock">();
	}
	static class UBrickTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTextBlock>();
	}
};
static_assert(alignof(UBrickTextBlock) == 0x000008, "Wrong alignment on UBrickTextBlock");
static_assert(sizeof(UBrickTextBlock) == 0x0002B8, "Wrong size on UBrickTextBlock");
static_assert(offsetof(UBrickTextBlock, ColorStyle) == 0x0002B0, "Member 'UBrickTextBlock::ColorStyle' has a wrong offset!");
static_assert(offsetof(UBrickTextBlock, StyleState) == 0x0002B1, "Member 'UBrickTextBlock::StyleState' has a wrong offset!");
static_assert(offsetof(UBrickTextBlock, TextStyle) == 0x0002B2, "Member 'UBrickTextBlock::TextStyle' has a wrong offset!");

// Class BrickRigs.BrickAIController
// 0x0008 (0x0330 - 0x0328)
class ABrickAIController : public AAIController
{
public:
	float                                         ControlRotationInterpSpeed;                        // 0x0328(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32C[0x4];                                      // 0x032C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickAIController">();
	}
	static class ABrickAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickAIController>();
	}
};
static_assert(alignof(ABrickAIController) == 0x000008, "Wrong alignment on ABrickAIController");
static_assert(sizeof(ABrickAIController) == 0x000330, "Wrong size on ABrickAIController");
static_assert(offsetof(ABrickAIController, ControlRotationInterpSpeed) == 0x000328, "Member 'ABrickAIController::ControlRotationInterpSpeed' has a wrong offset!");

// Class BrickRigs.DamageType_Fire
// 0x0000 (0x0040 - 0x0040)
class UDamageType_Fire : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_Fire">();
	}
	static class UDamageType_Fire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_Fire>();
	}
};
static_assert(alignof(UDamageType_Fire) == 0x000008, "Wrong alignment on UDamageType_Fire");
static_assert(sizeof(UDamageType_Fire) == 0x000040, "Wrong size on UDamageType_Fire");

// Class BrickRigs.DamageType_Detonator
// 0x0000 (0x0040 - 0x0040)
class UDamageType_Detonator final : public UDamageType_Fire
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_Detonator">();
	}
	static class UDamageType_Detonator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_Detonator>();
	}
};
static_assert(alignof(UDamageType_Detonator) == 0x000008, "Wrong alignment on UDamageType_Detonator");
static_assert(sizeof(UDamageType_Detonator) == 0x000040, "Wrong size on UDamageType_Detonator");

// Class BrickRigs.BrickAssetManager
// 0x01B8 (0x0630 - 0x0478)
class UBrickAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         ModHookClasses;                                    // 0x0480(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         BrickStaticInfoClasses;                            // 0x0490(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         BrickFilterClasses;                                // 0x04A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickMaterial*>                 BrickMaterials;                                    // 0x04B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         BrickPatternClasses;                               // 0x04C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickDecal*>                    BrickDecals;                                       // 0x04D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBrickFont*>                     BrickFonts;                                        // 0x04E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UExhaustEffect*>                 ExhaustEffects;                                    // 0x04F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         SirenSequenceClasses;                              // 0x0500(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         SirenTypeClasses;                                  // 0x0510(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         ExplosiveMaterialClasses;                          // 0x0520(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         InventoryItemClasses;                              // 0x0530(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UClass*>                         UIStyleClasses;                                    // 0x0540(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UWeatherCondition*>              WeatherConditions;                                 // 0x0550(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ULevelInfo*>                     LevelInfos;                                        // 0x0560(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UGameModeInfo*>                  GameModeInfos;                                     // 0x0570(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBillboardImage*>                BillboardImages;                                   // 0x0580(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UMenuMusic*>                     MenuMusicAssets;                                   // 0x0590(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A0[0x90];                                     // 0x05A0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickAssetManager* Get();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickAssetManager">();
	}
	static class UBrickAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickAssetManager>();
	}
};
static_assert(alignof(UBrickAssetManager) == 0x000008, "Wrong alignment on UBrickAssetManager");
static_assert(sizeof(UBrickAssetManager) == 0x000630, "Wrong size on UBrickAssetManager");
static_assert(offsetof(UBrickAssetManager, ModHookClasses) == 0x000480, "Member 'UBrickAssetManager::ModHookClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickStaticInfoClasses) == 0x000490, "Member 'UBrickAssetManager::BrickStaticInfoClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickFilterClasses) == 0x0004A0, "Member 'UBrickAssetManager::BrickFilterClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickMaterials) == 0x0004B0, "Member 'UBrickAssetManager::BrickMaterials' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickPatternClasses) == 0x0004C0, "Member 'UBrickAssetManager::BrickPatternClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickDecals) == 0x0004D0, "Member 'UBrickAssetManager::BrickDecals' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BrickFonts) == 0x0004E0, "Member 'UBrickAssetManager::BrickFonts' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, ExhaustEffects) == 0x0004F0, "Member 'UBrickAssetManager::ExhaustEffects' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, SirenSequenceClasses) == 0x000500, "Member 'UBrickAssetManager::SirenSequenceClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, SirenTypeClasses) == 0x000510, "Member 'UBrickAssetManager::SirenTypeClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, ExplosiveMaterialClasses) == 0x000520, "Member 'UBrickAssetManager::ExplosiveMaterialClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, InventoryItemClasses) == 0x000530, "Member 'UBrickAssetManager::InventoryItemClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, UIStyleClasses) == 0x000540, "Member 'UBrickAssetManager::UIStyleClasses' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, WeatherConditions) == 0x000550, "Member 'UBrickAssetManager::WeatherConditions' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, LevelInfos) == 0x000560, "Member 'UBrickAssetManager::LevelInfos' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, GameModeInfos) == 0x000570, "Member 'UBrickAssetManager::GameModeInfos' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, BillboardImages) == 0x000580, "Member 'UBrickAssetManager::BillboardImages' has a wrong offset!");
static_assert(offsetof(UBrickAssetManager, MenuMusicAssets) == 0x000590, "Member 'UBrickAssetManager::MenuMusicAssets' has a wrong offset!");

// Class BrickRigs.BrickEditorStaticMeshComponent
// 0x0010 (0x0550 - 0x0540)
class UBrickEditorStaticMeshComponent : public UStaticMeshComponent
{
public:
	uint8                                         Pad_540[0x10];                                     // 0x0540(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorStaticMeshComponent">();
	}
	static class UBrickEditorStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorStaticMeshComponent>();
	}
};
static_assert(alignof(UBrickEditorStaticMeshComponent) == 0x000010, "Wrong alignment on UBrickEditorStaticMeshComponent");
static_assert(sizeof(UBrickEditorStaticMeshComponent) == 0x000550, "Wrong size on UBrickEditorStaticMeshComponent");

// Class BrickRigs.BrickStaticMeshComponent
// 0x0010 (0x0560 - 0x0550)
class UBrickStaticMeshComponent final : public UBrickEditorStaticMeshComponent
{
public:
	uint8                                         Pad_550[0x10];                                     // 0x0550(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickStaticMeshComponent">();
	}
	static class UBrickStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickStaticMeshComponent>();
	}
};
static_assert(alignof(UBrickStaticMeshComponent) == 0x000010, "Wrong alignment on UBrickStaticMeshComponent");
static_assert(sizeof(UBrickStaticMeshComponent) == 0x000560, "Wrong size on UBrickStaticMeshComponent");

// Class BrickRigs.BrickCameraManager
// 0x0080 (0x2890 - 0x2810)
class ABrickCameraManager : public APlayerCameraManager
{
public:
	uint8                                         Pad_2810[0x28];                                    // 0x2810(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        AirNoiseAudioComponent;                            // 0x2838(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatInterval                         FocalDistanceRange;                                // 0x2840(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusInterpSpeed;                                  // 0x2848(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectLength;                                   // 0x284C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectFalloff;                                  // 0x2850(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectFOVScale;                                 // 0x2854(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectMaxFlinchAngle;                           // 0x2858(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitEffectFilmToe;                                  // 0x285C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HitEffectColorScale;                               // 0x2860(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictedAreaEffectInterpSpeed;                   // 0x2870(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestrictedAreaEffectSaturation;                    // 0x2874(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AirNoiseSound;                                     // 0x2878(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         AirNoiseSpeedRange;                                // 0x2880(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirNoiseVolumeInterpSpeed;                         // 0x2888(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_288C[0x4];                                     // 0x288C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickCameraManager">();
	}
	static class ABrickCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickCameraManager>();
	}
};
static_assert(alignof(ABrickCameraManager) == 0x000010, "Wrong alignment on ABrickCameraManager");
static_assert(sizeof(ABrickCameraManager) == 0x002890, "Wrong size on ABrickCameraManager");
static_assert(offsetof(ABrickCameraManager, AirNoiseAudioComponent) == 0x002838, "Member 'ABrickCameraManager::AirNoiseAudioComponent' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, FocalDistanceRange) == 0x002840, "Member 'ABrickCameraManager::FocalDistanceRange' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, FocusInterpSpeed) == 0x002848, "Member 'ABrickCameraManager::FocusInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectLength) == 0x00284C, "Member 'ABrickCameraManager::HitEffectLength' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectFalloff) == 0x002850, "Member 'ABrickCameraManager::HitEffectFalloff' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectFOVScale) == 0x002854, "Member 'ABrickCameraManager::HitEffectFOVScale' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectMaxFlinchAngle) == 0x002858, "Member 'ABrickCameraManager::HitEffectMaxFlinchAngle' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectFilmToe) == 0x00285C, "Member 'ABrickCameraManager::HitEffectFilmToe' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, HitEffectColorScale) == 0x002860, "Member 'ABrickCameraManager::HitEffectColorScale' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, RestrictedAreaEffectInterpSpeed) == 0x002870, "Member 'ABrickCameraManager::RestrictedAreaEffectInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, RestrictedAreaEffectSaturation) == 0x002874, "Member 'ABrickCameraManager::RestrictedAreaEffectSaturation' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, AirNoiseSound) == 0x002878, "Member 'ABrickCameraManager::AirNoiseSound' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, AirNoiseSpeedRange) == 0x002880, "Member 'ABrickCameraManager::AirNoiseSpeedRange' has a wrong offset!");
static_assert(offsetof(ABrickCameraManager, AirNoiseVolumeInterpSpeed) == 0x002888, "Member 'ABrickCameraManager::AirNoiseVolumeInterpSpeed' has a wrong offset!");

// Class BrickRigs.BrickCharacter
// 0x0150 (0x0910 - 0x07C0)
class ABrickCharacter : public ABaseCharacter
{
public:
	uint8                                         Pad_7C0[0x10];                                     // 0x07C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AInventoryItem*                         CurrentItemPrivate;                                // 0x07D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInventoryItem*                         RepCurrentItem;                                    // 0x07D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E0[0x8];                                      // 0x07E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AInventoryItem*                         NextItem;                                          // 0x07E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrickCarryInfo                        CarriedBrick;                                      // 0x07F0(0x0030)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBrickEditorObjectID                   VehicleSeatID;                                     // 0x0820(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_822[0xEE];                                     // 0x0822(0x00EE)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CockItem();
	void DropCarriedBrick(bool bYeet);
	bool EnterVehicle(class ABrickVehicle* InVehicle, const struct FBrickEditorObjectID& InSeatID);
	bool EquipCurrentItem();
	bool EquipItem(class AInventoryItem* InItem, bool bSkipUnequip);
	void ExitVehicle();
	void ForceEjectFromVehicle();
	void OnRep_CarriedBrick(const struct FBrickCarryInfo& OldCarriedBrick);
	void OnRep_CurrentItem(class AInventoryItem* PrevItem);
	void OnRep_VehicleSeatID();
	void PickUpBrick(class UBrick* Brick);
	void ReloadItem();
	void ServerCockItem();
	void ServerDropCarriedBrick(const struct FVector& BrickLocation, const struct FRotator& BrickRotation, const struct FVector& BrickVelocity);
	void ServerEnterVehicle(class ABrickVehicle* InVehicle, const struct FBrickEditorObjectID& InSeatID);
	void ServerExitVehicle();
	void ServerOnReplicatedAutoFire(class UFirearmComponent* FirearmComp, int32 MuzzlePitchAndYaw);
	void ServerOnReplicatedSingleFire(class UFirearmComponent* FirearmComp, int32 MuzzlePitchAndYaw);
	void ServerOnSingleFire(class UFirearmComponent* FirearmComp);
	void ServerOnStartAutoFire(class UFirearmComponent* FirearmComp);
	void ServerOnStopAutoFire(class UFirearmComponent* FirearmComp, uint8 RoundsFired);
	void ServerOnThrewExplosive(const struct FPlayerViewPoint& ViewPoint);
	void ServerPickUpBrick(class UBrick* Brick);
	void ServerReloadItem();
	void ServerSetCurrentItem(class AInventoryItem* NewItem);
	void ServerStartExtinguish();
	void ServerStopExtinguish();
	void ServerThrowCurrentItem(const struct FPlayerViewPoint& ViewPoint);
	void ServerThrowExplosive();
	void ServerUnequipCurrentItem();
	void ServerUpdateVehicleInput(const struct FVehicleInput& NewInput, const TArray<struct FRepActuatorState>& NewActuatorStates, class USeatBrick* Seat, const struct FRestartTransformVersion& RestartVersion, int32 PackedView, bool bNewAiming);
	void ServerUpdateVehicleViewRotation(class USeatBrick* Seat, int32 PackedView, bool bNewAiming);
	void SetAimRatio(float InAimRatio);
	void SetFireMode(EFireMode NewMode);
	void SetWantsToFire(bool bInWantsToFire);
	void ThrowCurrentItem();
	void ThrowExplosive();

	bool CanEnterVehicle(class ABrickVehicle* InVehicle, struct FBrickEditorObjectID* InOutSeatID) const;
	bool CanEquipItem(class AInventoryItem* InItem) const;
	bool CanFire() const;
	bool CanPickUpBrick(class UBrick* Brick) const;
	float GetAimRatio() const;
	class UBrick* GetCarriedBrick() const;
	class AInventoryItem* GetCurrentItem() const;
	class USeatBrick* GetVehicleSeat() const;
	const struct FBrickEditorObjectID GetVehicleSeatID() const;
	bool HasCurrentItem() const;
	bool IsCarryingBrick() const;
	bool IsFiring() const;
	bool IsInDriverSeat() const;
	bool ShouldFire() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickCharacter">();
	}
	static class ABrickCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickCharacter>();
	}
};
static_assert(alignof(ABrickCharacter) == 0x000010, "Wrong alignment on ABrickCharacter");
static_assert(sizeof(ABrickCharacter) == 0x000910, "Wrong size on ABrickCharacter");
static_assert(offsetof(ABrickCharacter, CurrentItemPrivate) == 0x0007D0, "Member 'ABrickCharacter::CurrentItemPrivate' has a wrong offset!");
static_assert(offsetof(ABrickCharacter, RepCurrentItem) == 0x0007D8, "Member 'ABrickCharacter::RepCurrentItem' has a wrong offset!");
static_assert(offsetof(ABrickCharacter, NextItem) == 0x0007E8, "Member 'ABrickCharacter::NextItem' has a wrong offset!");
static_assert(offsetof(ABrickCharacter, CarriedBrick) == 0x0007F0, "Member 'ABrickCharacter::CarriedBrick' has a wrong offset!");
static_assert(offsetof(ABrickCharacter, VehicleSeatID) == 0x000820, "Member 'ABrickCharacter::VehicleSeatID' has a wrong offset!");

// Class BrickRigs.WheelBrick
// 0x0020 (0x0118 - 0x00F8)
class UWheelBrick : public UBrick
{
public:
	TArray<class UWheelConnection*>               WheelConnections;                                  // 0x00F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bInvertTankSteering;                               // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WheelDiameter;                                     // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WheelWidth;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheelBrick">();
	}
	static class UWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheelBrick>();
	}
};
static_assert(alignof(UWheelBrick) == 0x000008, "Wrong alignment on UWheelBrick");
static_assert(sizeof(UWheelBrick) == 0x000118, "Wrong size on UWheelBrick");
static_assert(offsetof(UWheelBrick, WheelConnections) == 0x0000F8, "Member 'UWheelBrick::WheelConnections' has a wrong offset!");
static_assert(offsetof(UWheelBrick, bInvertTankSteering) == 0x000108, "Member 'UWheelBrick::bInvertTankSteering' has a wrong offset!");
static_assert(offsetof(UWheelBrick, WheelDiameter) == 0x00010C, "Member 'UWheelBrick::WheelDiameter' has a wrong offset!");
static_assert(offsetof(UWheelBrick, WheelWidth) == 0x000110, "Member 'UWheelBrick::WheelWidth' has a wrong offset!");

// Class BrickRigs.CarWheelBrick
// 0x0020 (0x0138 - 0x0118)
class UCarWheelBrick final : public UWheelBrick
{
public:
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TireThickness;                                     // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TirePressureRatio;                                 // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRootComponentWake(class UPrimitiveComponent* SleepingComponent, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarWheelBrick">();
	}
	static class UCarWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCarWheelBrick>();
	}
};
static_assert(alignof(UCarWheelBrick) == 0x000008, "Wrong alignment on UCarWheelBrick");
static_assert(sizeof(UCarWheelBrick) == 0x000138, "Wrong size on UCarWheelBrick");
static_assert(offsetof(UCarWheelBrick, TireThickness) == 0x000130, "Member 'UCarWheelBrick::TireThickness' has a wrong offset!");
static_assert(offsetof(UCarWheelBrick, TirePressureRatio) == 0x000134, "Member 'UCarWheelBrick::TirePressureRatio' has a wrong offset!");

// Class BrickRigs.CharacterAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UCharacterAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAnimInstance">();
	}
	static class UCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAnimInstance>();
	}
};
static_assert(alignof(UCharacterAnimInstance) == 0x000010, "Wrong alignment on UCharacterAnimInstance");
static_assert(sizeof(UCharacterAnimInstance) == 0x0002C0, "Wrong size on UCharacterAnimInstance");

// Class BrickRigs.JoinSessionPopupWidget
// 0x0040 (0x02D8 - 0x0298)
class UJoinSessionPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBoxWidget*                    PasswordTextBox;                                   // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   JoiningSessionText;                                // 0x02A8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   CancellingJoinText;                                // 0x02C0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void CancelJoinSession();
	void JoinSession();
	void OnPasswordChanged(const class FText& NewText, EValueChangedEventType EventType);
	void UpdateJoinState(EJoinSessionState InJoinState, bool bInPasswordRequired, bool bInHasPassword);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinSessionPopupWidget">();
	}
	static class UJoinSessionPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinSessionPopupWidget>();
	}
};
static_assert(alignof(UJoinSessionPopupWidget) == 0x000008, "Wrong alignment on UJoinSessionPopupWidget");
static_assert(sizeof(UJoinSessionPopupWidget) == 0x0002D8, "Wrong size on UJoinSessionPopupWidget");
static_assert(offsetof(UJoinSessionPopupWidget, PasswordTextBox) == 0x0002A0, "Member 'UJoinSessionPopupWidget::PasswordTextBox' has a wrong offset!");
static_assert(offsetof(UJoinSessionPopupWidget, JoiningSessionText) == 0x0002A8, "Member 'UJoinSessionPopupWidget::JoiningSessionText' has a wrong offset!");
static_assert(offsetof(UJoinSessionPopupWidget, CancellingJoinText) == 0x0002C0, "Member 'UJoinSessionPopupWidget::CancellingJoinText' has a wrong offset!");

// Class BrickRigs.BrickCharacterAnimInstance
// 0x0A40 (0x0D00 - 0x02C0)
class UBrickCharacterAnimInstance : public UCharacterAnimInstance
{
public:
	struct FBrickCharacterAnimInstanceProxy       Proxy;                                             // 0x02C0(0x0A40)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickCharacterAnimInstance">();
	}
	static class UBrickCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickCharacterAnimInstance>();
	}
};
static_assert(alignof(UBrickCharacterAnimInstance) == 0x000010, "Wrong alignment on UBrickCharacterAnimInstance");
static_assert(sizeof(UBrickCharacterAnimInstance) == 0x000D00, "Wrong size on UBrickCharacterAnimInstance");
static_assert(offsetof(UBrickCharacterAnimInstance, Proxy) == 0x0002C0, "Member 'UBrickCharacterAnimInstance::Proxy' has a wrong offset!");

// Class BrickRigs.BrickPlayerState
// 0x0110 (0x0430 - 0x0320)
class ABrickPlayerState final : public APlayerState
{
public:
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseCharacter*                         InactiveCharacter;                                 // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_330[0x1];                                      // 0x0330(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsAdmin;                                          // 0x0331(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         TeamID;                                            // 0x0332(0x0001)(Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsTeamLeader;                                     // 0x0333(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Money;                                             // 0x0334(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        Kills;                                             // 0x0338(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint16                                        Deaths;                                            // 0x033A(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAlive;                                          // 0x033C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33D[0xF3];                                     // 0x033D(0x00F3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Deaths();
	void OnRep_IsAdmin();
	void OnRep_IsAlive();
	void OnRep_IsTeamLeader();
	void OnRep_Kills();
	void OnRep_Money(float PrevValue);
	void OnRep_TeamId();
	void SetDeaths(int32 NewDeaths);
	void SetIsAdmin(bool bNewIsAdmin);
	void SetIsAlive(bool bInIsAlive);
	void SetIsTeamLeader(bool bNewLeader);
	void SetKills(int32 NewKills);
	void SetMoney(float NewValue);
	void SetScore(float NewScore);

	int32 GetDeaths() const;
	int32 GetKills() const;
	float GetMoney() const;
	class FText GetPlayerNameText() const;
	int32 GetUncompressedPing() const;
	bool IsAdmin() const;
	bool IsAlive() const;
	bool IsHost() const;
	bool IsTeamLeader() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPlayerState">();
	}
	static class ABrickPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickPlayerState>();
	}
};
static_assert(alignof(ABrickPlayerState) == 0x000008, "Wrong alignment on ABrickPlayerState");
static_assert(sizeof(ABrickPlayerState) == 0x000430, "Wrong size on ABrickPlayerState");
static_assert(offsetof(ABrickPlayerState, InactiveCharacter) == 0x000328, "Member 'ABrickPlayerState::InactiveCharacter' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, bIsAdmin) == 0x000331, "Member 'ABrickPlayerState::bIsAdmin' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, TeamID) == 0x000332, "Member 'ABrickPlayerState::TeamID' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, bIsTeamLeader) == 0x000333, "Member 'ABrickPlayerState::bIsTeamLeader' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, Money) == 0x000334, "Member 'ABrickPlayerState::Money' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, Kills) == 0x000338, "Member 'ABrickPlayerState::Kills' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, Deaths) == 0x00033A, "Member 'ABrickPlayerState::Deaths' has a wrong offset!");
static_assert(offsetof(ABrickPlayerState, bIsAlive) == 0x00033C, "Member 'ABrickPlayerState::bIsAlive' has a wrong offset!");

// Class BrickRigs.CouplingConnection
// 0x0020 (0x00F0 - 0x00D0)
class UCouplingConnection final : public UPhysicsConstraintConnection
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CouplingConnection">();
	}
	static class UCouplingConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCouplingConnection>();
	}
};
static_assert(alignof(UCouplingConnection) == 0x000008, "Wrong alignment on UCouplingConnection");
static_assert(sizeof(UCouplingConnection) == 0x0000F0, "Wrong size on UCouplingConnection");

// Class BrickRigs.TurbineConnection
// 0x0000 (0x00D0 - 0x00D0)
class UTurbineConnection final : public UPhysicsConstraintConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurbineConnection">();
	}
	static class UTurbineConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurbineConnection>();
	}
};
static_assert(alignof(UTurbineConnection) == 0x000008, "Wrong alignment on UTurbineConnection");
static_assert(sizeof(UTurbineConnection) == 0x0000D0, "Wrong size on UTurbineConnection");

// Class BrickRigs.ProjectileSeekingInterface
// 0x0000 (0x0000 - 0x0000)
class IProjectileSeekingInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileSeekingInterface">();
	}
	static class IProjectileSeekingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileSeekingInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProjectileSeekingInterface) == 0x000001, "Wrong alignment on IProjectileSeekingInterface");
static_assert(sizeof(IProjectileSeekingInterface) == 0x000001, "Wrong size on IProjectileSeekingInterface");

// Class BrickRigs.BrickConnectorsISMComponent
// 0x0010 (0x0600 - 0x05F0)
class UBrickConnectorsISMComponent final : public UInstancedStaticMeshComponent
{
public:
	class UMaterialInstanceDynamic*               Mid;                                               // 0x05F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIColorStyle                            FocusedColorStyle;                                 // 0x05F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIStyleState                            StyleState;                                        // 0x05FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIStyleState                            FocusedStyleState;                                 // 0x05FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStyle(EBrickUIColorStyle NewColorStyle, EBrickUIColorStyle NewFocusedColorStyle, EBrickUIStyleState NewStyleState, EBrickUIStyleState NewFocusedStyleState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickConnectorsISMComponent">();
	}
	static class UBrickConnectorsISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickConnectorsISMComponent>();
	}
};
static_assert(alignof(UBrickConnectorsISMComponent) == 0x000010, "Wrong alignment on UBrickConnectorsISMComponent");
static_assert(sizeof(UBrickConnectorsISMComponent) == 0x000600, "Wrong size on UBrickConnectorsISMComponent");
static_assert(offsetof(UBrickConnectorsISMComponent, Mid) == 0x0005F0, "Member 'UBrickConnectorsISMComponent::Mid' has a wrong offset!");
static_assert(offsetof(UBrickConnectorsISMComponent, ColorStyle) == 0x0005F8, "Member 'UBrickConnectorsISMComponent::ColorStyle' has a wrong offset!");
static_assert(offsetof(UBrickConnectorsISMComponent, FocusedColorStyle) == 0x0005F9, "Member 'UBrickConnectorsISMComponent::FocusedColorStyle' has a wrong offset!");
static_assert(offsetof(UBrickConnectorsISMComponent, StyleState) == 0x0005FA, "Member 'UBrickConnectorsISMComponent::StyleState' has a wrong offset!");
static_assert(offsetof(UBrickConnectorsISMComponent, FocusedStyleState) == 0x0005FB, "Member 'UBrickConnectorsISMComponent::FocusedStyleState' has a wrong offset!");

// Class BrickRigs.BrickDataSingleton
// 0x1548 (0x1570 - 0x0028)
class UBrickDataSingleton : public UObject
{
public:
	TArray<class UInputCategory*>                 InputCategories;                                   // 0x0028(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDataTable*                             InputTable;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class FText>        ItemTagDisplayNames;                               // 0x0040(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<float, class FText>                      GrayscaleColorNames;                               // 0x0090(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<float, class FText>                      HueColorNames;                                     // 0x00E0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLinearColor>        LegacyBrickPaints;                                 // 0x0130(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLegacyBrickMaterialReplacement> LegacyBrickMaterials;                  // 0x0180(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLegacyBrickEditorObjectClassCategory> LegacyBrickEditorObjectClasses;             // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSurfaceTypeEffects                    SurfaceTypeEffects[0x3F];                          // 0x01E0(0x0038)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class USoundClass*                            MainSoundClass;                                    // 0x0FA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            WorldSoundClass;                                   // 0x0FB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            MusicSoundClass;                                   // 0x0FB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickStaticInfo>           MaterialThumbnailRenderBrick;                      // 0x0FC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   NoItemThumbnailRenderClass;                        // 0x0FC8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TextureThumbnailRenderMaterial;                    // 0x0FF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ThumbnailRenderDirection;                          // 0x0FF8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1004[0xC];                                     // 0x1004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   ObjectThumbnailPostProcessSettings;                // 0x1010(0x0560)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UBrickDataSingleton* Get();

	class FText GetColorDisplayName(const struct FLinearColor& Color, bool bRoundValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickDataSingleton">();
	}
	static class UBrickDataSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickDataSingleton>();
	}
};
static_assert(alignof(UBrickDataSingleton) == 0x000010, "Wrong alignment on UBrickDataSingleton");
static_assert(sizeof(UBrickDataSingleton) == 0x001570, "Wrong size on UBrickDataSingleton");
static_assert(offsetof(UBrickDataSingleton, InputCategories) == 0x000028, "Member 'UBrickDataSingleton::InputCategories' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, InputTable) == 0x000038, "Member 'UBrickDataSingleton::InputTable' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, ItemTagDisplayNames) == 0x000040, "Member 'UBrickDataSingleton::ItemTagDisplayNames' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, GrayscaleColorNames) == 0x000090, "Member 'UBrickDataSingleton::GrayscaleColorNames' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, HueColorNames) == 0x0000E0, "Member 'UBrickDataSingleton::HueColorNames' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, LegacyBrickPaints) == 0x000130, "Member 'UBrickDataSingleton::LegacyBrickPaints' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, LegacyBrickMaterials) == 0x000180, "Member 'UBrickDataSingleton::LegacyBrickMaterials' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, LegacyBrickEditorObjectClasses) == 0x0001D0, "Member 'UBrickDataSingleton::LegacyBrickEditorObjectClasses' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, SurfaceTypeEffects) == 0x0001E0, "Member 'UBrickDataSingleton::SurfaceTypeEffects' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, MainSoundClass) == 0x000FA8, "Member 'UBrickDataSingleton::MainSoundClass' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, WorldSoundClass) == 0x000FB0, "Member 'UBrickDataSingleton::WorldSoundClass' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, MusicSoundClass) == 0x000FB8, "Member 'UBrickDataSingleton::MusicSoundClass' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, MaterialThumbnailRenderBrick) == 0x000FC0, "Member 'UBrickDataSingleton::MaterialThumbnailRenderBrick' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, NoItemThumbnailRenderClass) == 0x000FC8, "Member 'UBrickDataSingleton::NoItemThumbnailRenderClass' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, TextureThumbnailRenderMaterial) == 0x000FF0, "Member 'UBrickDataSingleton::TextureThumbnailRenderMaterial' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, ThumbnailRenderDirection) == 0x000FF8, "Member 'UBrickDataSingleton::ThumbnailRenderDirection' has a wrong offset!");
static_assert(offsetof(UBrickDataSingleton, ObjectThumbnailPostProcessSettings) == 0x001010, "Member 'UBrickDataSingleton::ObjectThumbnailPostProcessSettings' has a wrong offset!");

// Class BrickRigs.SpawnArea
// 0x0040 (0x0260 - 0x0220)
class ASpawnArea : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDIconComponent*                      HUDIconComponent;                                  // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHUDIconProperties                     HUDIconProperties;                                 // 0x0230(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnArea">();
	}
	static class ASpawnArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpawnArea>();
	}
};
static_assert(alignof(ASpawnArea) == 0x000008, "Wrong alignment on ASpawnArea");
static_assert(sizeof(ASpawnArea) == 0x000260, "Wrong size on ASpawnArea");
static_assert(offsetof(ASpawnArea, HUDIconComponent) == 0x000228, "Member 'ASpawnArea::HUDIconComponent' has a wrong offset!");
static_assert(offsetof(ASpawnArea, HUDIconProperties) == 0x000230, "Member 'ASpawnArea::HUDIconProperties' has a wrong offset!");

// Class BrickRigs.CapturePoint
// 0x0118 (0x0378 - 0x0260)
class ACapturePoint : public ASpawnArea
{
public:
	uint8                                         Pad_260[0x14];                                     // 0x0260(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RepCaptureRatio;                                   // 0x0274(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasBeenCaptured;                                  // 0x0275(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         CapturingTeam;                                     // 0x0276(0x0001)(Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         CapturedBy;                                        // 0x0277(0x0001)(Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ABaseCharacter*>                 OverlappingCharacters;                             // 0x0278(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               FlagMID;                                           // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class ABrickBuilding>          BuildingBase;                                      // 0x0298(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UShapeComponent*                        ShapeComponent;                                    // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            StaticMesh;                                        // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDrawDistance;                                   // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxFlagHeight;                                     // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                IconOffset;                                        // 0x02E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToCapture;                                     // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         CapturePointId;                                    // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECapturePointShape                            CapturePointShape;                                 // 0x02F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F2[0x2];                                      // 0x02F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ShapeOffset;                                       // 0x02F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ShapeRotation;                                     // 0x0300(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ShapeScale;                                        // 0x030C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x60];                                     // 0x0318(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCapturedByChanged();
	void OnCapturingTeamChanged();
	void OnRep_CaptureRatio();
	void OnTriggerBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnTriggerEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	bool SetCapturedBy(const struct FGenericTeamId& TeamID, bool bNewHasBeenCaptured);
	bool SetCaptureRatio(float NewRatio);
	bool SetCapturingTeam(const struct FGenericTeamId& TeamID);

	const struct FGenericTeamId GetCapturedBy() const;
	class FText GetCapturePointShortDisplayName() const;
	float GetCaptureRatio() const;
	const struct FGenericTeamId GetCapturingTeam() const;
	bool HasBeenCaptured() const;
	bool IsCapturePointOnBuilding(const class ABrickBuilding* InBuilding) const;
	bool IsCharacterOnCapturePoint(class ABaseCharacter* InCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapturePoint">();
	}
	static class ACapturePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACapturePoint>();
	}
};
static_assert(alignof(ACapturePoint) == 0x000008, "Wrong alignment on ACapturePoint");
static_assert(sizeof(ACapturePoint) == 0x000378, "Wrong size on ACapturePoint");
static_assert(offsetof(ACapturePoint, RepCaptureRatio) == 0x000274, "Member 'ACapturePoint::RepCaptureRatio' has a wrong offset!");
static_assert(offsetof(ACapturePoint, bHasBeenCaptured) == 0x000275, "Member 'ACapturePoint::bHasBeenCaptured' has a wrong offset!");
static_assert(offsetof(ACapturePoint, CapturingTeam) == 0x000276, "Member 'ACapturePoint::CapturingTeam' has a wrong offset!");
static_assert(offsetof(ACapturePoint, CapturedBy) == 0x000277, "Member 'ACapturePoint::CapturedBy' has a wrong offset!");
static_assert(offsetof(ACapturePoint, OverlappingCharacters) == 0x000278, "Member 'ACapturePoint::OverlappingCharacters' has a wrong offset!");
static_assert(offsetof(ACapturePoint, FlagMID) == 0x000288, "Member 'ACapturePoint::FlagMID' has a wrong offset!");
static_assert(offsetof(ACapturePoint, BuildingBase) == 0x000298, "Member 'ACapturePoint::BuildingBase' has a wrong offset!");
static_assert(offsetof(ACapturePoint, MeshComponent) == 0x0002C0, "Member 'ACapturePoint::MeshComponent' has a wrong offset!");
static_assert(offsetof(ACapturePoint, ShapeComponent) == 0x0002C8, "Member 'ACapturePoint::ShapeComponent' has a wrong offset!");
static_assert(offsetof(ACapturePoint, StaticMesh) == 0x0002D0, "Member 'ACapturePoint::StaticMesh' has a wrong offset!");
static_assert(offsetof(ACapturePoint, MaxDrawDistance) == 0x0002D8, "Member 'ACapturePoint::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(ACapturePoint, MaxFlagHeight) == 0x0002DC, "Member 'ACapturePoint::MaxFlagHeight' has a wrong offset!");
static_assert(offsetof(ACapturePoint, IconOffset) == 0x0002E0, "Member 'ACapturePoint::IconOffset' has a wrong offset!");
static_assert(offsetof(ACapturePoint, TimeToCapture) == 0x0002EC, "Member 'ACapturePoint::TimeToCapture' has a wrong offset!");
static_assert(offsetof(ACapturePoint, CapturePointId) == 0x0002F0, "Member 'ACapturePoint::CapturePointId' has a wrong offset!");
static_assert(offsetof(ACapturePoint, CapturePointShape) == 0x0002F1, "Member 'ACapturePoint::CapturePointShape' has a wrong offset!");
static_assert(offsetof(ACapturePoint, ShapeOffset) == 0x0002F4, "Member 'ACapturePoint::ShapeOffset' has a wrong offset!");
static_assert(offsetof(ACapturePoint, ShapeRotation) == 0x000300, "Member 'ACapturePoint::ShapeRotation' has a wrong offset!");
static_assert(offsetof(ACapturePoint, ShapeScale) == 0x00030C, "Member 'ACapturePoint::ShapeScale' has a wrong offset!");

// Class BrickRigs.BrickDecal
// 0x0018 (0x0048 - 0x0030)
class UBrickDecal final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickDecalShape                              Shape;                                             // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickDecal">();
	}
	static class UBrickDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickDecal>();
	}
};
static_assert(alignof(UBrickDecal) == 0x000008, "Wrong alignment on UBrickDecal");
static_assert(sizeof(UBrickDecal) == 0x000048, "Wrong size on UBrickDecal");
static_assert(offsetof(UBrickDecal, Texture) == 0x000038, "Member 'UBrickDecal::Texture' has a wrong offset!");
static_assert(offsetof(UBrickDecal, Shape) == 0x000040, "Member 'UBrickDecal::Shape' has a wrong offset!");

// Class BrickRigs.BrickRetainerBox
// 0x0000 (0x0150 - 0x0150)
class UBrickRetainerBox final : public URetainerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickRetainerBox">();
	}
	static class UBrickRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickRetainerBox>();
	}
};
static_assert(alignof(UBrickRetainerBox) == 0x000008, "Wrong alignment on UBrickRetainerBox");
static_assert(sizeof(UBrickRetainerBox) == 0x000150, "Wrong size on UBrickRetainerBox");

// Class BrickRigs.BrickEditableTextBox
// 0x0808 (0x1240 - 0x0A38)
class UBrickEditableTextBox final : public UEditableTextBox
{
public:
	uint8                                         Pad_A38[0x808];                                    // 0x0A38(0x0808)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditableTextBox">();
	}
	static class UBrickEditableTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditableTextBox>();
	}
};
static_assert(alignof(UBrickEditableTextBox) == 0x000008, "Wrong alignment on UBrickEditableTextBox");
static_assert(sizeof(UBrickEditableTextBox) == 0x001240, "Wrong size on UBrickEditableTextBox");

// Class BrickRigs.BrickEditor
// 0x02B8 (0x04D8 - 0x0220)
class ABrickEditor : public AActor
{
public:
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickPlayerController*                 PlayerController;                                  // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x138];                                    // 0x0278(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickEditorMode*                       CurrentEditorMode;                                 // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBrickEditorMode*>               EditorModes;                                       // 0x03B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x50];                                     // 0x03C8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               OutlineMID;                                        // 0x0418(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               BoundsMID;                                         // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickEditorInterfaceComponent*         EditorInterfaceComponent;                          // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   BoundsMeshComponent;                               // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   GridMeshComponent;                                 // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   GizmoMeshComponent;                                // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CenterOfMassMeshComponent;                         // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x78];                                     // 0x0458(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickEditorStaticInfo>     StaticInfoClass;                                   // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditor">();
	}
	static class ABrickEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickEditor>();
	}
};
static_assert(alignof(ABrickEditor) == 0x000008, "Wrong alignment on ABrickEditor");
static_assert(sizeof(ABrickEditor) == 0x0004D8, "Wrong size on ABrickEditor");
static_assert(offsetof(ABrickEditor, PlayerController) == 0x000270, "Member 'ABrickEditor::PlayerController' has a wrong offset!");
static_assert(offsetof(ABrickEditor, CurrentEditorMode) == 0x0003B0, "Member 'ABrickEditor::CurrentEditorMode' has a wrong offset!");
static_assert(offsetof(ABrickEditor, EditorModes) == 0x0003B8, "Member 'ABrickEditor::EditorModes' has a wrong offset!");
static_assert(offsetof(ABrickEditor, OutlineMID) == 0x000418, "Member 'ABrickEditor::OutlineMID' has a wrong offset!");
static_assert(offsetof(ABrickEditor, BoundsMID) == 0x000420, "Member 'ABrickEditor::BoundsMID' has a wrong offset!");
static_assert(offsetof(ABrickEditor, EditorInterfaceComponent) == 0x000430, "Member 'ABrickEditor::EditorInterfaceComponent' has a wrong offset!");
static_assert(offsetof(ABrickEditor, BoundsMeshComponent) == 0x000438, "Member 'ABrickEditor::BoundsMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickEditor, GridMeshComponent) == 0x000440, "Member 'ABrickEditor::GridMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickEditor, GizmoMeshComponent) == 0x000448, "Member 'ABrickEditor::GizmoMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickEditor, CenterOfMassMeshComponent) == 0x000450, "Member 'ABrickEditor::CenterOfMassMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickEditor, StaticInfoClass) == 0x0004D0, "Member 'ABrickEditor::StaticInfoClass' has a wrong offset!");

// Class BrickRigs.CharacterAction
// 0x0060 (0x0088 - 0x0028)
class UCharacterAction : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ItemMontage;                                       // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActionLength;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterActionLayer                         ActionLayer;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CharacterMontage;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FoleySound;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterAction">();
	}
	static class UCharacterAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterAction>();
	}
};
static_assert(alignof(UCharacterAction) == 0x000008, "Wrong alignment on UCharacterAction");
static_assert(sizeof(UCharacterAction) == 0x000088, "Wrong size on UCharacterAction");
static_assert(offsetof(UCharacterAction, ItemMontage) == 0x000060, "Member 'UCharacterAction::ItemMontage' has a wrong offset!");
static_assert(offsetof(UCharacterAction, ActionLength) == 0x000068, "Member 'UCharacterAction::ActionLength' has a wrong offset!");
static_assert(offsetof(UCharacterAction, PlayRate) == 0x00006C, "Member 'UCharacterAction::PlayRate' has a wrong offset!");
static_assert(offsetof(UCharacterAction, ActionLayer) == 0x000070, "Member 'UCharacterAction::ActionLayer' has a wrong offset!");
static_assert(offsetof(UCharacterAction, CharacterMontage) == 0x000078, "Member 'UCharacterAction::CharacterMontage' has a wrong offset!");
static_assert(offsetof(UCharacterAction, FoleySound) == 0x000080, "Member 'UCharacterAction::FoleySound' has a wrong offset!");

// Class BrickRigs.ItemAction
// 0x0010 (0x0098 - 0x0088)
class UItemAction : public UCharacterAction
{
public:
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction">();
	}
	static class UItemAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction>();
	}
};
static_assert(alignof(UItemAction) == 0x000008, "Wrong alignment on UItemAction");
static_assert(sizeof(UItemAction) == 0x000098, "Wrong size on UItemAction");

// Class BrickRigs.BrickEditorArrowComponent
// 0x0040 (0x0590 - 0x0550)
class UBrickEditorArrowComponent : public UBrickEditorStaticMeshComponent
{
public:
	uint8                                         Pad_550[0x8];                                      // 0x0550(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0558(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            LinearArrowMesh;                                   // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CircularArrowMesh;                                 // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickEditorArrowType                         ArrowType;                                         // 0x0570(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearArrowLength;                                 // 0x0574(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularArrowAngle;                                // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircularArrowRadius;                               // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_581[0xF];                                      // 0x0581(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetArrowType(EBrickEditorArrowType NewType);
	void SetCircularArrowAngle(float NewAngle);
	void SetCircularArrowRadius(float NewRadius);
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetLinearArrowLength(float NewLength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorArrowComponent">();
	}
	static class UBrickEditorArrowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorArrowComponent>();
	}
};
static_assert(alignof(UBrickEditorArrowComponent) == 0x000010, "Wrong alignment on UBrickEditorArrowComponent");
static_assert(sizeof(UBrickEditorArrowComponent) == 0x000590, "Wrong size on UBrickEditorArrowComponent");
static_assert(offsetof(UBrickEditorArrowComponent, Mid) == 0x000558, "Member 'UBrickEditorArrowComponent::Mid' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, LinearArrowMesh) == 0x000560, "Member 'UBrickEditorArrowComponent::LinearArrowMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, CircularArrowMesh) == 0x000568, "Member 'UBrickEditorArrowComponent::CircularArrowMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, ArrowType) == 0x000570, "Member 'UBrickEditorArrowComponent::ArrowType' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, LinearArrowLength) == 0x000574, "Member 'UBrickEditorArrowComponent::LinearArrowLength' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, CircularArrowAngle) == 0x000578, "Member 'UBrickEditorArrowComponent::CircularArrowAngle' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, CircularArrowRadius) == 0x00057C, "Member 'UBrickEditorArrowComponent::CircularArrowRadius' has a wrong offset!");
static_assert(offsetof(UBrickEditorArrowComponent, ColorStyle) == 0x000580, "Member 'UBrickEditorArrowComponent::ColorStyle' has a wrong offset!");

// Class BrickRigs.BrickEditorAudioComponent
// 0x0010 (0x0870 - 0x0860)
class UBrickEditorAudioComponent final : public UAudioComponent
{
public:
	uint8                                         Pad_860[0x10];                                     // 0x0860(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorAudioComponent">();
	}
	static class UBrickEditorAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorAudioComponent>();
	}
};
static_assert(alignof(UBrickEditorAudioComponent) == 0x000010, "Wrong alignment on UBrickEditorAudioComponent");
static_assert(sizeof(UBrickEditorAudioComponent) == 0x000870, "Wrong size on UBrickEditorAudioComponent");

// Class BrickRigs.BrickEditorCableComponent
// 0x0000 (0x0570 - 0x0570)
class UBrickEditorCableComponent final : public UCableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorCableComponent">();
	}
	static class UBrickEditorCableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorCableComponent>();
	}
};
static_assert(alignof(UBrickEditorCableComponent) == 0x000010, "Wrong alignment on UBrickEditorCableComponent");
static_assert(sizeof(UBrickEditorCableComponent) == 0x000570, "Wrong size on UBrickEditorCableComponent");

// Class BrickRigs.BrickEditorComponentInterface
// 0x0000 (0x0000 - 0x0000)
class IBrickEditorComponentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorComponentInterface">();
	}
	static class IBrickEditorComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBrickEditorComponentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBrickEditorComponentInterface) == 0x000001, "Wrong alignment on IBrickEditorComponentInterface");
static_assert(sizeof(IBrickEditorComponentInterface) == 0x000001, "Wrong size on IBrickEditorComponentInterface");

// Class BrickRigs.CouplingBrick
// 0x0040 (0x0138 - 0x00F8)
class UCouplingBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ECouplingMode                                 CouplingMode;                                      // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_DisengageCoupling(class ABrickPlayerController* PC);
	void Interact_EngageCoupling(class ABrickPlayerController* PC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CouplingBrick">();
	}
	static class UCouplingBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCouplingBrick>();
	}
};
static_assert(alignof(UCouplingBrick) == 0x000008, "Wrong alignment on UCouplingBrick");
static_assert(sizeof(UCouplingBrick) == 0x000138, "Wrong size on UCouplingBrick");
static_assert(offsetof(UCouplingBrick, InputChannel) == 0x000108, "Member 'UCouplingBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UCouplingBrick, CouplingMode) == 0x000130, "Member 'UCouplingBrick::CouplingMode' has a wrong offset!");

// Class BrickRigs.BrickEditorMode
// 0x0010 (0x0038 - 0x0028)
class UBrickEditorMode : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickEditor*                           BrickEditor;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorMode">();
	}
	static class UBrickEditorMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorMode>();
	}
};
static_assert(alignof(UBrickEditorMode) == 0x000008, "Wrong alignment on UBrickEditorMode");
static_assert(sizeof(UBrickEditorMode) == 0x000038, "Wrong size on UBrickEditorMode");
static_assert(offsetof(UBrickEditorMode, BrickEditor) == 0x000030, "Member 'UBrickEditorMode::BrickEditor' has a wrong offset!");

// Class BrickRigs.BrickEditorDefaultMode
// 0x0128 (0x0160 - 0x0038)
class UBrickEditorDefaultMode final : public UBrickEditorMode
{
public:
	uint8                                         Pad_38[0x128];                                     // 0x0038(0x0128)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorDefaultMode">();
	}
	static class UBrickEditorDefaultMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorDefaultMode>();
	}
};
static_assert(alignof(UBrickEditorDefaultMode) == 0x000008, "Wrong alignment on UBrickEditorDefaultMode");
static_assert(sizeof(UBrickEditorDefaultMode) == 0x000160, "Wrong size on UBrickEditorDefaultMode");

// Class BrickRigs.ConfirmResolutionPopupParams
// 0x0000 (0x0068 - 0x0068)
class UConfirmResolutionPopupParams final : public UPopupParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfirmResolutionPopupParams">();
	}
	static class UConfirmResolutionPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfirmResolutionPopupParams>();
	}
};
static_assert(alignof(UConfirmResolutionPopupParams) == 0x000008, "Wrong alignment on UConfirmResolutionPopupParams");
static_assert(sizeof(UConfirmResolutionPopupParams) == 0x000068, "Wrong size on UConfirmResolutionPopupParams");

// Class BrickRigs.BrickEditorInterfaceComponent
// 0x0080 (0x0280 - 0x0200)
class UBrickEditorInterfaceComponent : public USceneComponent
{
public:
	TArray<class UBrickEditorObject*>             BrickEditorObjects;                                // 0x01F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_208[0x78];                                     // 0x0208(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorInterfaceComponent">();
	}
	static class UBrickEditorInterfaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorInterfaceComponent>();
	}
};
static_assert(alignof(UBrickEditorInterfaceComponent) == 0x000010, "Wrong alignment on UBrickEditorInterfaceComponent");
static_assert(sizeof(UBrickEditorInterfaceComponent) == 0x000280, "Wrong size on UBrickEditorInterfaceComponent");
static_assert(offsetof(UBrickEditorInterfaceComponent, BrickEditorObjects) == 0x0001F8, "Member 'UBrickEditorInterfaceComponent::BrickEditorObjects' has a wrong offset!");

// Class BrickRigs.BrickEditorISMComponent
// 0x0010 (0x0600 - 0x05F0)
class UBrickEditorISMComponent final : public UInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_5F0[0x10];                                     // 0x05F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorISMComponent">();
	}
	static class UBrickEditorISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorISMComponent>();
	}
};
static_assert(alignof(UBrickEditorISMComponent) == 0x000010, "Wrong alignment on UBrickEditorISMComponent");
static_assert(sizeof(UBrickEditorISMComponent) == 0x000600, "Wrong size on UBrickEditorISMComponent");

// Class BrickRigs.BrickEditorMirrorAxisWidget
// 0x0010 (0x0270 - 0x0260)
class UBrickEditorMirrorAxisWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClicked();
	void UpdateCanBeSelected(bool bNewCanBeSelected);
	void UpdateIsSelected(bool bNewSelected);
	void UpdateMirrorAxis(EAxis InAxis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorMirrorAxisWidget">();
	}
	static class UBrickEditorMirrorAxisWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorMirrorAxisWidget>();
	}
};
static_assert(alignof(UBrickEditorMirrorAxisWidget) == 0x000008, "Wrong alignment on UBrickEditorMirrorAxisWidget");
static_assert(sizeof(UBrickEditorMirrorAxisWidget) == 0x000270, "Wrong size on UBrickEditorMirrorAxisWidget");

// Class BrickRigs.BaseEditorInputComponent
// 0x0010 (0x0180 - 0x0170)
class UBaseEditorInputComponent : public UBaseInputComponent
{
public:
	class ABrickEditor*                           BrickEditor;                                       // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedAddToSelection();
	void OnPressedCaptureThumbnail();
	void OnPressedCycleViewMode();
	void OnPressedDeleteSelection();
	void OnPressedDuplicateSelection();
	void OnPressedDuplicateSelectionMirrored();
	void OnPressedEditMetaData();
	void OnPressedEditorCancel();
	void OnPressedEditorCommit();
	void OnPressedExitEditor();
	void OnPressedExitEditorWithVehicle();
	void OnPressedFocusSelection();
	void OnPressedHideSelection();
	void OnPressedImportItem();
	void OnPressedInvertSelection();
	void OnPressedMirrorSelection();
	void OnPressedMoveAxisX();
	void OnPressedMoveAxisY();
	void OnPressedMoveAxisZ();
	void OnPressedMovePerpendicular();
	void OnPressedMoveSelection();
	void OnPressedNewItem();
	void OnPressedOpenItem();
	void OnPressedRedo();
	void OnPressedSaveItem();
	void OnPressedSaveItemAs();
	void OnPressedSelect();
	void OnPressedSelectAttached();
	void OnPressedSelectAttachedRecursive();
	void OnPressedSelectByClass();
	void OnPressedSelectByColor();
	void OnPressedSelectByMaterial();
	void OnPressedSelectByPattern();
	void OnPressedSelectByType();
	void OnPressedToggleMirrorMode();
	void OnPressedToggleSelection();
	void OnPressedToggleSnapping();
	void OnPressedToggleTransformSpace();
	void OnPressedUndo();
	void OnPressedUnhideAll();
	void OnPressedUploadItem();
	void OnPressedUploadItemAs();
	void OnReleasedAddToSelection();
	void OnReleasedMovePerpendicular();
	void OnReleasedSelect();

	class FText GetCycleViewModeValueText() const;
	bool GetExitEditorWithVehicleEnabled() const;
	bool GetSaveItemAsEnabled() const;
	bool GetSaveItemEnabled() const;
	bool GetUploadItemAsEnabled() const;
	bool GetUploadItemEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseEditorInputComponent">();
	}
	static class UBaseEditorInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseEditorInputComponent>();
	}
};
static_assert(alignof(UBaseEditorInputComponent) == 0x000008, "Wrong alignment on UBaseEditorInputComponent");
static_assert(sizeof(UBaseEditorInputComponent) == 0x000180, "Wrong size on UBaseEditorInputComponent");
static_assert(offsetof(UBaseEditorInputComponent, BrickEditor) == 0x000170, "Member 'UBaseEditorInputComponent::BrickEditor' has a wrong offset!");

// Class BrickRigs.ExplosiveItem
// 0x0008 (0x0278 - 0x0270)
class AExplosiveItem : public AInventoryItem
{
public:
	EExplosiveItemState                           ExplosiveState;                                    // 0x0270(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Explode(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);
	void OnRep_ExplosiveState();
	void PrimeExplosive();
	void SetExplosiveState(EExplosiveItemState NewState);

	bool IsPrimed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveItem">();
	}
	static class AExplosiveItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosiveItem>();
	}
};
static_assert(alignof(AExplosiveItem) == 0x000008, "Wrong alignment on AExplosiveItem");
static_assert(sizeof(AExplosiveItem) == 0x000278, "Wrong size on AExplosiveItem");
static_assert(offsetof(AExplosiveItem, ExplosiveState) == 0x000270, "Member 'AExplosiveItem::ExplosiveState' has a wrong offset!");

// Class BrickRigs.EditorContextInputComponent
// 0x0000 (0x0180 - 0x0180)
class UEditorContextInputComponent final : public UBaseEditorInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorContextInputComponent">();
	}
	static class UEditorContextInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorContextInputComponent>();
	}
};
static_assert(alignof(UEditorContextInputComponent) == 0x000008, "Wrong alignment on UEditorContextInputComponent");
static_assert(sizeof(UEditorContextInputComponent) == 0x000180, "Wrong size on UEditorContextInputComponent");

// Class BrickRigs.BrickEditorModeWidget
// 0x0010 (0x0270 - 0x0260)
class UBrickEditorModeWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorModeWidget">();
	}
	static class UBrickEditorModeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorModeWidget>();
	}
};
static_assert(alignof(UBrickEditorModeWidget) == 0x000008, "Wrong alignment on UBrickEditorModeWidget");
static_assert(sizeof(UBrickEditorModeWidget) == 0x000270, "Wrong size on UBrickEditorModeWidget");

// Class BrickRigs.BrickEditorMoveMode
// 0x00C8 (0x0100 - 0x0038)
class UBrickEditorMoveMode final : public UBrickEditorMode
{
public:
	uint8                                         Pad_38[0x98];                                      // 0x0038(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EffectiveMoveLocation;                             // 0x00D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               EffectiveMoveRotation;                             // 0x00DC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorMoveMode">();
	}
	static class UBrickEditorMoveMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorMoveMode>();
	}
};
static_assert(alignof(UBrickEditorMoveMode) == 0x000008, "Wrong alignment on UBrickEditorMoveMode");
static_assert(sizeof(UBrickEditorMoveMode) == 0x000100, "Wrong size on UBrickEditorMoveMode");
static_assert(offsetof(UBrickEditorMoveMode, EffectiveMoveLocation) == 0x0000D0, "Member 'UBrickEditorMoveMode::EffectiveMoveLocation' has a wrong offset!");
static_assert(offsetof(UBrickEditorMoveMode, EffectiveMoveRotation) == 0x0000DC, "Member 'UBrickEditorMoveMode::EffectiveMoveRotation' has a wrong offset!");

// Class BrickRigs.BrickEditorObjectFilter
// 0x0088 (0x00B0 - 0x0028)
class UBrickEditorObjectFilter : public UObject
{
public:
	bool                                          bIncludeUncategorizedObjects;                      // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickEditorObjectFilterParams         FilterParams;                                      // 0x0030(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBrickEditorObjectFilterParams> SubFilters;                                        // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObjectFilter">();
	}
	static class UBrickEditorObjectFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObjectFilter>();
	}
};
static_assert(alignof(UBrickEditorObjectFilter) == 0x000008, "Wrong alignment on UBrickEditorObjectFilter");
static_assert(sizeof(UBrickEditorObjectFilter) == 0x0000B0, "Wrong size on UBrickEditorObjectFilter");
static_assert(offsetof(UBrickEditorObjectFilter, bIncludeUncategorizedObjects) == 0x000028, "Member 'UBrickEditorObjectFilter::bIncludeUncategorizedObjects' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectFilter, FilterParams) == 0x000030, "Member 'UBrickEditorObjectFilter::FilterParams' has a wrong offset!");
static_assert(offsetof(UBrickEditorObjectFilter, SubFilters) == 0x0000A0, "Member 'UBrickEditorObjectFilter::SubFilters' has a wrong offset!");

// Class BrickRigs.CouplingBrickBaseStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UCouplingBrickBaseStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CouplingBrickBaseStaticInfo">();
	}
	static class UCouplingBrickBaseStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCouplingBrickBaseStaticInfo>();
	}
};
static_assert(alignof(UCouplingBrickBaseStaticInfo) == 0x000008, "Wrong alignment on UCouplingBrickBaseStaticInfo");
static_assert(sizeof(UCouplingBrickBaseStaticInfo) == 0x000168, "Wrong size on UCouplingBrickBaseStaticInfo");

// Class BrickRigs.BrickEditorObjectPickerMode
// 0x0020 (0x0058 - 0x0038)
class UBrickEditorObjectPickerMode : public UBrickEditorMode
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObjectPickerMode">();
	}
	static class UBrickEditorObjectPickerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObjectPickerMode>();
	}
};
static_assert(alignof(UBrickEditorObjectPickerMode) == 0x000008, "Wrong alignment on UBrickEditorObjectPickerMode");
static_assert(sizeof(UBrickEditorObjectPickerMode) == 0x000058, "Wrong size on UBrickEditorObjectPickerMode");

// Class BrickRigs.BrickEditorObjectPropertyPickerMode
// 0x0000 (0x0058 - 0x0058)
class UBrickEditorObjectPropertyPickerMode final : public UBrickEditorObjectPickerMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObjectPropertyPickerMode">();
	}
	static class UBrickEditorObjectPropertyPickerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObjectPropertyPickerMode>();
	}
};
static_assert(alignof(UBrickEditorObjectPropertyPickerMode) == 0x000008, "Wrong alignment on UBrickEditorObjectPropertyPickerMode");
static_assert(sizeof(UBrickEditorObjectPropertyPickerMode) == 0x000058, "Wrong size on UBrickEditorObjectPropertyPickerMode");

// Class BrickRigs.DashboardSliderWidget
// 0x0010 (0x0270 - 0x0260)
class UDashboardSliderWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickSliderWidget*                     Slider;                                            // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateColorStyle(EBrickUIColorStyle NewStyle);
	void UpdateIcon(int32 IconIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashboardSliderWidget">();
	}
	static class UDashboardSliderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashboardSliderWidget>();
	}
};
static_assert(alignof(UDashboardSliderWidget) == 0x000008, "Wrong alignment on UDashboardSliderWidget");
static_assert(sizeof(UDashboardSliderWidget) == 0x000270, "Wrong size on UDashboardSliderWidget");
static_assert(offsetof(UDashboardSliderWidget, Slider) == 0x000268, "Member 'UDashboardSliderWidget::Slider' has a wrong offset!");

// Class BrickRigs.BrickEditorPropertyPickerMode
// 0x0000 (0x0058 - 0x0058)
class UBrickEditorPropertyPickerMode final : public UBrickEditorObjectPickerMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorPropertyPickerMode">();
	}
	static class UBrickEditorPropertyPickerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorPropertyPickerMode>();
	}
};
static_assert(alignof(UBrickEditorPropertyPickerMode) == 0x000008, "Wrong alignment on UBrickEditorPropertyPickerMode");
static_assert(sizeof(UBrickEditorPropertyPickerMode) == 0x000058, "Wrong size on UBrickEditorPropertyPickerMode");

// Class BrickRigs.BrickEditorObjectPropertyWidget
// 0x0000 (0x0280 - 0x0280)
class UBrickEditorObjectPropertyWidget : public UPropertyWidget
{
public:
	void ClearSelection();
	void OpenObjectPicker();
	void SelectObjects();
	void UpdateSelectedObjects(const class FText& FirstObjectName, int32 NumSelectedObjects, bool bDefaultObjects);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorObjectPropertyWidget">();
	}
	static class UBrickEditorObjectPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorObjectPropertyWidget>();
	}
};
static_assert(alignof(UBrickEditorObjectPropertyWidget) == 0x000008, "Wrong alignment on UBrickEditorObjectPropertyWidget");
static_assert(sizeof(UBrickEditorObjectPropertyWidget) == 0x000280, "Wrong size on UBrickEditorObjectPropertyWidget");

// Class BrickRigs.BrickEditorParticleComponent
// 0x0010 (0x0720 - 0x0710)
class UBrickEditorParticleComponent final : public UParticleSystemComponent
{
public:
	uint8                                         Pad_710[0x10];                                     // 0x0710(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSystemFinishedCallback(class UParticleSystemComponent* InParticleComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorParticleComponent">();
	}
	static class UBrickEditorParticleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorParticleComponent>();
	}
};
static_assert(alignof(UBrickEditorParticleComponent) == 0x000010, "Wrong alignment on UBrickEditorParticleComponent");
static_assert(sizeof(UBrickEditorParticleComponent) == 0x000720, "Wrong size on UBrickEditorParticleComponent");

// Class BrickRigs.GravelSilo
// 0x0068 (0x02A8 - 0x0240)
class AGravelSilo final : public AStaticMeshProp
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSiloOpen;                                       // 0x0248(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionComponent*                  InteractionComponent;                              // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               OutletPSC;                                         // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           ParticleComponents;                                // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        OutletEmitter;                                     // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            ParticleMesh;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParticlesPerSecond;                                // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxOffset;                                         // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MinVelocity;                                       // 0x0288(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MaxVelocity;                                       // 0x0294(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         ParticleScale;                                     // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Interact_CloseSilo(class ABrickPlayerController* PC);
	void Interact_OpenSilo(class ABrickPlayerController* PC);
	void OnRep_bIsSiloOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GravelSilo">();
	}
	static class AGravelSilo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGravelSilo>();
	}
};
static_assert(alignof(AGravelSilo) == 0x000008, "Wrong alignment on AGravelSilo");
static_assert(sizeof(AGravelSilo) == 0x0002A8, "Wrong size on AGravelSilo");
static_assert(offsetof(AGravelSilo, bIsSiloOpen) == 0x000248, "Member 'AGravelSilo::bIsSiloOpen' has a wrong offset!");
static_assert(offsetof(AGravelSilo, InteractionComponent) == 0x000250, "Member 'AGravelSilo::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AGravelSilo, OutletPSC) == 0x000258, "Member 'AGravelSilo::OutletPSC' has a wrong offset!");
static_assert(offsetof(AGravelSilo, ParticleComponents) == 0x000260, "Member 'AGravelSilo::ParticleComponents' has a wrong offset!");
static_assert(offsetof(AGravelSilo, OutletEmitter) == 0x000270, "Member 'AGravelSilo::OutletEmitter' has a wrong offset!");
static_assert(offsetof(AGravelSilo, ParticleMesh) == 0x000278, "Member 'AGravelSilo::ParticleMesh' has a wrong offset!");
static_assert(offsetof(AGravelSilo, ParticlesPerSecond) == 0x000280, "Member 'AGravelSilo::ParticlesPerSecond' has a wrong offset!");
static_assert(offsetof(AGravelSilo, MaxOffset) == 0x000284, "Member 'AGravelSilo::MaxOffset' has a wrong offset!");
static_assert(offsetof(AGravelSilo, MinVelocity) == 0x000288, "Member 'AGravelSilo::MinVelocity' has a wrong offset!");
static_assert(offsetof(AGravelSilo, MaxVelocity) == 0x000294, "Member 'AGravelSilo::MaxVelocity' has a wrong offset!");
static_assert(offsetof(AGravelSilo, ParticleScale) == 0x0002A0, "Member 'AGravelSilo::ParticleScale' has a wrong offset!");

// Class BrickRigs.BrickEditorSkeletalMeshComponent
// 0x0010 (0x0F40 - 0x0F30)
class UBrickEditorSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_F30[0x10];                                     // 0x0F30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorSkeletalMeshComponent">();
	}
	static class UBrickEditorSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorSkeletalMeshComponent>();
	}
};
static_assert(alignof(UBrickEditorSkeletalMeshComponent) == 0x000010, "Wrong alignment on UBrickEditorSkeletalMeshComponent");
static_assert(sizeof(UBrickEditorSkeletalMeshComponent) == 0x000F40, "Wrong size on UBrickEditorSkeletalMeshComponent");

// Class BrickRigs.BrickEditorStaticInfo
// 0x0150 (0x0178 - 0x0028)
class UBrickEditorStaticInfo : public UObject
{
public:
	struct FVector                                EditorBounds;                                      // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         BoundsFadeRange;                                   // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BoundsMesh;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CenterOfMassMesh;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GridMesh;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            GizmoMesh;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GizmoSize;                                         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GizmoCenterHitRadius;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GizmoRotationArrowHitRadius;                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GizmoSweepSphereRadius;                            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     OutlineMaterial;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewObjectPlacementDistance;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewObjectPlacementSweepRadius;                     // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InitialCameraLocation;                             // 0x0080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetCameraSpeedParams           CameraSpeedParams;                                 // 0x008C(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FViewTargetZoomParams                  ZoomParams;                                        // 0x00A4(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedDistanceScale;                            // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateSpeed;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseRotateSpeed;                                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUndoSteps;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxUndoBufferSize;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSaveTime;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickEditorArrowComponent> VisualizationArrowComponentClass;                  // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickConnectorsISMComponent> ConnectorsISMComponentClass;                     // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PointLightFrustumMesh;                             // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SpotLightFrustumMesh;                              // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            InputChannelMesh;                                  // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UGCBrowserPopupClass;                              // 0x0100(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UGCMetaDataPopupClass;                             // 0x0128(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ReuploadPopupClass;                                // 0x0150(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorStaticInfo">();
	}
	static class UBrickEditorStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorStaticInfo>();
	}
};
static_assert(alignof(UBrickEditorStaticInfo) == 0x000008, "Wrong alignment on UBrickEditorStaticInfo");
static_assert(sizeof(UBrickEditorStaticInfo) == 0x000178, "Wrong size on UBrickEditorStaticInfo");
static_assert(offsetof(UBrickEditorStaticInfo, EditorBounds) == 0x000028, "Member 'UBrickEditorStaticInfo::EditorBounds' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, BoundsFadeRange) == 0x000034, "Member 'UBrickEditorStaticInfo::BoundsFadeRange' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, BoundsMesh) == 0x000040, "Member 'UBrickEditorStaticInfo::BoundsMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, CenterOfMassMesh) == 0x000048, "Member 'UBrickEditorStaticInfo::CenterOfMassMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GridMesh) == 0x000050, "Member 'UBrickEditorStaticInfo::GridMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GizmoMesh) == 0x000058, "Member 'UBrickEditorStaticInfo::GizmoMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GizmoSize) == 0x000060, "Member 'UBrickEditorStaticInfo::GizmoSize' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GizmoCenterHitRadius) == 0x000064, "Member 'UBrickEditorStaticInfo::GizmoCenterHitRadius' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GizmoRotationArrowHitRadius) == 0x000068, "Member 'UBrickEditorStaticInfo::GizmoRotationArrowHitRadius' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, GizmoSweepSphereRadius) == 0x00006C, "Member 'UBrickEditorStaticInfo::GizmoSweepSphereRadius' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, OutlineMaterial) == 0x000070, "Member 'UBrickEditorStaticInfo::OutlineMaterial' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, NewObjectPlacementDistance) == 0x000078, "Member 'UBrickEditorStaticInfo::NewObjectPlacementDistance' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, NewObjectPlacementSweepRadius) == 0x00007C, "Member 'UBrickEditorStaticInfo::NewObjectPlacementSweepRadius' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, InitialCameraLocation) == 0x000080, "Member 'UBrickEditorStaticInfo::InitialCameraLocation' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, CameraSpeedParams) == 0x00008C, "Member 'UBrickEditorStaticInfo::CameraSpeedParams' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, ZoomParams) == 0x0000A4, "Member 'UBrickEditorStaticInfo::ZoomParams' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, MoveSpeed) == 0x0000BC, "Member 'UBrickEditorStaticInfo::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, MoveSpeedDistanceScale) == 0x0000C0, "Member 'UBrickEditorStaticInfo::MoveSpeedDistanceScale' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, RotateSpeed) == 0x0000C4, "Member 'UBrickEditorStaticInfo::RotateSpeed' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, MouseRotateSpeed) == 0x0000C8, "Member 'UBrickEditorStaticInfo::MouseRotateSpeed' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, MaxUndoSteps) == 0x0000CC, "Member 'UBrickEditorStaticInfo::MaxUndoSteps' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, MaxUndoBufferSize) == 0x0000D0, "Member 'UBrickEditorStaticInfo::MaxUndoBufferSize' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, AutoSaveTime) == 0x0000D4, "Member 'UBrickEditorStaticInfo::AutoSaveTime' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, VisualizationArrowComponentClass) == 0x0000D8, "Member 'UBrickEditorStaticInfo::VisualizationArrowComponentClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, ConnectorsISMComponentClass) == 0x0000E0, "Member 'UBrickEditorStaticInfo::ConnectorsISMComponentClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, PointLightFrustumMesh) == 0x0000E8, "Member 'UBrickEditorStaticInfo::PointLightFrustumMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, SpotLightFrustumMesh) == 0x0000F0, "Member 'UBrickEditorStaticInfo::SpotLightFrustumMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, InputChannelMesh) == 0x0000F8, "Member 'UBrickEditorStaticInfo::InputChannelMesh' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, UGCBrowserPopupClass) == 0x000100, "Member 'UBrickEditorStaticInfo::UGCBrowserPopupClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, UGCMetaDataPopupClass) == 0x000128, "Member 'UBrickEditorStaticInfo::UGCMetaDataPopupClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorStaticInfo, ReuploadPopupClass) == 0x000150, "Member 'UBrickEditorStaticInfo::ReuploadPopupClass' has a wrong offset!");

// Class BrickRigs.RodBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class URodBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RodBrickStaticInfo">();
	}
	static class URodBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URodBrickStaticInfo>();
	}
};
static_assert(alignof(URodBrickStaticInfo) == 0x000008, "Wrong alignment on URodBrickStaticInfo");
static_assert(sizeof(URodBrickStaticInfo) == 0x000168, "Wrong size on URodBrickStaticInfo");

// Class BrickRigs.BrickEditorTextRenderComponent
// 0x0000 (0x0500 - 0x0500)
class UBrickEditorTextRenderComponent final : public UTextRenderComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorTextRenderComponent">();
	}
	static class UBrickEditorTextRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorTextRenderComponent>();
	}
};
static_assert(alignof(UBrickEditorTextRenderComponent) == 0x000010, "Wrong alignment on UBrickEditorTextRenderComponent");
static_assert(sizeof(UBrickEditorTextRenderComponent) == 0x000500, "Wrong size on UBrickEditorTextRenderComponent");

// Class BrickRigs.GrilleBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UGrilleBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrilleBrickStaticInfo">();
	}
	static class UGrilleBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrilleBrickStaticInfo>();
	}
};
static_assert(alignof(UGrilleBrickStaticInfo) == 0x000008, "Wrong alignment on UGrilleBrickStaticInfo");
static_assert(sizeof(UGrilleBrickStaticInfo) == 0x000168, "Wrong size on UGrilleBrickStaticInfo");

// Class BrickRigs.BrickEditorWidget
// 0x00C8 (0x0328 - 0x0260)
class UBrickEditorWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickEditorModeWidget*                 CurrentModeWidget;                                 // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UPlacableObjectWidget*>          PlacableWidgets;                                   // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBrickEditorMirrorAxisWidget*>   MirrorAxisWidgets;                                 // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPagedListHeaderWidget*                 ItemHeaderWidget;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBoxWidget*                    PlacableSearchTextBox;                             // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickGridPanel*                        PlacablesPanel;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPlacableObjectWidget>      PlacableWidgetClass;                               // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPlacablesPerRow;                                // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   UGCTaskPopupClass;                                 // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBrickEditorModeWidget>     MoveModeWidgetClass;                               // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBrickEditorMirrorAxisWidget> MirrorModeWidgetClass;                           // 0x0320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddMirrorModeWidget(class UBrickEditorMirrorAxisWidget* Widget, int32 Index_0);
	void AddModeWidget(class UBrickEditorModeWidget* Widget);
	void ClearPlacableFilter();
	void OnMeasurementSystemChanged(EMeasurementSystem NewSystem);
	void OnPlacableSearchTextChanged(const class FText& NewText, EValueChangedEventType EventType);
	void UpdateCanClearPlacableFilter(bool bNewCanClear);
	void UpdateCanPlaceObjects(bool bNewCanPlace);
	void UpdateEditorUIScale(float NewScale);
	void UpdateSelection(const class FText& SelectionName, bool bAnythingSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEditorWidget">();
	}
	static class UBrickEditorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEditorWidget>();
	}
};
static_assert(alignof(UBrickEditorWidget) == 0x000008, "Wrong alignment on UBrickEditorWidget");
static_assert(sizeof(UBrickEditorWidget) == 0x000328, "Wrong size on UBrickEditorWidget");
static_assert(offsetof(UBrickEditorWidget, CurrentModeWidget) == 0x000280, "Member 'UBrickEditorWidget::CurrentModeWidget' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, PlacableWidgets) == 0x000288, "Member 'UBrickEditorWidget::PlacableWidgets' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, MirrorAxisWidgets) == 0x0002A8, "Member 'UBrickEditorWidget::MirrorAxisWidgets' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, ItemHeaderWidget) == 0x0002C0, "Member 'UBrickEditorWidget::ItemHeaderWidget' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, PlacableSearchTextBox) == 0x0002C8, "Member 'UBrickEditorWidget::PlacableSearchTextBox' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, PlacablesPanel) == 0x0002D0, "Member 'UBrickEditorWidget::PlacablesPanel' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, PropertiesPanel) == 0x0002D8, "Member 'UBrickEditorWidget::PropertiesPanel' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, PlacableWidgetClass) == 0x0002E0, "Member 'UBrickEditorWidget::PlacableWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, NumPlacablesPerRow) == 0x0002E8, "Member 'UBrickEditorWidget::NumPlacablesPerRow' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, UGCTaskPopupClass) == 0x0002F0, "Member 'UBrickEditorWidget::UGCTaskPopupClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, MoveModeWidgetClass) == 0x000318, "Member 'UBrickEditorWidget::MoveModeWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickEditorWidget, MirrorModeWidgetClass) == 0x000320, "Member 'UBrickEditorWidget::MirrorModeWidgetClass' has a wrong offset!");

// Class BrickRigs.BrickEngineMessage
// 0x0000 (0x00A8 - 0x00A8)
class UBrickEngineMessage final : public UEngineMessage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEngineMessage">();
	}
	static class UBrickEngineMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEngineMessage>();
	}
};
static_assert(alignof(UBrickEngineMessage) == 0x000008, "Wrong alignment on UBrickEngineMessage");
static_assert(sizeof(UBrickEngineMessage) == 0x0000A8, "Wrong size on UBrickEngineMessage");

// Class BrickRigs.BrickExpandableArea
// 0x0008 (0x0340 - 0x0338)
class UBrickExpandableArea final : public UExpandableArea
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickExpandableArea">();
	}
	static class UBrickExpandableArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickExpandableArea>();
	}
};
static_assert(alignof(UBrickExpandableArea) == 0x000008, "Wrong alignment on UBrickExpandableArea");
static_assert(sizeof(UBrickExpandableArea) == 0x000340, "Wrong size on UBrickExpandableArea");

// Class BrickRigs.DestructibleInstanceTemplate
// 0x0038 (0x0068 - 0x0030)
class UDestructibleInstanceTemplate final : public UDataAsset
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            BrokenMesh;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulateBrokenMesh;                               // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrokenMeshMaxLinearSpeed;                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrokenMeshMaxAngularSpeed;                         // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamage;                                         // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrawDistance;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreakEmitterSpawnDistance;                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BreakEmitter;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BreakSound;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleInstanceTemplate">();
	}
	static class UDestructibleInstanceTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleInstanceTemplate>();
	}
};
static_assert(alignof(UDestructibleInstanceTemplate) == 0x000008, "Wrong alignment on UDestructibleInstanceTemplate");
static_assert(sizeof(UDestructibleInstanceTemplate) == 0x000068, "Wrong size on UDestructibleInstanceTemplate");
static_assert(offsetof(UDestructibleInstanceTemplate, Mesh) == 0x000030, "Member 'UDestructibleInstanceTemplate::Mesh' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, BrokenMesh) == 0x000038, "Member 'UDestructibleInstanceTemplate::BrokenMesh' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, bSimulateBrokenMesh) == 0x000040, "Member 'UDestructibleInstanceTemplate::bSimulateBrokenMesh' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, BrokenMeshMaxLinearSpeed) == 0x000044, "Member 'UDestructibleInstanceTemplate::BrokenMeshMaxLinearSpeed' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, BrokenMeshMaxAngularSpeed) == 0x000048, "Member 'UDestructibleInstanceTemplate::BrokenMeshMaxAngularSpeed' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, MinDamage) == 0x00004C, "Member 'UDestructibleInstanceTemplate::MinDamage' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, MaxDrawDistance) == 0x000050, "Member 'UDestructibleInstanceTemplate::MaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, MaxBreakEmitterSpawnDistance) == 0x000054, "Member 'UDestructibleInstanceTemplate::MaxBreakEmitterSpawnDistance' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, BreakEmitter) == 0x000058, "Member 'UDestructibleInstanceTemplate::BreakEmitter' has a wrong offset!");
static_assert(offsetof(UDestructibleInstanceTemplate, BreakSound) == 0x000060, "Member 'UDestructibleInstanceTemplate::BreakSound' has a wrong offset!");

// Class BrickRigs.BrickFont
// 0x0030 (0x0060 - 0x0030)
class UBrickFont final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FontMaterial;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickFont">();
	}
	static class UBrickFont* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickFont>();
	}
};
static_assert(alignof(UBrickFont) == 0x000008, "Wrong alignment on UBrickFont");
static_assert(sizeof(UBrickFont) == 0x000060, "Wrong size on UBrickFont");
static_assert(offsetof(UBrickFont, DisplayName) == 0x000038, "Member 'UBrickFont::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickFont, Font) == 0x000050, "Member 'UBrickFont::Font' has a wrong offset!");
static_assert(offsetof(UBrickFont, FontMaterial) == 0x000058, "Member 'UBrickFont::FontMaterial' has a wrong offset!");

// Class BrickRigs.RotorBladeBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class URotorBladeBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotorBladeBrickStaticInfo">();
	}
	static class URotorBladeBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URotorBladeBrickStaticInfo>();
	}
};
static_assert(alignof(URotorBladeBrickStaticInfo) == 0x000008, "Wrong alignment on URotorBladeBrickStaticInfo");
static_assert(sizeof(URotorBladeBrickStaticInfo) == 0x000168, "Wrong size on URotorBladeBrickStaticInfo");

// Class BrickRigs.HUDContainerWidget
// 0x0030 (0x02A8 - 0x0278)
class UHUDContainerWidget : public UMainWidgetBase
{
public:
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameOverlayWidget*                     GameOverlayWidget;                                 // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            ActiveHUDWidget;                                   // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameOverlayWidget>         GameOverlayWidgetClass;                            // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddGameOverlayWidget(class UGameOverlayWidget* Widget);
	void AddHUDWidget(class UUserWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDContainerWidget">();
	}
	static class UHUDContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDContainerWidget>();
	}
};
static_assert(alignof(UHUDContainerWidget) == 0x000008, "Wrong alignment on UHUDContainerWidget");
static_assert(sizeof(UHUDContainerWidget) == 0x0002A8, "Wrong size on UHUDContainerWidget");
static_assert(offsetof(UHUDContainerWidget, GameOverlayWidget) == 0x000288, "Member 'UHUDContainerWidget::GameOverlayWidget' has a wrong offset!");
static_assert(offsetof(UHUDContainerWidget, ActiveHUDWidget) == 0x000290, "Member 'UHUDContainerWidget::ActiveHUDWidget' has a wrong offset!");
static_assert(offsetof(UHUDContainerWidget, GameOverlayWidgetClass) == 0x0002A0, "Member 'UHUDContainerWidget::GameOverlayWidgetClass' has a wrong offset!");

// Class BrickRigs.BrickGameInstance
// 0x0480 (0x0628 - 0x01A8)
class UBrickGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x1F8];                                    // 0x01A8(0x01F8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadingScreenWidget*                   LoadingScreenWidget;                               // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWindowManagerWidget*                   WindowManagerWidget;                               // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        MusicAudioComponent;                               // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x190];                                    // 0x03B8(0x0190)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULoadingScreenWidget>       LoadingScreenWidgetClass;                          // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UWindowManagerWidget>       WindowManagerWidgetClass;                          // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FIntPoint                              UGCThumbnailResolution;                            // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              MenuMusicSoundCue;                                 // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_568[0xC0];                                     // 0x0568(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickGameInstance* Get(const class UObject* WorldContextObject);

	bool ClosePopup(struct FPopupHandle& Handle, EPopupResult Result);
	class UPopupParams* CreatePopupParams(TSubclassOf<class UPopupParams> ParamsClass);
	void OpenMainMenu(bool bForceExit);
	bool OpenMessagePopup(struct FPopupHandle& Handle, const class FText& Message, bool bCanCancel, TDelegate<void(EPopupResult Result)> ClosedDelegate);
	bool OpenPopup(struct FPopupHandle& Handle, class UPopupParams* PopupParams, bool bToggleOpen);
	bool QuitGame();

	bool IsPopupOpen(const struct FPopupHandle& Handle) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGameInstance">();
	}
	static class UBrickGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickGameInstance>();
	}
};
static_assert(alignof(UBrickGameInstance) == 0x000008, "Wrong alignment on UBrickGameInstance");
static_assert(sizeof(UBrickGameInstance) == 0x000628, "Wrong size on UBrickGameInstance");
static_assert(offsetof(UBrickGameInstance, LoadingScreenWidget) == 0x0003A0, "Member 'UBrickGameInstance::LoadingScreenWidget' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, WindowManagerWidget) == 0x0003A8, "Member 'UBrickGameInstance::WindowManagerWidget' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, MusicAudioComponent) == 0x0003B0, "Member 'UBrickGameInstance::MusicAudioComponent' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, LoadingScreenWidgetClass) == 0x000548, "Member 'UBrickGameInstance::LoadingScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, WindowManagerWidgetClass) == 0x000550, "Member 'UBrickGameInstance::WindowManagerWidgetClass' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, UGCThumbnailResolution) == 0x000558, "Member 'UBrickGameInstance::UGCThumbnailResolution' has a wrong offset!");
static_assert(offsetof(UBrickGameInstance, MenuMusicSoundCue) == 0x000560, "Member 'UBrickGameInstance::MenuMusicSoundCue' has a wrong offset!");

// Class BrickRigs.CurrentItemWidget
// 0x0008 (0x0268 - 0x0260)
class UCurrentItemWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeIn();
	void FadeOut(bool bImmediate);
	void UpdateAmmo(int32 Current, int32 Capacity, int32 Ammo);
	void UpdateAmmoType(EAmmoType NewType);
	void UpdateFireMode(const EFireMode NewMode, const bool bHasFirearm);
	void UpdateItemName(const class FText& NewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrentItemWidget">();
	}
	static class UCurrentItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrentItemWidget>();
	}
};
static_assert(alignof(UCurrentItemWidget) == 0x000008, "Wrong alignment on UCurrentItemWidget");
static_assert(sizeof(UCurrentItemWidget) == 0x000268, "Wrong size on UCurrentItemWidget");

// Class BrickRigs.BrickGameSession
// 0x0070 (0x02A8 - 0x0238)
class ABrickGameSession final : public AGameSession
{
public:
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AdminPassword;                                     // 0x0250(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FKickedPlayer>                  KickedPlayers;                                     // 0x0260(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrickChatMessage>              ChatMessageLog;                                    // 0x0280(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0xC];                                      // 0x0290(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAdminLoginAttempts;                             // 0x029C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FailedAdminLoginKickDuration;                      // 0x02A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABrickGameSession* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGameSession">();
	}
	static class ABrickGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGameSession>();
	}
};
static_assert(alignof(ABrickGameSession) == 0x000008, "Wrong alignment on ABrickGameSession");
static_assert(sizeof(ABrickGameSession) == 0x0002A8, "Wrong size on ABrickGameSession");
static_assert(offsetof(ABrickGameSession, AdminPassword) == 0x000250, "Member 'ABrickGameSession::AdminPassword' has a wrong offset!");
static_assert(offsetof(ABrickGameSession, KickedPlayers) == 0x000260, "Member 'ABrickGameSession::KickedPlayers' has a wrong offset!");
static_assert(offsetof(ABrickGameSession, ChatMessageLog) == 0x000280, "Member 'ABrickGameSession::ChatMessageLog' has a wrong offset!");
static_assert(offsetof(ABrickGameSession, MaxAdminLoginAttempts) == 0x00029C, "Member 'ABrickGameSession::MaxAdminLoginAttempts' has a wrong offset!");
static_assert(offsetof(ABrickGameSession, FailedAdminLoginKickDuration) == 0x0002A0, "Member 'ABrickGameSession::FailedAdminLoginKickDuration' has a wrong offset!");

// Class BrickRigs.BrickGameState
// 0x0348 (0x05D8 - 0x0290)
class ABrickGameState : public AGameState
{
public:
	uint8                                         Pad_290[0x18];                                     // 0x0290(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchSettings                         MatchSettings;                                     // 0x02A8(0x00C8)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FMatchSettings                         NextMatchSettings;                                 // 0x0370(0x00C8)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0xC8];                                     // 0x0438(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         MatchRandomSeed;                                   // 0x0500(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBrickTeam*>                     Teams;                                             // 0x0508(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBrickTeam*                             DefaultTeam;                                       // 0x0518(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickTeam*                             ZombieTeam;                                        // 0x0520(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickTeam*                             DummyTeam;                                         // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMatchWinner                           MatchWinner;                                       // 0x0530(0x0001)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_531[0x1];                                      // 0x0531(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        CurrentRound;                                      // 0x0532(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         SpawnPointArray;                                   // 0x0538(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadoutInventoryComponent*             LoadoutInventoryComponent;                         // 0x0550(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExitMatchDelay;                                    // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55C[0x7C];                                     // 0x055C(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABrickGameState* Get(const class UObject* WorldContextObject);

	void OnGameModeSubLevelLoaded();
	void OnMatchTimerElapsed();
	void OnRep_CurrentRound();
	void OnRep_MatchSettings();
	void OnRep_MatchWinner();
	void OnRep_NextMatchSettings();
	void SetCurrentRound(int32 NewRound);
	void SetMatchSettings(const struct FMatchSettings& NewSettings);
	void SetMatchWinner(const struct FMatchWinner& InWinner);
	void SetNextMatchSettings(const struct FMatchSettings& NewSettings);

	bool CanPlayerJoinTeam(class ABrickPlayerController* PC, const struct FGenericTeamId& TeamID) const;
	bool DoesTeamExist(const struct FGenericTeamId& TeamID) const;
	class UBrickTeam* FindTeam(const struct FGenericTeamId& TeamID) const;
	int32 GetCurrentRound() const;
	class UBrickTeam* GetDefaultTeam() const;
	class UBrickTeam* GetDummyTeam() const;
	uint8 GetMatchRandomSeed() const;
	const struct FMatchSettings GetMatchSettings() const;
	int32 GetMatchTimerRate() const;
	int32 GetMatchTimerRemaining() const;
	const struct FMatchWinner GetMatchWinner() const;
	int32 GetMaxPlayersInTeam(const struct FGenericTeamId& TeamID) const;
	const struct FMatchSettings GetNextMatchSettings() const;
	int32 GetNumFreeSlotsInTeam(const struct FGenericTeamId& TeamID) const;
	int32 GetNumPlayersInTeam(const struct FGenericTeamId& TeamID) const;
	int32 GetNumPlayersToStartWarmup() const;
	const TArray<class UBrickTeam*> GetTeams() const;
	float GetVehiclePrice(const struct FVehicleSpawnProperties& Props) const;
	class UBrickTeam* GetZombieTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGameState">();
	}
	static class ABrickGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGameState>();
	}
};
static_assert(alignof(ABrickGameState) == 0x000008, "Wrong alignment on ABrickGameState");
static_assert(sizeof(ABrickGameState) == 0x0005D8, "Wrong size on ABrickGameState");
static_assert(offsetof(ABrickGameState, MatchSettings) == 0x0002A8, "Member 'ABrickGameState::MatchSettings' has a wrong offset!");
static_assert(offsetof(ABrickGameState, NextMatchSettings) == 0x000370, "Member 'ABrickGameState::NextMatchSettings' has a wrong offset!");
static_assert(offsetof(ABrickGameState, MatchRandomSeed) == 0x000500, "Member 'ABrickGameState::MatchRandomSeed' has a wrong offset!");
static_assert(offsetof(ABrickGameState, Teams) == 0x000508, "Member 'ABrickGameState::Teams' has a wrong offset!");
static_assert(offsetof(ABrickGameState, DefaultTeam) == 0x000518, "Member 'ABrickGameState::DefaultTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameState, ZombieTeam) == 0x000520, "Member 'ABrickGameState::ZombieTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameState, DummyTeam) == 0x000528, "Member 'ABrickGameState::DummyTeam' has a wrong offset!");
static_assert(offsetof(ABrickGameState, MatchWinner) == 0x000530, "Member 'ABrickGameState::MatchWinner' has a wrong offset!");
static_assert(offsetof(ABrickGameState, CurrentRound) == 0x000532, "Member 'ABrickGameState::CurrentRound' has a wrong offset!");
static_assert(offsetof(ABrickGameState, SpawnPointArray) == 0x000538, "Member 'ABrickGameState::SpawnPointArray' has a wrong offset!");
static_assert(offsetof(ABrickGameState, LoadoutInventoryComponent) == 0x000550, "Member 'ABrickGameState::LoadoutInventoryComponent' has a wrong offset!");
static_assert(offsetof(ABrickGameState, ExitMatchDelay) == 0x000558, "Member 'ABrickGameState::ExitMatchDelay' has a wrong offset!");

// Class BrickRigs.BrickGridPanel
// 0x0018 (0x0178 - 0x0160)
class UBrickGridPanel final : public UGridPanel
{
public:
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUISpacingStyle                          SlotSpacingStyle;                                  // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultColumnFill;                                 // 0x016C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultRowFill;                                    // 0x0170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDefaultColumnFill(const float Coefficient);
	void SetDefaultRowFill(const float Coefficient);
	void SetSlotSpacingStyle(const EBrickUISpacingStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridPanel">();
	}
	static class UBrickGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickGridPanel>();
	}
};
static_assert(alignof(UBrickGridPanel) == 0x000008, "Wrong alignment on UBrickGridPanel");
static_assert(sizeof(UBrickGridPanel) == 0x000178, "Wrong size on UBrickGridPanel");
static_assert(offsetof(UBrickGridPanel, SlotSpacingStyle) == 0x000168, "Member 'UBrickGridPanel::SlotSpacingStyle' has a wrong offset!");
static_assert(offsetof(UBrickGridPanel, DefaultColumnFill) == 0x00016C, "Member 'UBrickGridPanel::DefaultColumnFill' has a wrong offset!");
static_assert(offsetof(UBrickGridPanel, DefaultRowFill) == 0x000170, "Member 'UBrickGridPanel::DefaultRowFill' has a wrong offset!");

// Class BrickRigs.BrickHorizontalBox
// 0x0010 (0x0148 - 0x0138)
class UBrickHorizontalBox final : public UHorizontalBox
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUISpacingStyle                          SlotSpacingStyle;                                  // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSlotSpacingStyle(EBrickUISpacingStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickHorizontalBox">();
	}
	static class UBrickHorizontalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickHorizontalBox>();
	}
};
static_assert(alignof(UBrickHorizontalBox) == 0x000008, "Wrong alignment on UBrickHorizontalBox");
static_assert(sizeof(UBrickHorizontalBox) == 0x000148, "Wrong size on UBrickHorizontalBox");
static_assert(offsetof(UBrickHorizontalBox, SlotSpacingStyle) == 0x000140, "Member 'UBrickHorizontalBox::SlotSpacingStyle' has a wrong offset!");

// Class BrickRigs.BrickImage
// 0x00D0 (0x02E0 - 0x0210)
class UBrickImage final : public UImage
{
public:
	uint8                                         Pad_210[0xC1];                                     // 0x0210(0x00C1)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUIColorStyle                            ColorStyle;                                        // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIStyleState                            StyleState;                                        // 0x02D2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIIconAtlas                             IconAtlas;                                         // 0x02D3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrickUIIconSlot                       IconSlot;                                          // 0x02D4(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsThrobber;                                       // 0x02DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearIconAtlas();
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetIconAtlas(EBrickUIIconAtlas NewAtlas);
	void SetIconAtlasAndSlot(EBrickUIIconAtlas NewAtlas, const struct FBrickUIIconSlot& NewSlot);
	void SetIconSlot(const struct FBrickUIIconSlot& NewSlot);
	void SetIsThrobber(bool bNewIsThrobber);
	void SetStyleState(EBrickUIStyleState NewState);

	bool IsLoadingImage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickImage">();
	}
	static class UBrickImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickImage>();
	}
};
static_assert(alignof(UBrickImage) == 0x000008, "Wrong alignment on UBrickImage");
static_assert(sizeof(UBrickImage) == 0x0002E0, "Wrong size on UBrickImage");
static_assert(offsetof(UBrickImage, ColorStyle) == 0x0002D1, "Member 'UBrickImage::ColorStyle' has a wrong offset!");
static_assert(offsetof(UBrickImage, StyleState) == 0x0002D2, "Member 'UBrickImage::StyleState' has a wrong offset!");
static_assert(offsetof(UBrickImage, IconAtlas) == 0x0002D3, "Member 'UBrickImage::IconAtlas' has a wrong offset!");
static_assert(offsetof(UBrickImage, IconSlot) == 0x0002D4, "Member 'UBrickImage::IconSlot' has a wrong offset!");
static_assert(offsetof(UBrickImage, bIsThrobber) == 0x0002DC, "Member 'UBrickImage::bIsThrobber' has a wrong offset!");

// Class BrickRigs.DragStrip
// 0x0090 (0x02B0 - 0x0220)
class ADragStrip: public AActor
{
public:
	uint8                                         Pad_220[0xC];                                      // 0x0220(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EDragRaceState                                RaceState;                                         // 0x022C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22D[0x3];                                      // 0x022D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragRaceLane                          LeftLaneState;                                     // 0x0230(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FDragRaceLane                          RightLaneState;                                    // 0x0248(0x0018)(Net, RepNotify, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               TreeMID;                                           // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionComponent*                  InteractionComponent;                              // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLine;                                         // 0x0278(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FinishLines;                                       // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector2D                              TrackBounds;                                       // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTreeLights;                                     // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PerLightDelay;                                     // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARaceTimer*                             RaceTimerRight;                                    // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARaceTimer*                             RaceTimerLeft;                                     // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UMaterialInstanceDynamic* CreateTreeMID();
	void Interact_StartRace(class ABrickPlayerController* PC);
	void OnRep_LeftLaneState();
	void OnRep_RaceState();
	void OnRep_RightLaneState();

	struct FVector GetInteractionLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragStrip">();
	}
	static class ADragStrip* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADragStrip>();
	}
};
static_assert(alignof(ADragStrip) == 0x000008, "Wrong alignment on ADragStrip");
static_assert(sizeof(ADragStrip) == 0x0002B0, "Wrong size on ADragStrip");
static_assert(offsetof(ADragStrip, RaceState) == 0x00022C, "Member 'ADragStrip::RaceState' has a wrong offset!");
static_assert(offsetof(ADragStrip, LeftLaneState) == 0x000230, "Member 'ADragStrip::LeftLaneState' has a wrong offset!");
static_assert(offsetof(ADragStrip, RightLaneState) == 0x000248, "Member 'ADragStrip::RightLaneState' has a wrong offset!");
static_assert(offsetof(ADragStrip, TreeMID) == 0x000260, "Member 'ADragStrip::TreeMID' has a wrong offset!");
static_assert(offsetof(ADragStrip, InteractionComponent) == 0x000270, "Member 'ADragStrip::InteractionComponent' has a wrong offset!");
static_assert(offsetof(ADragStrip, StartLine) == 0x000278, "Member 'ADragStrip::StartLine' has a wrong offset!");
static_assert(offsetof(ADragStrip, FinishLines) == 0x000280, "Member 'ADragStrip::FinishLines' has a wrong offset!");
static_assert(offsetof(ADragStrip, TrackBounds) == 0x000290, "Member 'ADragStrip::TrackBounds' has a wrong offset!");
static_assert(offsetof(ADragStrip, NumTreeLights) == 0x000298, "Member 'ADragStrip::NumTreeLights' has a wrong offset!");
static_assert(offsetof(ADragStrip, PerLightDelay) == 0x00029C, "Member 'ADragStrip::PerLightDelay' has a wrong offset!");
static_assert(offsetof(ADragStrip, RaceTimerRight) == 0x0002A0, "Member 'ADragStrip::RaceTimerRight' has a wrong offset!");
static_assert(offsetof(ADragStrip, RaceTimerLeft) == 0x0002A8, "Member 'ADragStrip::RaceTimerLeft' has a wrong offset!");

// Class BrickRigs.BrickLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class UBrickLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickLocalPlayer">();
	}
	static class UBrickLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickLocalPlayer>();
	}
};
static_assert(alignof(UBrickLocalPlayer) == 0x000008, "Wrong alignment on UBrickLocalPlayer");
static_assert(sizeof(UBrickLocalPlayer) == 0x000258, "Wrong size on UBrickLocalPlayer");

// Class BrickRigs.BrickMaterial
// 0x0070 (0x00A0 - 0x0030)
class UBrickMaterial final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PriceFactor;                                       // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickPhysicalMaterial*                 PhysMaterial;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metallic;                                          // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness;                                         // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Opacity;                                           // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTiling;                                        // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintMetallicAlpha;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightBrightness;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickBrightness;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DiffuseTexture;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NormalTexture;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MRAOTexture;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EmissiveTexture;                                   // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickMaterial">();
	}
	static class UBrickMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickMaterial>();
	}
};
static_assert(alignof(UBrickMaterial) == 0x000008, "Wrong alignment on UBrickMaterial");
static_assert(sizeof(UBrickMaterial) == 0x0000A0, "Wrong size on UBrickMaterial");
static_assert(offsetof(UBrickMaterial, DisplayName) == 0x000038, "Member 'UBrickMaterial::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, PriceFactor) == 0x000050, "Member 'UBrickMaterial::PriceFactor' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, PhysMaterial) == 0x000058, "Member 'UBrickMaterial::PhysMaterial' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, Metallic) == 0x000060, "Member 'UBrickMaterial::Metallic' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, Roughness) == 0x000064, "Member 'UBrickMaterial::Roughness' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, Opacity) == 0x000068, "Member 'UBrickMaterial::Opacity' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, Brightness) == 0x00006C, "Member 'UBrickMaterial::Brightness' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, BaseTiling) == 0x000070, "Member 'UBrickMaterial::BaseTiling' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, PaintMetallicAlpha) == 0x000074, "Member 'UBrickMaterial::PaintMetallicAlpha' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, LightBrightness) == 0x000078, "Member 'UBrickMaterial::LightBrightness' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, BrickBrightness) == 0x00007C, "Member 'UBrickMaterial::BrickBrightness' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, DiffuseTexture) == 0x000080, "Member 'UBrickMaterial::DiffuseTexture' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, NormalTexture) == 0x000088, "Member 'UBrickMaterial::NormalTexture' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, MRAOTexture) == 0x000090, "Member 'UBrickMaterial::MRAOTexture' has a wrong offset!");
static_assert(offsetof(UBrickMaterial, EmissiveTexture) == 0x000098, "Member 'UBrickMaterial::EmissiveTexture' has a wrong offset!");

// Class BrickRigs.DestructibleHierarchicalISMComponent
// 0x0020 (0x0700 - 0x06E0)
class UDestructibleHierarchicalISMComponent final : public UHierarchicalInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_6D8[0x28];                                     // 0x06D8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleHierarchicalISMComponent">();
	}
	static class UDestructibleHierarchicalISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleHierarchicalISMComponent>();
	}
};
static_assert(alignof(UDestructibleHierarchicalISMComponent) == 0x000010, "Wrong alignment on UDestructibleHierarchicalISMComponent");
static_assert(sizeof(UDestructibleHierarchicalISMComponent) == 0x000700, "Wrong size on UDestructibleHierarchicalISMComponent");

// Class BrickRigs.BrickMultiLineTextBox
// 0x0A78 (0x1710 - 0x0C98)
class UBrickMultiLineTextBox final : public UMultiLineEditableTextBox
{
public:
	uint8                                         Pad_C98[0xA78];                                    // 0x0C98(0x0A78)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickMultiLineTextBox">();
	}
	static class UBrickMultiLineTextBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickMultiLineTextBox>();
	}
};
static_assert(alignof(UBrickMultiLineTextBox) == 0x000008, "Wrong alignment on UBrickMultiLineTextBox");
static_assert(sizeof(UBrickMultiLineTextBox) == 0x001710, "Wrong size on UBrickMultiLineTextBox");

// Class BrickRigs.BrickObjectPool
// 0x0010 (0x0040 - 0x0030)
class UBrickObjectPool final : public UWorldSubsystem
{
public:
	TArray<class UUserWidget*>                    WidgetPool;                                        // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UBrickObjectPool* Get(const class UObject* WorldContextObject);
	static class UUserWidget* GetWidget(const class UObject* WorldContextObject, const TSubclassOf<class UUserWidget> WidgetClass);
	static void PoolWidget(class UUserWidget* Widget);
	static void PoolWidgets(TArray<class UUserWidget*>& Widgets, const int32 NumToKeep);
	static class UUserWidget* RecycleWidget(const class UObject* WorldContextObject, TArray<class UUserWidget*>& Widgets, const TSubclassOf<class UUserWidget> WidgetClass, const int32 Index_0, bool* bOutRecycled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickObjectPool">();
	}
	static class UBrickObjectPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickObjectPool>();
	}
};
static_assert(alignof(UBrickObjectPool) == 0x000008, "Wrong alignment on UBrickObjectPool");
static_assert(sizeof(UBrickObjectPool) == 0x000040, "Wrong size on UBrickObjectPool");
static_assert(offsetof(UBrickObjectPool, WidgetPool) == 0x000030, "Member 'UBrickObjectPool::WidgetPool' has a wrong offset!");

// Class BrickRigs.ExhaustBrick
// 0x0070 (0x0190 - 0x0120)
class UExhaustBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMotorBrick*                            ConnectedMotor;                                    // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x28];                                     // 0x0130(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0158(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         SpawnScale;                                        // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 SmokeColor;                                        // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UExhaustEffect*                         ExhaustEffect;                                     // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExhaustBrick">();
	}
	static class UExhaustBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExhaustBrick>();
	}
};
static_assert(alignof(UExhaustBrick) == 0x000008, "Wrong alignment on UExhaustBrick");
static_assert(sizeof(UExhaustBrick) == 0x000190, "Wrong size on UExhaustBrick");
static_assert(offsetof(UExhaustBrick, ConnectedMotor) == 0x000128, "Member 'UExhaustBrick::ConnectedMotor' has a wrong offset!");
static_assert(offsetof(UExhaustBrick, InputChannel) == 0x000158, "Member 'UExhaustBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UExhaustBrick, SpawnScale) == 0x000180, "Member 'UExhaustBrick::SpawnScale' has a wrong offset!");
static_assert(offsetof(UExhaustBrick, SmokeColor) == 0x000184, "Member 'UExhaustBrick::SmokeColor' has a wrong offset!");
static_assert(offsetof(UExhaustBrick, ExhaustEffect) == 0x000188, "Member 'UExhaustBrick::ExhaustEffect' has a wrong offset!");

// Class BrickRigs.BrickParticleModule
// 0x0000 (0x0030 - 0x0030)
class UBrickParticleModule : public UParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickParticleModule">();
	}
	static class UBrickParticleModule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickParticleModule>();
	}
};
static_assert(alignof(UBrickParticleModule) == 0x000008, "Wrong alignment on UBrickParticleModule");
static_assert(sizeof(UBrickParticleModule) == 0x000030, "Wrong size on UBrickParticleModule");

// Class BrickRigs.ParticleModuleBrickFire
// 0x0000 (0x0030 - 0x0030)
class UParticleModuleBrickFire final : public UBrickParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBrickFire">();
	}
	static class UParticleModuleBrickFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBrickFire>();
	}
};
static_assert(alignof(UParticleModuleBrickFire) == 0x000008, "Wrong alignment on UParticleModuleBrickFire");
static_assert(sizeof(UParticleModuleBrickFire) == 0x000030, "Wrong size on UParticleModuleBrickFire");

// Class BrickRigs.CompressorBrick
// 0x0000 (0x00F8 - 0x00F8)
class UCompressorBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompressorBrick">();
	}
	static class UCompressorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompressorBrick>();
	}
};
static_assert(alignof(UCompressorBrick) == 0x000008, "Wrong alignment on UCompressorBrick");
static_assert(sizeof(UCompressorBrick) == 0x0000F8, "Wrong size on UCompressorBrick");

// Class BrickRigs.ParticleModuleBrickSliding
// 0x0000 (0x0030 - 0x0030)
class UParticleModuleBrickSliding final : public UBrickParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBrickSliding">();
	}
	static class UParticleModuleBrickSliding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBrickSliding>();
	}
};
static_assert(alignof(UParticleModuleBrickSliding) == 0x000008, "Wrong alignment on UParticleModuleBrickSliding");
static_assert(sizeof(UParticleModuleBrickSliding) == 0x000030, "Wrong size on UParticleModuleBrickSliding");

// Class BrickRigs.ParticleModulePrecipitation
// 0x0000 (0x0030 - 0x0030)
class UParticleModulePrecipitation final : public UBrickParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModulePrecipitation">();
	}
	static class UParticleModulePrecipitation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModulePrecipitation>();
	}
};
static_assert(alignof(UParticleModulePrecipitation) == 0x000008, "Wrong alignment on UParticleModulePrecipitation");
static_assert(sizeof(UParticleModulePrecipitation) == 0x000030, "Wrong size on UParticleModulePrecipitation");

// Class BrickRigs.DetonatorBrick
// 0x0040 (0x0160 - 0x0120)
class UDetonatorBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void Interact_Detonate(class ABrickPlayerController* PC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetonatorBrick">();
	}
	static class UDetonatorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetonatorBrick>();
	}
};
static_assert(alignof(UDetonatorBrick) == 0x000008, "Wrong alignment on UDetonatorBrick");
static_assert(sizeof(UDetonatorBrick) == 0x000160, "Wrong size on UDetonatorBrick");
static_assert(offsetof(UDetonatorBrick, InputChannel) == 0x000138, "Member 'UDetonatorBrick::InputChannel' has a wrong offset!");

// Class BrickRigs.ParticleModuleBuildingCollapse
// 0x0000 (0x0030 - 0x0030)
class UParticleModuleBuildingCollapse final : public UBrickParticleModule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleModuleBuildingCollapse">();
	}
	static class UParticleModuleBuildingCollapse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleModuleBuildingCollapse>();
	}
};
static_assert(alignof(UParticleModuleBuildingCollapse) == 0x000008, "Wrong alignment on UParticleModuleBuildingCollapse");
static_assert(sizeof(UParticleModuleBuildingCollapse) == 0x000030, "Wrong size on UParticleModuleBuildingCollapse");

// Class BrickRigs.BrickPattern
// 0x0028 (0x0050 - 0x0028)
class UBrickPattern : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tiling;                                            // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPattern">();
	}
	static class UBrickPattern* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickPattern>();
	}
};
static_assert(alignof(UBrickPattern) == 0x000008, "Wrong alignment on UBrickPattern");
static_assert(sizeof(UBrickPattern) == 0x000050, "Wrong size on UBrickPattern");
static_assert(offsetof(UBrickPattern, Color) == 0x000030, "Member 'UBrickPattern::Color' has a wrong offset!");
static_assert(offsetof(UBrickPattern, Texture) == 0x000040, "Member 'UBrickPattern::Texture' has a wrong offset!");
static_assert(offsetof(UBrickPattern, Tiling) == 0x000048, "Member 'UBrickPattern::Tiling' has a wrong offset!");

// Class BrickRigs.ConnectorSpacingPropertyWidget
// 0x0000 (0x0280 - 0x0280)
class UConnectorSpacingPropertyWidget : public UPropertyWidget
{
public:
	void SetConnectorSpacing(const struct FScalableBrickConnectorSpacing& NewSpacing);
	void UpdateConnectorSpacing(const struct FScalableBrickConnectorSpacing& NewSpacing, const uint8 AxisFlags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectorSpacingPropertyWidget">();
	}
	static class UConnectorSpacingPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConnectorSpacingPropertyWidget>();
	}
};
static_assert(alignof(UConnectorSpacingPropertyWidget) == 0x000008, "Wrong alignment on UConnectorSpacingPropertyWidget");
static_assert(sizeof(UConnectorSpacingPropertyWidget) == 0x000280, "Wrong size on UConnectorSpacingPropertyWidget");

// Class BrickRigs.BrickPawnInterface
// 0x0000 (0x0000 - 0x0000)
class IBrickPawnInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPawnInterface">();
	}
	static class IBrickPawnInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBrickPawnInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBrickPawnInterface) == 0x000001, "Wrong alignment on IBrickPawnInterface");
static_assert(sizeof(IBrickPawnInterface) == 0x000001, "Wrong size on IBrickPawnInterface");

// Class BrickRigs.BrickPhysicalMaterial
// 0x0010 (0x0090 - 0x0080)
class UBrickPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         Strength;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hardness;                                          // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Flammability;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPhysicalMaterial">();
	}
	static class UBrickPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickPhysicalMaterial>();
	}
};
static_assert(alignof(UBrickPhysicalMaterial) == 0x000008, "Wrong alignment on UBrickPhysicalMaterial");
static_assert(sizeof(UBrickPhysicalMaterial) == 0x000090, "Wrong size on UBrickPhysicalMaterial");
static_assert(offsetof(UBrickPhysicalMaterial, Strength) == 0x000080, "Member 'UBrickPhysicalMaterial::Strength' has a wrong offset!");
static_assert(offsetof(UBrickPhysicalMaterial, Hardness) == 0x000084, "Member 'UBrickPhysicalMaterial::Hardness' has a wrong offset!");
static_assert(offsetof(UBrickPhysicalMaterial, Flammability) == 0x000088, "Member 'UBrickPhysicalMaterial::Flammability' has a wrong offset!");

// Class BrickRigs.ContextMenuWidget
// 0x0038 (0x02A0 - 0x0268)
class UContextMenuWidget : public UMenuAnchorWidget
{
public:
	uint8                                         Pad_268[0x30];                                     // 0x0268(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputActionListWidget*                 ActionListWidget;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActionTriggered(const class FName& ActionName, bool bReleased);
	void UpdateTitleText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextMenuWidget">();
	}
	static class UContextMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextMenuWidget>();
	}
};
static_assert(alignof(UContextMenuWidget) == 0x000008, "Wrong alignment on UContextMenuWidget");
static_assert(sizeof(UContextMenuWidget) == 0x0002A0, "Wrong size on UContextMenuWidget");
static_assert(offsetof(UContextMenuWidget, ActionListWidget) == 0x000298, "Member 'UContextMenuWidget::ActionListWidget' has a wrong offset!");

// Class BrickRigs.BrickPlayerController
// 0x0418 (0x0A10 - 0x05F8)
class ABrickPlayerController final : public ABasePlayerController
{
public:
	uint8                                         Pad_5F8[0x50];                                     // 0x05F8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundMix*                              AtmosphereSoundMix;                                // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_650[0x70];                                     // 0x0650(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseCharacter*                         PlayerCharacter;                                   // 0x06C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseCharacter*                         SpectatedCharacter;                                // 0x06C8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseCharacter*                         ViewedCharacter;                                   // 0x06D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickVehicle*                          PlayerVehicle;                                     // 0x06D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickVehicle*                          ViewedVehicle;                                     // 0x06E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryComponent*                    AccessedInventory;                                 // 0x06F0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInventory                             ReplicatedInventory;                               // 0x06F8(0x0120)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_818[0x18];                                     // 0x0818(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickEditor*                           BrickEditor;                                       // 0x0830(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 EditorEntryPoint;                                  // 0x0838(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_840[0x10];                                     // 0x0840(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreezeTime;                                        // 0x0850(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_854[0x4];                                      // 0x0854(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        HurtAudioComponent;                                // 0x0858(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_860[0x1B0];                                    // 0x0860(0x01B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AccessInventory(class UInventoryComponent* InAccessedInventory);
	void AdjustSlomoSpeed(int32 Dir);
	void AdminSay(const class FText& Message);
	bool CanCheat();
	EPlayerSpawnResult CanRestartAt(struct FPlayerSpawnRequest* InOutSpawnRequest, bool bForceRestart);
	void ClientDamagedCharacter(const struct FClientDamageInfo& DamageInfo);
	void ClientOnFailedToRestart(EPlayerSpawnResult SpawnResult, const struct FVehicleSpawnProperties& Props);
	void ClientReceiveChatMessage(const struct FBrickChatMessage& ChatMessage);
	void ClientReceiveChatMessages(const TArray<struct FBrickChatMessage>& ChatMessages);
	void ClientRevertVehicleDamage(class ABrickVehicle* Vehicle, const struct FRestartTransformVersion& ComparisonIndex);
	void ClientSentWrongAdminPassword(uint8 AttemptsRemaining);
	void ClientWasKickedForDuration(const class FString& KickReason, const struct FTimespan& KickDuration);
	void CloseInventory();
	void CloseMap();
	void CloseScoreboard();
	void CloseVehicleBrowser();
	void DestroyAllDummies();
	void DestroyCharacter(class ABaseCharacter* Char);
	bool EnterEditor(EUGCType InUGCType, const struct FUGCFileInfo& InFileInfo, bool bImport, class AActor* EntryPoint);
	bool EnterFreeCam();
	void EnterVehicleEditor(class AActor* EntryPoint);
	void ExitEditor(const struct FUGCFileInfo& InFileInfo);
	void ExitFreeCam();
	void ExplodeVehicle();
	void JoinTeam(const struct FGenericTeamId& InTeamId);
	void KillCharacter();
	void OnRep_AccessedInventory(class UInventoryComponent* OldInventory);
	void OnRep_PlayerCharacter(class ABaseCharacter* OldCharacter);
	void OnRep_ReplicatedInventory();
	void OnRep_SpectatedCharacter();
	void OpenChat();
	void OpenInventory();
	void OpenMap(bool bToggleOpen);
	void OpenScoreboard(bool bToggleOpen);
	void OpenVehicleBrowser(class AActor* EntryPoint);
	void PossessCharacter(class ABaseCharacter* Char);
	void RecoverAllDummies();
	void RequestAdminAccess(const class FString& PW);
	void ResetLevel();
	EPlayerSpawnResult RestartAt(const struct FPlayerSpawnRequest& SpawnRequest);
	void RestartAtNextSpawnPoint();
	void RestartMatch();
	void RestartOnSpot();
	void Say(const class FText& Message);
	void ScrapAllVehicles(bool bIncludeUsed);
	void ScrapVehicle(class ABrickVehicle* InVehicle, bool bInPerson);
	void SendChatMessage(EChatContext Context, const class FText& Message);
	void ServerAccessInventory(class UInventoryComponent* InInventory);
	void ServerApplyMatchSettings(bool bFade);
	void ServerAttachWinchBrick(class UWinchBrick* WinchBrick, const struct FWinchAttachTarget& AttachTarget);
	void ServerCheatMoney(float Amount);
	void ServerCheatScore(float Amount);
	void ServerCycleCharacters(bool bForward);
	void ServerCycleVehicles(bool bReverse);
	void ServerDestroyAllDummies();
	void ServerDestroyCharacter(class ABaseCharacter* Char);
	void ServerEngageCouplingBrick(class UCouplingBrick* CouplingBrick, bool bEngage);
	void ServerExplodeVehicle();
	void ServerJoinTeam(const struct FGenericTeamId& InTeamId);
	void ServerKillCharacter();
	void ServerOnAnyVehicleConstructed(class ABrickVehicle* InVehicle);
	void ServerOnMeleeHit(const struct FRepHitInfo& HitInfo);
	void ServerOnPlayerChangedMatchSettings(const struct FMatchSettings& NewSettings, bool bApply, bool bFade);
	void ServerOnProjectileHit(const struct FProjectileHitInfo& HitInfo);
	void ServerOpenGravelSilo(class AGravelSilo* Silo, bool bOpen);
	void ServerPossessCharacter(class ABaseCharacter* Char);
	void ServerRecoverAllDummies();
	void ServerRequestAdminAccess(const class FString& PW);
	void ServerResetLevel();
	void ServerRestartAt(const struct FPlayerSpawnRequest& SpawnRequest);
	void ServerRestartMatch();
	void ServerScrapAllVehicles(bool bIncludeUsed);
	void ServerScrapVehicle(class ABrickVehicle* InVehicle, bool bInPerson);
	void ServerSendChatMessage(EChatContext Context, const class FText& Message);
	void ServerSetElevatorDirection(class AElevator* Elevator, EElevatorDirection Dir);
	void ServerSetSwitchBrickValue(class USwitchBrick* SwitchBrick, int8 NewValue);
	void ServerSetVehiclePinMode(EVehiclePinMode PinMode);
	void ServerSpawnDummy(const struct FVector& Location, uint16 CompressedYaw);
	void ServerSpectateNextCharacter(bool bForward);
	void ServerStartDragRace(class ADragStrip* DragStrip);
	void ServerToggleInvincible(bool bVehicle);
	void ServerTriggerDetonatorBrick(class UDetonatorBrick* DetonatorBrick);
	void ServerUpdateActuator(const struct FRepActuatorState& NewState, const struct FRestartTransformVersion& RestartVersion);
	void ServerUpdateVehicleMovement(class ABrickVehicle* Vehicle, const TArray<struct FRepBrickMovementState>& MovementSates, const float OwnerTimestamp, const struct FRestartTransformVersion& ComparisonIndex);
	void ServerUpdateVehicleMovementAndDamage(class ABrickVehicle* Vehicle, const TArray<struct FRepBrickMovementState>& MovementSates, const float OwnerTimestamp, const struct FBrickConnectionDamageBitfield& ConnectionDamage, const struct FRestartTransformVersion& ComparisonIndex);
	void SetFixedCam(bool bNewFixedCam);
	void SetFreeCamMode(EFreeCamMode NewMode);
	void SetPlayerCharacter(class ABaseCharacter* InCharacter);
	void SetSpectatedCharacter(class ABaseCharacter* InCharacter);
	void SetVehiclePinMode(EVehiclePinMode PinMode);
	void ShowHUDWidget(const TSoftClassPtr<class UClass>& HUDWidgetClass);
	void SpawnDummy(const struct FVector& Location, float Yaw);
	bool SpectateNextCharacter(bool bForward);
	void ToggleInvincible(bool bVehicle);
	void ToggleSlowMotion();

	bool CanAccessInventory(class UInventoryComponent* InInventory) const;
	bool CanDestroyAllDummies() const;
	bool CanDestroyCharacter(class ABaseCharacter* Char) const;
	bool CanEnterEditor(EUGCType InUGCType, class AActor* EntryPoint) const;
	bool CanEverBeAdmin() const;
	bool CanExplodeVehicle() const;
	bool CanInteract() const;
	bool CanJoinTeam(const struct FGenericTeamId& InTeamId) const;
	bool CanOpenVehicleBrowser(class AActor* EntryPoint) const;
	bool CanPinVehicle() const;
	bool CanPossessCharacter(class ABaseCharacter* Char) const;
	bool CanRecoverAllDummies() const;
	bool CanRestartOnSpot() const;
	bool CanRestartVehicle() const;
	bool CanScrapAllVehicles() const;
	bool CanScrapVehicle(class ABrickVehicle* InVehicle, bool bInPerson) const;
	bool CanSpawnAnywhere() const;
	bool CanSpawnDummy(bool bAtAll) const;
	EPlayerSpawnResult CanSpawnVehicle(const struct FUGCFileInfo& FileInfo, bool bRemoveCurrent) const;
	bool CanSpectateCharacter(class ABaseCharacter* InCharacter) const;
	bool CanTeleportPlayer() const;
	bool CanToggleInvincible() const;
	bool CanUseFreeCam() const;
	bool CanUseSlowMotion() const;
	bool CanViewInventory() const;
	class UHUDIconComponent* FindFocusedHUDIconComponent() const;
	class UInventoryComponent* GetAccessedInventory() const;
	class ABrickEditor* GetBrickEditor() const;
	class AActor* GetEditorEntryPoint() const;
	EFreeCamMode GetFreeCamMode() const;
	class ABaseCharacter* GetPlayerCharacter() const;
	class ABrickVehicle* GetPlayerVehicle() const;
	float GetRespawnTimerRemaining() const;
	class ABaseCharacter* GetSpectatedCharacter() const;
	class ABaseCharacter* GetViewedCharacter() const;
	class ABrickVehicle* GetViewedVehicle() const;
	bool IsAdminByDefault() const;
	bool IsFreeCamFixed() const;
	bool IsInEditor(EUGCType InUGCType) const;
	bool IsInFreeCam() const;
	bool IsInventoryOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPlayerController">();
	}
	static class ABrickPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickPlayerController>();
	}
};
static_assert(alignof(ABrickPlayerController) == 0x000008, "Wrong alignment on ABrickPlayerController");
static_assert(sizeof(ABrickPlayerController) == 0x000A10, "Wrong size on ABrickPlayerController");
static_assert(offsetof(ABrickPlayerController, AtmosphereSoundMix) == 0x000648, "Member 'ABrickPlayerController::AtmosphereSoundMix' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, PlayerCharacter) == 0x0006C0, "Member 'ABrickPlayerController::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, SpectatedCharacter) == 0x0006C8, "Member 'ABrickPlayerController::SpectatedCharacter' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, ViewedCharacter) == 0x0006D0, "Member 'ABrickPlayerController::ViewedCharacter' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, PlayerVehicle) == 0x0006D8, "Member 'ABrickPlayerController::PlayerVehicle' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, ViewedVehicle) == 0x0006E0, "Member 'ABrickPlayerController::ViewedVehicle' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, AccessedInventory) == 0x0006F0, "Member 'ABrickPlayerController::AccessedInventory' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, ReplicatedInventory) == 0x0006F8, "Member 'ABrickPlayerController::ReplicatedInventory' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, BrickEditor) == 0x000830, "Member 'ABrickPlayerController::BrickEditor' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, EditorEntryPoint) == 0x000838, "Member 'ABrickPlayerController::EditorEntryPoint' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, FreezeTime) == 0x000850, "Member 'ABrickPlayerController::FreezeTime' has a wrong offset!");
static_assert(offsetof(ABrickPlayerController, HurtAudioComponent) == 0x000858, "Member 'ABrickPlayerController::HurtAudioComponent' has a wrong offset!");

// Class BrickRigs.Elevator
// 0x0088 (0x02A8 - 0x0220)
class AElevator : public AActor
{
public:
	uint8                                         Pad_220[0xC];                                      // 0x0220(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FElevatorState                         RepElevatorState;                                  // 0x022C(0x000C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x38];                                     // 0x0238(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ElevatorMesh;                                      // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AudioComponent;                                    // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  BaseIC;                                            // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  TopIC;                                             // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  PlatformIC;                                        // 0x0290(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxHeight;                                         // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Acceleration;                                      // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_ElevatorDown(class ABrickPlayerController* PC);
	void Interact_ElevatorUp(class ABrickPlayerController* PC);
	void Interact_StopElevator(class ABrickPlayerController* PC);
	void OnElevatorStateChanged(const struct FElevatorState& NewState);
	void OnRep_RepElevatorState();
	void SetElevatorDirection(const EElevatorDirection Dir);
	void SetElevatorState(const struct FElevatorState& NewState);

	struct FVector GetInteractionLocation(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Elevator">();
	}
	static class AElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElevator>();
	}
};
static_assert(alignof(AElevator) == 0x000008, "Wrong alignment on AElevator");
static_assert(sizeof(AElevator) == 0x0002A8, "Wrong size on AElevator");
static_assert(offsetof(AElevator, RepElevatorState) == 0x00022C, "Member 'AElevator::RepElevatorState' has a wrong offset!");
static_assert(offsetof(AElevator, ElevatorMesh) == 0x000270, "Member 'AElevator::ElevatorMesh' has a wrong offset!");
static_assert(offsetof(AElevator, AudioComponent) == 0x000278, "Member 'AElevator::AudioComponent' has a wrong offset!");
static_assert(offsetof(AElevator, BaseIC) == 0x000280, "Member 'AElevator::BaseIC' has a wrong offset!");
static_assert(offsetof(AElevator, TopIC) == 0x000288, "Member 'AElevator::TopIC' has a wrong offset!");
static_assert(offsetof(AElevator, PlatformIC) == 0x000290, "Member 'AElevator::PlatformIC' has a wrong offset!");
static_assert(offsetof(AElevator, MaxHeight) == 0x000298, "Member 'AElevator::MaxHeight' has a wrong offset!");
static_assert(offsetof(AElevator, MaxSpeed) == 0x00029C, "Member 'AElevator::MaxSpeed' has a wrong offset!");
static_assert(offsetof(AElevator, Acceleration) == 0x0002A0, "Member 'AElevator::Acceleration' has a wrong offset!");

// Class BrickRigs.BrickPlayerInput
// 0x00C8 (0x0470 - 0x03A8)
class UBrickPlayerInput final : public UPlayerInput
{
public:
	uint8                                         Pad_3A8[0x58];                                     // 0x03A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputComponent*>                LastInputStack;                                    // 0x0400(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x50];                                     // 0x0410(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EInputMethod NewInputMethod)> OnInputMethodChangedDelegate;        // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPlayerInput">();
	}
	static class UBrickPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickPlayerInput>();
	}
};
static_assert(alignof(UBrickPlayerInput) == 0x000008, "Wrong alignment on UBrickPlayerInput");
static_assert(sizeof(UBrickPlayerInput) == 0x000470, "Wrong size on UBrickPlayerInput");
static_assert(offsetof(UBrickPlayerInput, LastInputStack) == 0x000400, "Member 'UBrickPlayerInput::LastInputStack' has a wrong offset!");
static_assert(offsetof(UBrickPlayerInput, OnInputMethodChangedDelegate) == 0x000460, "Member 'UBrickPlayerInput::OnInputMethodChangedDelegate' has a wrong offset!");

// Class BrickRigs.BrickPlayerStart
// 0x0028 (0x0248 - 0x0220)
class ABrickPlayerStart final : public AActor
{
public:
	TSoftObjectPtr<class ASpawnArea>              SpawnArea;                                         // 0x0220(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPlayerStart">();
	}
	static class ABrickPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickPlayerStart>();
	}
};
static_assert(alignof(ABrickPlayerStart) == 0x000008, "Wrong alignment on ABrickPlayerStart");
static_assert(sizeof(ABrickPlayerStart) == 0x000248, "Wrong size on ABrickPlayerStart");
static_assert(offsetof(ABrickPlayerStart, SpawnArea) == 0x000220, "Member 'ABrickPlayerStart::SpawnArea' has a wrong offset!");

// Class BrickRigs.ZombieAnimInstance
// 0x0840 (0x0B00 - 0x02C0)
class UZombieAnimInstance : public UCharacterAnimInstance
{
public:
	struct FZombieAnimInstanceProxy               Proxy;                                             // 0x02C0(0x0840)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAnimInstance">();
	}
	static class UZombieAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAnimInstance>();
	}
};
static_assert(alignof(UZombieAnimInstance) == 0x000010, "Wrong alignment on UZombieAnimInstance");
static_assert(sizeof(UZombieAnimInstance) == 0x000B00, "Wrong size on UZombieAnimInstance");
static_assert(offsetof(UZombieAnimInstance, Proxy) == 0x0002C0, "Member 'UZombieAnimInstance::Proxy' has a wrong offset!");

// Class BrickRigs.BrickProjectile
// 0x0140 (0x03F0 - 0x02B0)
class ABrickProjectile : public AFluMoveSyncKinematicActor
{
public:
	uint8                                         Pad_2B0[0x48];                                     // 0x02B0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UFirearmComponent>       FirearmComponent;                                  // 0x02F8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x1C];                                     // 0x0300(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	EAmmoType                                     AmmoType;                                          // 0x031C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31D[0x1];                                      // 0x031D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        NumMergedProjectiles;                              // 0x031E(0x0002)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 SeekingTarget;                                     // 0x0320(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x28];                                     // 0x0328(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComponent;                                   // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickProjectileMovementComponent*      ProjectileMovementComponent;                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CollisionProfileName;                              // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            StaticMesh;                                        // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TrailParticleSystem;                               // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DesintegrationParticleSystem;                      // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PenetrationCoefficient;                            // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAcceleration;                                // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHomingDistance;                                 // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHomingAngle;                                    // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHomingLeadDistance;                             // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlareEffectiveness;                                // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravityScale;                                      // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FlybySound;                                        // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlybySoundDelay;                                   // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlybySoundPitch;                                   // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetZoomParams                  ZoomParams;                                        // 0x03B8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UExplosiveMaterial>         ExplosiveMaterial;                                 // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UExplosiveMaterial>         IncendiaryMaterial;                                // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveVolume;                                   // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionDamage;                                   // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_SeekingTarget(class AActor* OldTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickProjectile">();
	}
	static class ABrickProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickProjectile>();
	}
};
static_assert(alignof(ABrickProjectile) == 0x000010, "Wrong alignment on ABrickProjectile");
static_assert(sizeof(ABrickProjectile) == 0x0003F0, "Wrong size on ABrickProjectile");
static_assert(offsetof(ABrickProjectile, FirearmComponent) == 0x0002F8, "Member 'ABrickProjectile::FirearmComponent' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, AmmoType) == 0x00031C, "Member 'ABrickProjectile::AmmoType' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, NumMergedProjectiles) == 0x00031E, "Member 'ABrickProjectile::NumMergedProjectiles' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, SeekingTarget) == 0x000320, "Member 'ABrickProjectile::SeekingTarget' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, SphereComponent) == 0x000350, "Member 'ABrickProjectile::SphereComponent' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, StaticMeshComponent) == 0x000358, "Member 'ABrickProjectile::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, ProjectileMovementComponent) == 0x000360, "Member 'ABrickProjectile::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, CollisionProfileName) == 0x000368, "Member 'ABrickProjectile::CollisionProfileName' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, StaticMesh) == 0x000370, "Member 'ABrickProjectile::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, TrailParticleSystem) == 0x000378, "Member 'ABrickProjectile::TrailParticleSystem' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, DesintegrationParticleSystem) == 0x000380, "Member 'ABrickProjectile::DesintegrationParticleSystem' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, MeshScale) == 0x000388, "Member 'ABrickProjectile::MeshScale' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, PenetrationCoefficient) == 0x00038C, "Member 'ABrickProjectile::PenetrationCoefficient' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, HomingAcceleration) == 0x000390, "Member 'ABrickProjectile::HomingAcceleration' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, MaxHomingDistance) == 0x000394, "Member 'ABrickProjectile::MaxHomingDistance' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, MaxHomingAngle) == 0x000398, "Member 'ABrickProjectile::MaxHomingAngle' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, MaxHomingLeadDistance) == 0x00039C, "Member 'ABrickProjectile::MaxHomingLeadDistance' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, FlareEffectiveness) == 0x0003A0, "Member 'ABrickProjectile::FlareEffectiveness' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, GravityScale) == 0x0003A4, "Member 'ABrickProjectile::GravityScale' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, FlybySound) == 0x0003A8, "Member 'ABrickProjectile::FlybySound' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, FlybySoundDelay) == 0x0003B0, "Member 'ABrickProjectile::FlybySoundDelay' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, FlybySoundPitch) == 0x0003B4, "Member 'ABrickProjectile::FlybySoundPitch' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, ZoomParams) == 0x0003B8, "Member 'ABrickProjectile::ZoomParams' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, DamageType) == 0x0003D0, "Member 'ABrickProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, ExplosiveMaterial) == 0x0003D8, "Member 'ABrickProjectile::ExplosiveMaterial' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, IncendiaryMaterial) == 0x0003E0, "Member 'ABrickProjectile::IncendiaryMaterial' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, ExplosiveVolume) == 0x0003E8, "Member 'ABrickProjectile::ExplosiveVolume' has a wrong offset!");
static_assert(offsetof(ABrickProjectile, ExplosionDamage) == 0x0003EC, "Member 'ABrickProjectile::ExplosionDamage' has a wrong offset!");

// Class BrickRigs.WindowManagerWidget
// 0x0150 (0x03C0 - 0x0270)
class UWindowManagerWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMainWidgetBase*                        ActiveWidget;                                      // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x30];                                     // 0x0288(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPopupContainerWidget*>          PopupContainerWidgets;                             // 0x02B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMenuAnchorWidget*                      MenuAnchorWidget;                                  // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UTooltipWidget*                         CurrentTooltipWidget;                              // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x20];                                     // 0x0300(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           MainCanvasPanel;                                   // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   IntroSequenceWidgetClass;                          // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MenuWidgetClass;                                   // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   HUDContainerWidgetClass;                           // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupContainerWidget>      PopupContainerClass;                               // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UContextMenuWidget>         ContextMenuWidgetClass;                            // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTooltipWidget>             TooltipWidgetClass;                                // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooltipOffset;                                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TooltipDelay;                                      // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UWindowManagerWidget* Get(const class UObject* WorldContextObject);

	void AddActiveWidget(class UMainWidgetBase* Widget);
	void OnIntroSequenceFinished();
	void SetMenuOpen(bool bOpen);

	bool CanOpenOrCloseMenu(bool bOpen) const;
	bool IsMenuOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowManagerWidget">();
	}
	static class UWindowManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowManagerWidget>();
	}
};
static_assert(alignof(UWindowManagerWidget) == 0x000008, "Wrong alignment on UWindowManagerWidget");
static_assert(sizeof(UWindowManagerWidget) == 0x0003C0, "Wrong size on UWindowManagerWidget");
static_assert(offsetof(UWindowManagerWidget, ActiveWidget) == 0x000280, "Member 'UWindowManagerWidget::ActiveWidget' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, PopupContainerWidgets) == 0x0002B8, "Member 'UWindowManagerWidget::PopupContainerWidgets' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, MenuAnchorWidget) == 0x0002D0, "Member 'UWindowManagerWidget::MenuAnchorWidget' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, CurrentTooltipWidget) == 0x0002F8, "Member 'UWindowManagerWidget::CurrentTooltipWidget' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, MainCanvasPanel) == 0x000320, "Member 'UWindowManagerWidget::MainCanvasPanel' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, IntroSequenceWidgetClass) == 0x000328, "Member 'UWindowManagerWidget::IntroSequenceWidgetClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, MenuWidgetClass) == 0x000350, "Member 'UWindowManagerWidget::MenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, HUDContainerWidgetClass) == 0x000378, "Member 'UWindowManagerWidget::HUDContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, PopupContainerClass) == 0x0003A0, "Member 'UWindowManagerWidget::PopupContainerClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, ContextMenuWidgetClass) == 0x0003A8, "Member 'UWindowManagerWidget::ContextMenuWidgetClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, TooltipWidgetClass) == 0x0003B0, "Member 'UWindowManagerWidget::TooltipWidgetClass' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, TooltipOffset) == 0x0003B8, "Member 'UWindowManagerWidget::TooltipOffset' has a wrong offset!");
static_assert(offsetof(UWindowManagerWidget, TooltipDelay) == 0x0003BC, "Member 'UWindowManagerWidget::TooltipDelay' has a wrong offset!");

// Class BrickRigs.BrickProjectileMovementComponent
// 0x0020 (0x01F0 - 0x01D0)
class UBrickProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_1D0[0x20];                                     // 0x01D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickProjectileMovementComponent">();
	}
	static class UBrickProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickProjectileMovementComponent>();
	}
};
static_assert(alignof(UBrickProjectileMovementComponent) == 0x000010, "Wrong alignment on UBrickProjectileMovementComponent");
static_assert(sizeof(UBrickProjectileMovementComponent) == 0x0001F0, "Wrong size on UBrickProjectileMovementComponent");

// Class BrickRigs.ProjectileInputComponent
// 0x0000 (0x0170 - 0x0170)
class UProjectileInputComponent final : public UBaseInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileInputComponent">();
	}
	static class UProjectileInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileInputComponent>();
	}
};
static_assert(alignof(UProjectileInputComponent) == 0x000008, "Wrong alignment on UProjectileInputComponent");
static_assert(sizeof(UProjectileInputComponent) == 0x000170, "Wrong size on UProjectileInputComponent");

// Class BrickRigs.BrickPropertyInterface
// 0x0000 (0x0000 - 0x0000)
class IBrickPropertyInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPropertyInterface">();
	}
	static class IBrickPropertyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBrickPropertyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBrickPropertyInterface) == 0x000001, "Wrong alignment on IBrickPropertyInterface");
static_assert(sizeof(IBrickPropertyInterface) == 0x000001, "Wrong size on IBrickPropertyInterface");

// Class BrickRigs.BrickRichTextBlock
// 0x0000 (0x0678 - 0x0678)
class UBrickRichTextBlock final : public URichTextBlock
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickRichTextBlock">();
	}
	static class UBrickRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickRichTextBlock>();
	}
};
static_assert(alignof(UBrickRichTextBlock) == 0x000008, "Wrong alignment on UBrickRichTextBlock");
static_assert(sizeof(UBrickRichTextBlock) == 0x000678, "Wrong size on UBrickRichTextBlock");

// Class BrickRigs.BrickScrollBox
// 0x0010 (0x0898 - 0x0888)
class UBrickScrollBox final : public UScrollBox
{
public:
	uint8                                         Pad_888[0x8];                                      // 0x0888(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUISpacingStyle                          SlotSpacingStyle;                                  // 0x0890(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_891[0x7];                                      // 0x0891(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSlotSpacingStyle(EBrickUISpacingStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickScrollBox">();
	}
	static class UBrickScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickScrollBox>();
	}
};
static_assert(alignof(UBrickScrollBox) == 0x000008, "Wrong alignment on UBrickScrollBox");
static_assert(sizeof(UBrickScrollBox) == 0x000898, "Wrong size on UBrickScrollBox");
static_assert(offsetof(UBrickScrollBox, SlotSpacingStyle) == 0x000890, "Member 'UBrickScrollBox::SlotSpacingStyle' has a wrong offset!");

// Class BrickRigs.BrickSliderWidget
// 0x0080 (0x0300 - 0x0280)
class UBrickSliderWidget : public UButtonWidgetBase
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBoxWidget*                    TextBox;                                           // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickBorder*                           FillBorder;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Value;                                             // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinValue;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxValue;                                          // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValueStep;                                         // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickSliderGridSnapMode                      GridSnapMode;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ENumericValueType                             ValueType;                                         // 0x02B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxFractionalDigits;                               // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   CustomTextFormat;                                  // 0x02B8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsReadOnly;                                       // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMarquee;                                        // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float Value, EValueChangedEventType EventType)> OnValueChangedDelegate; // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTextChanged(const class FText& NewText, EValueChangedEventType EventType);
	void SetCustomTextFormat(const class FText& InFormat);
	void SetGridSnapMode(const EBrickSliderGridSnapMode NewMode);
	void SetIsMarquee(bool bInMarquee);
	void SetIsReadOnly(bool bInReadOnly);
	void SetMaxFractionalDigits(int32 InMaxDigits);
	void SetValue(float NewValue);
	void SetValueRange(float InMinValue, float InMaxValue);
	void SetValueType(ENumericValueType InType);
	void UpdateIsDragging(const bool bIsDragging);
	void UpdateSliderPosition(float NewValue);

	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSliderWidget">();
	}
	static class UBrickSliderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSliderWidget>();
	}
};
static_assert(alignof(UBrickSliderWidget) == 0x000008, "Wrong alignment on UBrickSliderWidget");
static_assert(sizeof(UBrickSliderWidget) == 0x000300, "Wrong size on UBrickSliderWidget");
static_assert(offsetof(UBrickSliderWidget, TextBox) == 0x000290, "Member 'UBrickSliderWidget::TextBox' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, FillBorder) == 0x000298, "Member 'UBrickSliderWidget::FillBorder' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, Value) == 0x0002A0, "Member 'UBrickSliderWidget::Value' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, MinValue) == 0x0002A4, "Member 'UBrickSliderWidget::MinValue' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, MaxValue) == 0x0002A8, "Member 'UBrickSliderWidget::MaxValue' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, ValueStep) == 0x0002AC, "Member 'UBrickSliderWidget::ValueStep' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, GridSnapMode) == 0x0002B0, "Member 'UBrickSliderWidget::GridSnapMode' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, ValueType) == 0x0002B1, "Member 'UBrickSliderWidget::ValueType' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, MaxFractionalDigits) == 0x0002B4, "Member 'UBrickSliderWidget::MaxFractionalDigits' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, CustomTextFormat) == 0x0002B8, "Member 'UBrickSliderWidget::CustomTextFormat' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, bIsReadOnly) == 0x0002D0, "Member 'UBrickSliderWidget::bIsReadOnly' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, bIsMarquee) == 0x0002D1, "Member 'UBrickSliderWidget::bIsMarquee' has a wrong offset!");
static_assert(offsetof(UBrickSliderWidget, OnValueChangedDelegate) == 0x0002D8, "Member 'UBrickSliderWidget::OnValueChangedDelegate' has a wrong offset!");

// Class BrickRigs.BrickSpectatorPawn
// 0x0288 (0x0530 - 0x02A8)
class alignas(0x10) ABrickSpectatorPawn : public ASpectatorPawn
{
public:
	uint8                                         Pad_2A8[0x1A0];                                    // 0x02A8(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 FollowTarget;                                      // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x58];                                     // 0x0450(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               Mid;                                               // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   PlacementBoundsMeshComponent;                      // 0x04B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            PlacementBoundsMesh;                               // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PlacementBoundsDefaultSize;                        // 0x04C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MinPlacementBoundsSize;                            // 0x04D4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlacementBoundsSizeInterpSpeed;                    // 0x04E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlacementBoundsScreenFitInflation;                 // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlacementSweepRadius;                              // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PawnRotationSpeed;                                 // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FViewTargetCameraSpeedParams           CameraSpeedParams;                                 // 0x04F0(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FViewTargetZoomParams                  ZoomParams;                                        // 0x0508(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ShiftInterpSpeed;                                  // 0x0520(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_524[0xC];                                      // 0x0524(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSpectatorPawn">();
	}
	static class ABrickSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickSpectatorPawn>();
	}
};
static_assert(alignof(ABrickSpectatorPawn) == 0x000010, "Wrong alignment on ABrickSpectatorPawn");
static_assert(sizeof(ABrickSpectatorPawn) == 0x000530, "Wrong size on ABrickSpectatorPawn");
static_assert(offsetof(ABrickSpectatorPawn, FollowTarget) == 0x000448, "Member 'ABrickSpectatorPawn::FollowTarget' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, Mid) == 0x0004A8, "Member 'ABrickSpectatorPawn::Mid' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementBoundsMeshComponent) == 0x0004B8, "Member 'ABrickSpectatorPawn::PlacementBoundsMeshComponent' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementBoundsMesh) == 0x0004C0, "Member 'ABrickSpectatorPawn::PlacementBoundsMesh' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementBoundsDefaultSize) == 0x0004C8, "Member 'ABrickSpectatorPawn::PlacementBoundsDefaultSize' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, MinPlacementBoundsSize) == 0x0004D4, "Member 'ABrickSpectatorPawn::MinPlacementBoundsSize' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementBoundsSizeInterpSpeed) == 0x0004E0, "Member 'ABrickSpectatorPawn::PlacementBoundsSizeInterpSpeed' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementBoundsScreenFitInflation) == 0x0004E4, "Member 'ABrickSpectatorPawn::PlacementBoundsScreenFitInflation' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PlacementSweepRadius) == 0x0004E8, "Member 'ABrickSpectatorPawn::PlacementSweepRadius' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, PawnRotationSpeed) == 0x0004EC, "Member 'ABrickSpectatorPawn::PawnRotationSpeed' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, CameraSpeedParams) == 0x0004F0, "Member 'ABrickSpectatorPawn::CameraSpeedParams' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, ZoomParams) == 0x000508, "Member 'ABrickSpectatorPawn::ZoomParams' has a wrong offset!");
static_assert(offsetof(ABrickSpectatorPawn, ShiftInterpSpeed) == 0x000520, "Member 'ABrickSpectatorPawn::ShiftInterpSpeed' has a wrong offset!");

// Class BrickRigs.BrickStatics
// 0x0000 (0x0028 - 0x0028)
class UBrickStatics final : public UBlueprintFunctionLibrary
{
public:
	static class FString ColorToHex(const struct FLinearColor& Color, const bool bIncludeAlpha);
	static struct FUniqueNetIdRepl CreateUniqueNetId(const class FName& OSSName, const class FString& Str);
	static bool ExtinguishActor(const struct FHitResult& Hit);
	static struct FUniqueNetIdRepl GetPlayerUniqueNetId(const class APlayerController* PC);
	static class FString GetProjectVersion();
	static EConnectorSpacing GetScalableBrickConnectorSpacingAxis(const struct FScalableBrickConnectorSpacing& ConnectorSpacing, const EFluAxisSigned Axis);
	static struct FLinearColor HexToColor(const class FString& Hex);
	static bool IsModdedAsset(const class UObject* Asset);
	static bool SetActorOnFire(const struct FHitResult& Hit, class APawn* Instigator, class AActor* DamageCauser);
	static void SetScalableBrickConnectorSpacingAxis(struct FScalableBrickConnectorSpacing& ConnectorSpacing, const EFluAxisSigned Axis, const EConnectorSpacing NewSpacing);
	static bool ShowPlayerProfileUI(const class APlayerController* OwnPC, const struct FUniqueNetIdRepl& PlayerId);
	static void SpawnExplosion(class UObject* WorldContextObject, TSubclassOf<class UExplosiveMaterial> ExplosiveMaterial, float Volume, const struct FVector& Location, const struct FRotator& Rotation, class APawn* Instigator, class AActor* DamageCauser, const TArray<class UPrimitiveComponent*>& ComponentsToIgnore);
	static bool SpreadFire(class UObject* WorldContextObject, const struct FTransform& Transform, const struct FVector& BoundsMin, const struct FVector& BoundsMax, float SpreadDistance, float SpreadProbability);
	static class FString UniqueNetIdToString(const struct FUniqueNetIdRepl& UniqueNetId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickStatics">();
	}
	static class UBrickStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickStatics>();
	}
};
static_assert(alignof(UBrickStatics) == 0x000008, "Wrong alignment on UBrickStatics");
static_assert(sizeof(UBrickStatics) == 0x000028, "Wrong size on UBrickStatics");

// Class BrickRigs.BrickTextBoxWidget
// 0x0048 (0x02A8 - 0x0260)
class UBrickTextBoxWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickMultiLineTextBox*                 MultiLineTextBox;                                  // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickButtonWidget*                     ShowPasswordButton;                                // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const class FText& NewText, EValueChangedEventType EventType)> OnTextChangedDelegate; // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         MaxTextLength;                                     // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultiLine;                                   // 0x02A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPassword;                                       // 0x02A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNumeric;                                        // 0x02A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A7[0x1];                                      // 0x02A7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTextChanged(const class FText& NewText);
	void SetAllowMultiLine(bool bInAllowMultiLine);
	void SetBrushStyle(EBrickUIBrushStyle InBrushStyle);
	void SetColorStyle(EBrickUIColorStyle InColorStyle);
	void SetCustomFocus(bool bNewUseCustomFocus, bool bNewFocused);
	void SetHintText(const class FText& InText);
	void SetIsMarquee(bool bNewMarquee);
	void SetIsPassword(bool bNewIsPassword);
	void SetIsReadOnly(bool bNewReadOnly);
	void SetJustification(ETextJustify NewJustification);
	void SetMaxTextLength(int32 InMaxLength);
	void SetPaddingStyle(EBrickUIPaddingStyle InPaddingStyle);
	void SetPasswordVisible(bool bNewVisible);
	void SetText(const class FText& InText, bool bValidateText);
	void SetTextStyle(EBrickUITextStyle InTextStyle);
	void StartTyping(bool bSelectAllText);
	void TogglePasswordVisible();
	void UpdateIsPassword(bool bNewIsPassword);
	void UpdatePasswordVisible(bool bNewVisible);

	class FText GetText() const;
	bool IsMarquee() const;
	bool IsPasswordVisible() const;
	bool IsReadOnly() const;
	bool IsTyping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTextBoxWidget">();
	}
	static class UBrickTextBoxWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTextBoxWidget>();
	}
};
static_assert(alignof(UBrickTextBoxWidget) == 0x000008, "Wrong alignment on UBrickTextBoxWidget");
static_assert(sizeof(UBrickTextBoxWidget) == 0x0002A8, "Wrong size on UBrickTextBoxWidget");
static_assert(offsetof(UBrickTextBoxWidget, MultiLineTextBox) == 0x000280, "Member 'UBrickTextBoxWidget::MultiLineTextBox' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, ShowPasswordButton) == 0x000288, "Member 'UBrickTextBoxWidget::ShowPasswordButton' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, OnTextChangedDelegate) == 0x000290, "Member 'UBrickTextBoxWidget::OnTextChangedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, MaxTextLength) == 0x0002A0, "Member 'UBrickTextBoxWidget::MaxTextLength' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, bAllowMultiLine) == 0x0002A4, "Member 'UBrickTextBoxWidget::bAllowMultiLine' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, bIsPassword) == 0x0002A5, "Member 'UBrickTextBoxWidget::bIsPassword' has a wrong offset!");
static_assert(offsetof(UBrickTextBoxWidget, bIsNumeric) == 0x0002A6, "Member 'UBrickTextBoxWidget::bIsNumeric' has a wrong offset!");

// Class BrickRigs.BrickUIStyle
// 0x5AB0 (0x5AD8 - 0x0028)
class UBrickUIStyle : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   StyleDisplayName;                                  // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateBrush                            ThrobberBrush;                                     // 0x0048(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ThrobberRotationSpeed;                             // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickUIIconAtlas                      IconAtlas[0x11];                                   // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBrickUIBrushStyle                     BrushStyles[0x8];                                  // 0x01E8(0x0770)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	struct FBrickUIColorStyle                     ColorStyles[0x8];                                  // 0x3D68(0x00E0)(Edit, DisableEditOnInstance, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	struct FTextBlockStyle                        TextStyles[0x9];                                   // 0x4468(0x0270)(Edit, DisableEditOnInstance, EditConst, NativeAccessSpecifierPublic)
	float                                         SpacingStyles[0x3];                                // 0x5A58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                PaddingStyles[0x7];                                // 0x5A64(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AD4[0x4];                                     // 0x5AD4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FText FormatRichTextStyle(EBrickUITextStyle Style, const class FText& InText);
	static EBrickUIColorStyle GetTeamAttitudeColorStyle(ETeamAttitude TeamAttitude);
	static EBrickUITextStyle GetTeamAttitudeTextStyle(ETeamAttitude TeamAttitude);
	static void GetUIStyle(TDelegate<void(const class UBrickUIStyle* Style)> Delegate);
	static EBrickUIColorStyle InvertTeamAttitudeColorStyle(EBrickUIColorStyle ColorStyle);
	static EBrickUIStyleState SwitchButtonStyleState(EBrickUIStyleState StyleState);
	static void UnbindUIStyle(class UObject* Object);

	void BuildStyle();
	void SetBrush(EBrickUIBrushStyle BrushStyle, EBrickUIStyleState StyleState, const struct FSlateBrush& InBrush);
	void SetColor(EBrickUIColorStyle ColorStyle, EBrickUIStyleState StyleState, const struct FLinearColor& InColor);
	void SetIconAtlas(EBrickUIIconAtlas InIconAtlas, const struct FBrickUIIconAtlas& InAtlas);
	void SetPaddingStyle(EBrickUIPaddingStyle PaddingStyle, const struct FMargin& InPadding);
	void SetSpacingStyle(EBrickUISpacingStyle SpacingStyle, float InSpacing);
	void SetTextStyle(EBrickUITextStyle TextStyle, const struct FTextBlockStyle& InTextStyle);

	const struct FSlateBrush GetBrush(EBrickUIBrushStyle BrushStyle, EBrickUIStyleState StyleState, const struct FSlateBrush& Fallback) const;
	const struct FLinearColor GetColor(EBrickUIColorStyle ColorStyle, EBrickUIStyleState StyleState, const struct FLinearColor& Fallback) const;
	struct FMargin GetPadding(EBrickUIPaddingStyle PaddingStyle, const struct FMargin& Fallback) const;
	float GetSpacing(EBrickUISpacingStyle SpacingStyle, float Fallback) const;
	const struct FTextBlockStyle GetTextStyle(EBrickUITextStyle TextStyle, const struct FTextBlockStyle& Fallback) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickUIStyle">();
	}
	static class UBrickUIStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickUIStyle>();
	}
};
static_assert(alignof(UBrickUIStyle) == 0x000008, "Wrong alignment on UBrickUIStyle");
static_assert(sizeof(UBrickUIStyle) == 0x005AD8, "Wrong size on UBrickUIStyle");
static_assert(offsetof(UBrickUIStyle, StyleDisplayName) == 0x000030, "Member 'UBrickUIStyle::StyleDisplayName' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, ThrobberBrush) == 0x000048, "Member 'UBrickUIStyle::ThrobberBrush' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, ThrobberRotationSpeed) == 0x0000D0, "Member 'UBrickUIStyle::ThrobberRotationSpeed' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, IconAtlas) == 0x0000D8, "Member 'UBrickUIStyle::IconAtlas' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, BrushStyles) == 0x0001E8, "Member 'UBrickUIStyle::BrushStyles' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, ColorStyles) == 0x003D68, "Member 'UBrickUIStyle::ColorStyles' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, TextStyles) == 0x004468, "Member 'UBrickUIStyle::TextStyles' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, SpacingStyles) == 0x005A58, "Member 'UBrickUIStyle::SpacingStyles' has a wrong offset!");
static_assert(offsetof(UBrickUIStyle, PaddingStyles) == 0x005A64, "Member 'UBrickUIStyle::PaddingStyles' has a wrong offset!");

// Class BrickRigs.BrickUserSettings
// 0x0320 (0x0348 - 0x0028)
class UBrickUserSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldKeyTime;                                       // 0x0030(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MouseTapTime;                                      // 0x0034(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ConfigVersion;                                     // 0x0038(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHostServerType                               HostServerType;                                    // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerPassword;                                    // 0x0050(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMatchSettings                         MatchSettings;                                     // 0x0060(0x00C8)(Config, NativeAccessSpecifierPrivate)
	bool                                          bAllowDifferentMods;                               // 0x0128(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyMatchSettings;                               // 0x0129(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeMatchSettings;                                // 0x012A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDVisibility                                hudvisibility;                                     // 0x012B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EMeasurementSystem                            MeasurementSystem;                                 // 0x012C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EChatContext                                  ChatContext;                                       // 0x012D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBrickUIStyle>              UIStyle;                                           // 0x0130(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FBrickPropertySettings> BrickPropertySettings;                          // 0x0138(0x0050)(Config, NativeAccessSpecifierPrivate)
	float                                         MasterVolume;                                      // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicVolume;                                       // 0x018C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FieldOfView;                                       // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECameraMode                                   CameraMode;                                        // 0x0194(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETransmissionMode                             TransmissionMode;                                  // 0x0195(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoCounterSteering;                              // 0x0196(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_197[0x1];                                      // 0x0197(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivity;                                  // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadSensitivity;                                // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertViewPitch;                                  // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleAim;                                        // 0x01A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleSprint;                                     // 0x01A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleCrouch;                                     // 0x01A3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputCategory*                         InputCategory;                                     // 0x01A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 InputMappingSearchText;                            // 0x01B0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAxis                                         EditorMirrorAxis;                                  // 0x01C0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBrickEditorViewMode                          EditorViewMode;                                    // 0x01C1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldSetupParams                      EditorWorldSetupParams;                            // 0x01C8(0x0030)(Config, NativeAccessSpecifierPrivate)
	float                                         EditorUIScale;                                     // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorMouseMoveSensitivity;                        // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorGridSnappingDistance;                        // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorGridSnappingAngle;                           // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorBrickSnappingDistance;                       // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorBrickSnappingAngle;                          // 0x020C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEditorSnappingEnabled;                            // 0x0210(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEditorGizmoWorldSpace;                            // 0x0211(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBrickUnitsDisplayMode                        BrickUnitsDisplayMode;                             // 0x0212(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EColorDisplayMode                             ColorDisplayMode;                                  // 0x0213(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorZoomRatio;                                   // 0x0214(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditorCameraSpeedRatio;                            // 0x0218(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeCamSpeedRatio;                                 // 0x021C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeCamShiftSpeedRatio;                            // 0x0220(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProjectileCamZoomRatio;                            // 0x0224(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x18];                                     // 0x0228(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EHUDVisibility NewVisibility)> OnHUDVisibilityChangedDelegate;     // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EMeasurementSystem NewVisibility)> OnMeasurementSystemChangedDelegate; // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0xD8];                                     // 0x0260(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const EColorDisplayMode NewDisplayMode)> OnColorDisplayModeChanged; // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UBrickUserSettings* GetUserSettings();

	void CycleBrickUnitsDisplayMode();
	void SetBrickUnitsDisplayMode(const EBrickUnitsDisplayMode& NewMode);
	void SetColorDisplayMode(const EColorDisplayMode NewMode);

	EBrickUnitsDisplayMode GetBrickUnitsDisplayMode() const;
	EColorDisplayMode GetColorDisplayMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickUserSettings">();
	}
	static class UBrickUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickUserSettings>();
	}
};
static_assert(alignof(UBrickUserSettings) == 0x000008, "Wrong alignment on UBrickUserSettings");
static_assert(sizeof(UBrickUserSettings) == 0x000348, "Wrong size on UBrickUserSettings");
static_assert(offsetof(UBrickUserSettings, HoldKeyTime) == 0x000030, "Member 'UBrickUserSettings::HoldKeyTime' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MouseTapTime) == 0x000034, "Member 'UBrickUserSettings::MouseTapTime' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, ConfigVersion) == 0x000038, "Member 'UBrickUserSettings::ConfigVersion' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, HostServerType) == 0x000048, "Member 'UBrickUserSettings::HostServerType' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, ServerPassword) == 0x000050, "Member 'UBrickUserSettings::ServerPassword' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MatchSettings) == 0x000060, "Member 'UBrickUserSettings::MatchSettings' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bAllowDifferentMods) == 0x000128, "Member 'UBrickUserSettings::bAllowDifferentMods' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bApplyMatchSettings) == 0x000129, "Member 'UBrickUserSettings::bApplyMatchSettings' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bFadeMatchSettings) == 0x00012A, "Member 'UBrickUserSettings::bFadeMatchSettings' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, hudvisibility) == 0x00012B, "Member 'UBrickUserSettings::hudvisibility' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MeasurementSystem) == 0x00012C, "Member 'UBrickUserSettings::MeasurementSystem' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, ChatContext) == 0x00012D, "Member 'UBrickUserSettings::ChatContext' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, UIStyle) == 0x000130, "Member 'UBrickUserSettings::UIStyle' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, BrickPropertySettings) == 0x000138, "Member 'UBrickUserSettings::BrickPropertySettings' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MasterVolume) == 0x000188, "Member 'UBrickUserSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MusicVolume) == 0x00018C, "Member 'UBrickUserSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, FieldOfView) == 0x000190, "Member 'UBrickUserSettings::FieldOfView' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, CameraMode) == 0x000194, "Member 'UBrickUserSettings::CameraMode' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, TransmissionMode) == 0x000195, "Member 'UBrickUserSettings::TransmissionMode' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bAutoCounterSteering) == 0x000196, "Member 'UBrickUserSettings::bAutoCounterSteering' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, MouseSensitivity) == 0x000198, "Member 'UBrickUserSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, GamepadSensitivity) == 0x00019C, "Member 'UBrickUserSettings::GamepadSensitivity' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bInvertViewPitch) == 0x0001A0, "Member 'UBrickUserSettings::bInvertViewPitch' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bToggleAim) == 0x0001A1, "Member 'UBrickUserSettings::bToggleAim' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bToggleSprint) == 0x0001A2, "Member 'UBrickUserSettings::bToggleSprint' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bToggleCrouch) == 0x0001A3, "Member 'UBrickUserSettings::bToggleCrouch' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, InputCategory) == 0x0001A8, "Member 'UBrickUserSettings::InputCategory' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, InputMappingSearchText) == 0x0001B0, "Member 'UBrickUserSettings::InputMappingSearchText' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorMirrorAxis) == 0x0001C0, "Member 'UBrickUserSettings::EditorMirrorAxis' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorViewMode) == 0x0001C1, "Member 'UBrickUserSettings::EditorViewMode' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorWorldSetupParams) == 0x0001C8, "Member 'UBrickUserSettings::EditorWorldSetupParams' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorUIScale) == 0x0001F8, "Member 'UBrickUserSettings::EditorUIScale' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorMouseMoveSensitivity) == 0x0001FC, "Member 'UBrickUserSettings::EditorMouseMoveSensitivity' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorGridSnappingDistance) == 0x000200, "Member 'UBrickUserSettings::EditorGridSnappingDistance' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorGridSnappingAngle) == 0x000204, "Member 'UBrickUserSettings::EditorGridSnappingAngle' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorBrickSnappingDistance) == 0x000208, "Member 'UBrickUserSettings::EditorBrickSnappingDistance' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorBrickSnappingAngle) == 0x00020C, "Member 'UBrickUserSettings::EditorBrickSnappingAngle' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bEditorSnappingEnabled) == 0x000210, "Member 'UBrickUserSettings::bEditorSnappingEnabled' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, bEditorGizmoWorldSpace) == 0x000211, "Member 'UBrickUserSettings::bEditorGizmoWorldSpace' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, BrickUnitsDisplayMode) == 0x000212, "Member 'UBrickUserSettings::BrickUnitsDisplayMode' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, ColorDisplayMode) == 0x000213, "Member 'UBrickUserSettings::ColorDisplayMode' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorZoomRatio) == 0x000214, "Member 'UBrickUserSettings::EditorZoomRatio' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, EditorCameraSpeedRatio) == 0x000218, "Member 'UBrickUserSettings::EditorCameraSpeedRatio' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, FreeCamSpeedRatio) == 0x00021C, "Member 'UBrickUserSettings::FreeCamSpeedRatio' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, FreeCamShiftSpeedRatio) == 0x000220, "Member 'UBrickUserSettings::FreeCamShiftSpeedRatio' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, ProjectileCamZoomRatio) == 0x000224, "Member 'UBrickUserSettings::ProjectileCamZoomRatio' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, OnHUDVisibilityChangedDelegate) == 0x000240, "Member 'UBrickUserSettings::OnHUDVisibilityChangedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, OnMeasurementSystemChangedDelegate) == 0x000250, "Member 'UBrickUserSettings::OnMeasurementSystemChangedDelegate' has a wrong offset!");
static_assert(offsetof(UBrickUserSettings, OnColorDisplayModeChanged) == 0x000338, "Member 'UBrickUserSettings::OnColorDisplayModeChanged' has a wrong offset!");

// Class BrickRigs.BrickVehicleComponent
// 0x00B0 (0x0330 - 0x0280)
class UBrickVehicleComponent final : public UBrickEditorInterfaceComponent
{
public:
	uint8                                         Pad_280[0xB0];                                     // 0x0280(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickVehicleComponent">();
	}
	static class UBrickVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickVehicleComponent>();
	}
};
static_assert(alignof(UBrickVehicleComponent) == 0x000010, "Wrong alignment on UBrickVehicleComponent");
static_assert(sizeof(UBrickVehicleComponent) == 0x000330, "Wrong size on UBrickVehicleComponent");

// Class BrickRigs.BrickVehicleStaticInfo
// 0x00F0 (0x0118 - 0x0028)
class UBrickVehicleStaticInfo : public UObject
{
public:
	float                                         MaxConstructionLoopFrameTime;                      // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxConstructionTime;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCollisionEffectSpawnDist;                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCollisionEffectSpeed;                           // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlidingEffectSpeed;                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCollisionSoundDelay;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         SlidingSpeedRange;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             CollisionSound;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FireEmitter;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FireSound;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickPattern>              BrickBurntPattern;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInt32Interval                         NumBurnIntervalsRange;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         BurnTimeRange;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ExtinguishCooldownRange;                           // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSpreadProbability;                             // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireSpreadDistance;                                // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      HandlingSoundAttenuation;                          // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SwitchSound;                                       // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetZoomParams                  ZoomParams;                                        // 0x0098(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinZoomVehicleBoundsRadius;                        // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultZoomRatio;                                  // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DefaultViewRotation;                               // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ViewRotationInterpSpeed;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VelocityCameraInputSpeedRange;                     // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLocationInterpSpeed;                         // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraVelocityInterpSpeed;                         // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHUDIconProperties                     HUDIconProperties;                                 // 0x00D8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         IconOffsetZ;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFriendlyIconDrawDist;                           // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHostileIconDrawDist;                            // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickVehicleStaticInfo">();
	}
	static class UBrickVehicleStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickVehicleStaticInfo>();
	}
};
static_assert(alignof(UBrickVehicleStaticInfo) == 0x000008, "Wrong alignment on UBrickVehicleStaticInfo");
static_assert(sizeof(UBrickVehicleStaticInfo) == 0x000118, "Wrong size on UBrickVehicleStaticInfo");
static_assert(offsetof(UBrickVehicleStaticInfo, MaxConstructionLoopFrameTime) == 0x000028, "Member 'UBrickVehicleStaticInfo::MaxConstructionLoopFrameTime' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MaxConstructionTime) == 0x00002C, "Member 'UBrickVehicleStaticInfo::MaxConstructionTime' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MaxCollisionEffectSpawnDist) == 0x000030, "Member 'UBrickVehicleStaticInfo::MaxCollisionEffectSpawnDist' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MinCollisionEffectSpeed) == 0x000034, "Member 'UBrickVehicleStaticInfo::MinCollisionEffectSpeed' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MinSlidingEffectSpeed) == 0x000038, "Member 'UBrickVehicleStaticInfo::MinSlidingEffectSpeed' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MinCollisionSoundDelay) == 0x00003C, "Member 'UBrickVehicleStaticInfo::MinCollisionSoundDelay' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, SlidingSpeedRange) == 0x000040, "Member 'UBrickVehicleStaticInfo::SlidingSpeedRange' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, CollisionSound) == 0x000048, "Member 'UBrickVehicleStaticInfo::CollisionSound' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, FireEmitter) == 0x000050, "Member 'UBrickVehicleStaticInfo::FireEmitter' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, FireSound) == 0x000058, "Member 'UBrickVehicleStaticInfo::FireSound' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, BrickBurntPattern) == 0x000060, "Member 'UBrickVehicleStaticInfo::BrickBurntPattern' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, NumBurnIntervalsRange) == 0x000068, "Member 'UBrickVehicleStaticInfo::NumBurnIntervalsRange' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, BurnTimeRange) == 0x000070, "Member 'UBrickVehicleStaticInfo::BurnTimeRange' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, ExtinguishCooldownRange) == 0x000078, "Member 'UBrickVehicleStaticInfo::ExtinguishCooldownRange' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, FireSpreadProbability) == 0x000080, "Member 'UBrickVehicleStaticInfo::FireSpreadProbability' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, FireSpreadDistance) == 0x000084, "Member 'UBrickVehicleStaticInfo::FireSpreadDistance' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, HandlingSoundAttenuation) == 0x000088, "Member 'UBrickVehicleStaticInfo::HandlingSoundAttenuation' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, SwitchSound) == 0x000090, "Member 'UBrickVehicleStaticInfo::SwitchSound' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, ZoomParams) == 0x000098, "Member 'UBrickVehicleStaticInfo::ZoomParams' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MinZoomVehicleBoundsRadius) == 0x0000B0, "Member 'UBrickVehicleStaticInfo::MinZoomVehicleBoundsRadius' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, DefaultZoomRatio) == 0x0000B4, "Member 'UBrickVehicleStaticInfo::DefaultZoomRatio' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, DefaultViewRotation) == 0x0000B8, "Member 'UBrickVehicleStaticInfo::DefaultViewRotation' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, ViewRotationInterpSpeed) == 0x0000C4, "Member 'UBrickVehicleStaticInfo::ViewRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, VelocityCameraInputSpeedRange) == 0x0000C8, "Member 'UBrickVehicleStaticInfo::VelocityCameraInputSpeedRange' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, CameraLocationInterpSpeed) == 0x0000D0, "Member 'UBrickVehicleStaticInfo::CameraLocationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, CameraVelocityInterpSpeed) == 0x0000D4, "Member 'UBrickVehicleStaticInfo::CameraVelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, HUDIconProperties) == 0x0000D8, "Member 'UBrickVehicleStaticInfo::HUDIconProperties' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, IconOffsetZ) == 0x000108, "Member 'UBrickVehicleStaticInfo::IconOffsetZ' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MaxFriendlyIconDrawDist) == 0x00010C, "Member 'UBrickVehicleStaticInfo::MaxFriendlyIconDrawDist' has a wrong offset!");
static_assert(offsetof(UBrickVehicleStaticInfo, MaxHostileIconDrawDist) == 0x000110, "Member 'UBrickVehicleStaticInfo::MaxHostileIconDrawDist' has a wrong offset!");

// Class BrickRigs.BrickVerticalBox
// 0x0010 (0x0148 - 0x0138)
class UBrickVerticalBox final : public UVerticalBox
{
public:
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EBrickUISpacingStyle                          SlotSpacingStyle;                                  // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSlotSpacingStyle(EBrickUISpacingStyle NewStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickVerticalBox">();
	}
	static class UBrickVerticalBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickVerticalBox>();
	}
};
static_assert(alignof(UBrickVerticalBox) == 0x000008, "Wrong alignment on UBrickVerticalBox");
static_assert(sizeof(UBrickVerticalBox) == 0x000148, "Wrong size on UBrickVerticalBox");
static_assert(offsetof(UBrickVerticalBox, SlotSpacingStyle) == 0x000140, "Member 'UBrickVerticalBox::SlotSpacingStyle' has a wrong offset!");

// Class BrickRigs.BrickWorldSettings
// 0x0108 (0x04A8 - 0x03A0)
class ABrickWorldSettings : public AWorldSettings
{
public:
	class AWorldSetupActor*                       WorldSetupActor;                                   // 0x03A0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APhysicsVolume*                         DefaultWaterPhysicsVolume;                         // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATrain*>                         SpawnedTrains;                                     // 0x03C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACapturePoint*>                  CapturePoints;                                     // 0x0400(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	class UProjectileManagerComponent*            ProjectileManager;                                 // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADefaultPhysicsVolume>      DefaultWaterPhysicsVolumeClass;                    // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   WaterBounds;                                       // 0x0420(0x001C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SeaLevel;                                          // 0x043C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTrainTrack>                    TrainTracks;                                       // 0x0440(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTrainSpawnInfo>                TrainSpawnInfos;                                   // 0x0450(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x48];                                     // 0x0460(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABrickWorldSettings* Get(const class UObject* WorldContextObject);

	void AddHeatSeekingTarget(class AActor* Target);
	void RemoveHeatSeekingTarget(class AActor* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickWorldSettings">();
	}
	static class ABrickWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickWorldSettings>();
	}
};
static_assert(alignof(ABrickWorldSettings) == 0x000008, "Wrong alignment on ABrickWorldSettings");
static_assert(sizeof(ABrickWorldSettings) == 0x0004A8, "Wrong size on ABrickWorldSettings");
static_assert(offsetof(ABrickWorldSettings, WorldSetupActor) == 0x0003A0, "Member 'ABrickWorldSettings::WorldSetupActor' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, DefaultWaterPhysicsVolume) == 0x0003A8, "Member 'ABrickWorldSettings::DefaultWaterPhysicsVolume' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, SpawnedTrains) == 0x0003C0, "Member 'ABrickWorldSettings::SpawnedTrains' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, CapturePoints) == 0x000400, "Member 'ABrickWorldSettings::CapturePoints' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, ProjectileManager) == 0x000410, "Member 'ABrickWorldSettings::ProjectileManager' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, DefaultWaterPhysicsVolumeClass) == 0x000418, "Member 'ABrickWorldSettings::DefaultWaterPhysicsVolumeClass' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, WaterBounds) == 0x000420, "Member 'ABrickWorldSettings::WaterBounds' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, SeaLevel) == 0x00043C, "Member 'ABrickWorldSettings::SeaLevel' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, TrainTracks) == 0x000440, "Member 'ABrickWorldSettings::TrainTracks' has a wrong offset!");
static_assert(offsetof(ABrickWorldSettings, TrainSpawnInfos) == 0x000450, "Member 'ABrickWorldSettings::TrainSpawnInfos' has a wrong offset!");

// Class BrickRigs.BumperBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UBumperBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BumperBrickStaticInfo">();
	}
	static class UBumperBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBumperBrickStaticInfo>();
	}
};
static_assert(alignof(UBumperBrickStaticInfo) == 0x000008, "Wrong alignment on UBumperBrickStaticInfo");
static_assert(sizeof(UBumperBrickStaticInfo) == 0x000168, "Wrong size on UBumperBrickStaticInfo");

// Class BrickRigs.CameraBrick
// 0x0080 (0x0178 - 0x00F8)
class UCameraBrick : public UBrick
{
public:
	uint8                                         Pad_F8[0x60];                                      // 0x00F8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CameraName;                                        // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrickEditorObjectPtr                  OwningSeat;                                        // 0x0168(0x000C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBrick">();
	}
	static class UCameraBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBrick>();
	}
};
static_assert(alignof(UCameraBrick) == 0x000008, "Wrong alignment on UCameraBrick");
static_assert(sizeof(UCameraBrick) == 0x000178, "Wrong size on UCameraBrick");
static_assert(offsetof(UCameraBrick, CameraName) == 0x000158, "Member 'UCameraBrick::CameraName' has a wrong offset!");
static_assert(offsetof(UCameraBrick, OwningSeat) == 0x000168, "Member 'UCameraBrick::OwningSeat' has a wrong offset!");

// Class BrickRigs.CharacterCapsuleComponent
// 0x0030 (0x0500 - 0x04D0)
class UCharacterCapsuleComponent final : public UCapsuleComponent
{
public:
	uint8                                         Pad_4D0[0x30];                                     // 0x04D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCapsuleComponent">();
	}
	static class UCharacterCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCapsuleComponent>();
	}
};
static_assert(alignof(UCharacterCapsuleComponent) == 0x000010, "Wrong alignment on UCharacterCapsuleComponent");
static_assert(sizeof(UCharacterCapsuleComponent) == 0x000500, "Wrong size on UCharacterCapsuleComponent");

// Class BrickRigs.PlayerPawnInputComponent
// 0x0030 (0x0200 - 0x01D0)
class UPlayerPawnInputComponent : public UPawnInputComponent
{
public:
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseCharacter*                         Character;                                         // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABrickCharacter*                        BrickCharacter;                                    // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABrickVehicle*                          Vehicle;                                           // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHeldCycleExplosives();
	void OnHeldCycleSlots();
	void OnHeldKill();
	void OnPressedAim();
	void OnPressedCycleExplosives();
	void OnPressedCycleFireMode();
	void OnPressedCycleSlots();
	void OnPressedFire();
	void OnPressedKill();
	void OnPressedPrimarySlot();
	void OnPressedReload();
	void OnPressedSecondarySlot();
	void OnPressedSpecialSlot();
	void OnPressedThrowItem();
	void OnPressedUnequipItem();
	void OnReleasedAim();
	void OnReleasedCycleExplosives();
	void OnReleasedCycleSlots();
	void OnReleasedFire();
	void OnReleasedKill();
	void OnTappedCycleExplosives();
	void OnTappedCycleSlots();
	void OnTappedKill();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPawnInputComponent">();
	}
	static class UPlayerPawnInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPawnInputComponent>();
	}
};
static_assert(alignof(UPlayerPawnInputComponent) == 0x000008, "Wrong alignment on UPlayerPawnInputComponent");
static_assert(sizeof(UPlayerPawnInputComponent) == 0x000200, "Wrong size on UPlayerPawnInputComponent");
static_assert(offsetof(UPlayerPawnInputComponent, Character) == 0x0001E8, "Member 'UPlayerPawnInputComponent::Character' has a wrong offset!");
static_assert(offsetof(UPlayerPawnInputComponent, BrickCharacter) == 0x0001F0, "Member 'UPlayerPawnInputComponent::BrickCharacter' has a wrong offset!");
static_assert(offsetof(UPlayerPawnInputComponent, Vehicle) == 0x0001F8, "Member 'UPlayerPawnInputComponent::Vehicle' has a wrong offset!");

// Class BrickRigs.CharacterInputComponent
// 0x0000 (0x0200 - 0x0200)
class UCharacterInputComponent final : public UPlayerPawnInputComponent
{
public:
	void OnPressedCrouch();
	void OnPressedJump();
	void OnPressedSprint();
	void OnReleasedCrouch();
	void OnReleasedJump();
	void OnReleasedSprint();
	void OnToggleCrouch();
	void WalkForward(float Val);
	void WalkRight(float Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInputComponent">();
	}
	static class UCharacterInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInputComponent>();
	}
};
static_assert(alignof(UCharacterInputComponent) == 0x000008, "Wrong alignment on UCharacterInputComponent");
static_assert(sizeof(UCharacterInputComponent) == 0x000200, "Wrong size on UCharacterInputComponent");

// Class BrickRigs.WorldSetupActor
// 0x0950 (0x0B70 - 0x0220)
class AWorldSetupActor : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorldSetupParams                      CurrentWorldSetupParams;                           // 0x0238(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FWorldSetupParams                      PrevWorldSetupParams;                              // 0x0268(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FWorldSetupParams                      TargetWorldSetupParams;                            // 0x0298(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x188];                                    // 0x02C8(0x0188)(Fixing Size After Last Property [ Dumper-7 ])
	class UDirectionalLightComponent*             SunLightComponent;                                 // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkyLightComponent*                     SkyLightComponent;                                 // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   SkyMeshComponent;                                  // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   CloudMeshComponent;                                // 0x0468(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               PrecipitationPSC;                                  // 0x0470(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAudioComponent*>                LightningACs;                                      // 0x0478(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UExponentialHeightFogComponent*         ExponentialHeightFogComponent;                     // 0x0488(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPostProcessComponent*                  PostProcessComponent;                              // 0x0490(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AmbientAudioComponent;                             // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               MapCaptureComponent;                               // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            SkyMesh;                                           // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SkyMeshScale;                                      // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           EnvironmentMPC;                                    // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SkyMaterial;                                       // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     EditorSkyMaterial;                                 // 0x04C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeTransitionRate;                                // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeatherTransitionTime;                             // 0x04D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundCoverageTransitionTime;                      // 0x04D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         SnowHeightRange;                                   // 0x04DC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterHeight;                                       // 0x04E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeOfDayUpdateInterval;                           // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReflectionCaptureUpdateInterval;                   // 0x04EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      SunColorCurve;                                     // 0x04F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      SunColorCurveNoAtmosphere;                         // 0x04F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      SkyColorCurve;                                     // 0x0500(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      HorizonColorCurve;                                 // 0x0508(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveLinearColor*                      CloudDensitySunIntensityCurve;                     // 0x0510(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            CloudMesh;                                         // 0x0518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCloudThickness;                                 // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudCoordinateSnappingGrid;                       // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudScaleSnappingGrid;                            // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudScaleFactor;                                  // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudLitColorSunIntensity;                         // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudLitColorSkyIntensity;                         // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudUnlitColorDesaturation;                       // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloudUnlitColorBrightness;                         // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCloudOpaqueMaterialDensity;                     // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_544[0x4];                                      // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     CloudOpaqueMaterial;                               // 0x0548(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CloudPostProcessMaterial;                          // 0x0550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogDensity;                                        // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogHeightFalloff;                                  // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogStartDistance;                                  // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogHeightOffset;                                   // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FogBrightness;                                     // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundBase*>                     LightningSounds;                                   // 0x0570(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MaxLightningLength;                                // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        PrecipitationEmitters[0x3];                        // 0x0588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundMix*                              UnderwaterSoundMix;                                // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     UnderwaterProcessMaterial;                         // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 MapRenderTarget;                                   // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESceneCaptureSource                           MapCaptureSource;                                  // 0x05B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEngineShowFlagsSetting>        MapCaptureShowFlags;                               // 0x05C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPostProcessSettings                   MapCapturePostProcessSettings;                     // 0x05D0(0x0560)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FBox                                   MapWorldBounds;                                    // 0x0B30(0x001C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4C[0x24];                                     // 0x0B4C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AWorldSetupActor* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSetupActor">();
	}
	static class AWorldSetupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldSetupActor>();
	}
};
static_assert(alignof(AWorldSetupActor) == 0x000010, "Wrong alignment on AWorldSetupActor");
static_assert(sizeof(AWorldSetupActor) == 0x000B70, "Wrong size on AWorldSetupActor");
static_assert(offsetof(AWorldSetupActor, CurrentWorldSetupParams) == 0x000238, "Member 'AWorldSetupActor::CurrentWorldSetupParams' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, PrevWorldSetupParams) == 0x000268, "Member 'AWorldSetupActor::PrevWorldSetupParams' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, TargetWorldSetupParams) == 0x000298, "Member 'AWorldSetupActor::TargetWorldSetupParams' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SunLightComponent) == 0x000450, "Member 'AWorldSetupActor::SunLightComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyLightComponent) == 0x000458, "Member 'AWorldSetupActor::SkyLightComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyMeshComponent) == 0x000460, "Member 'AWorldSetupActor::SkyMeshComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudMeshComponent) == 0x000468, "Member 'AWorldSetupActor::CloudMeshComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, PrecipitationPSC) == 0x000470, "Member 'AWorldSetupActor::PrecipitationPSC' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, LightningACs) == 0x000478, "Member 'AWorldSetupActor::LightningACs' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, ExponentialHeightFogComponent) == 0x000488, "Member 'AWorldSetupActor::ExponentialHeightFogComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, PostProcessComponent) == 0x000490, "Member 'AWorldSetupActor::PostProcessComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, AmbientAudioComponent) == 0x000498, "Member 'AWorldSetupActor::AmbientAudioComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapCaptureComponent) == 0x0004A0, "Member 'AWorldSetupActor::MapCaptureComponent' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyMesh) == 0x0004A8, "Member 'AWorldSetupActor::SkyMesh' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyMeshScale) == 0x0004B0, "Member 'AWorldSetupActor::SkyMeshScale' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, EnvironmentMPC) == 0x0004B8, "Member 'AWorldSetupActor::EnvironmentMPC' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyMaterial) == 0x0004C0, "Member 'AWorldSetupActor::SkyMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, EditorSkyMaterial) == 0x0004C8, "Member 'AWorldSetupActor::EditorSkyMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, TimeTransitionRate) == 0x0004D0, "Member 'AWorldSetupActor::TimeTransitionRate' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, WeatherTransitionTime) == 0x0004D4, "Member 'AWorldSetupActor::WeatherTransitionTime' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, GroundCoverageTransitionTime) == 0x0004D8, "Member 'AWorldSetupActor::GroundCoverageTransitionTime' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SnowHeightRange) == 0x0004DC, "Member 'AWorldSetupActor::SnowHeightRange' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, WaterHeight) == 0x0004E4, "Member 'AWorldSetupActor::WaterHeight' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, TimeOfDayUpdateInterval) == 0x0004E8, "Member 'AWorldSetupActor::TimeOfDayUpdateInterval' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, ReflectionCaptureUpdateInterval) == 0x0004EC, "Member 'AWorldSetupActor::ReflectionCaptureUpdateInterval' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SunColorCurve) == 0x0004F0, "Member 'AWorldSetupActor::SunColorCurve' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SunColorCurveNoAtmosphere) == 0x0004F8, "Member 'AWorldSetupActor::SunColorCurveNoAtmosphere' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, SkyColorCurve) == 0x000500, "Member 'AWorldSetupActor::SkyColorCurve' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, HorizonColorCurve) == 0x000508, "Member 'AWorldSetupActor::HorizonColorCurve' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudDensitySunIntensityCurve) == 0x000510, "Member 'AWorldSetupActor::CloudDensitySunIntensityCurve' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudMesh) == 0x000518, "Member 'AWorldSetupActor::CloudMesh' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MaxCloudThickness) == 0x000520, "Member 'AWorldSetupActor::MaxCloudThickness' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudCoordinateSnappingGrid) == 0x000524, "Member 'AWorldSetupActor::CloudCoordinateSnappingGrid' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudScaleSnappingGrid) == 0x000528, "Member 'AWorldSetupActor::CloudScaleSnappingGrid' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudScaleFactor) == 0x00052C, "Member 'AWorldSetupActor::CloudScaleFactor' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudLitColorSunIntensity) == 0x000530, "Member 'AWorldSetupActor::CloudLitColorSunIntensity' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudLitColorSkyIntensity) == 0x000534, "Member 'AWorldSetupActor::CloudLitColorSkyIntensity' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudUnlitColorDesaturation) == 0x000538, "Member 'AWorldSetupActor::CloudUnlitColorDesaturation' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudUnlitColorBrightness) == 0x00053C, "Member 'AWorldSetupActor::CloudUnlitColorBrightness' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MinCloudOpaqueMaterialDensity) == 0x000540, "Member 'AWorldSetupActor::MinCloudOpaqueMaterialDensity' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudOpaqueMaterial) == 0x000548, "Member 'AWorldSetupActor::CloudOpaqueMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, CloudPostProcessMaterial) == 0x000550, "Member 'AWorldSetupActor::CloudPostProcessMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, FogDensity) == 0x000558, "Member 'AWorldSetupActor::FogDensity' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, FogHeightFalloff) == 0x00055C, "Member 'AWorldSetupActor::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, FogStartDistance) == 0x000560, "Member 'AWorldSetupActor::FogStartDistance' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, FogHeightOffset) == 0x000564, "Member 'AWorldSetupActor::FogHeightOffset' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, FogBrightness) == 0x000568, "Member 'AWorldSetupActor::FogBrightness' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, LightningSounds) == 0x000570, "Member 'AWorldSetupActor::LightningSounds' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MaxLightningLength) == 0x000580, "Member 'AWorldSetupActor::MaxLightningLength' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, PrecipitationEmitters) == 0x000588, "Member 'AWorldSetupActor::PrecipitationEmitters' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, UnderwaterSoundMix) == 0x0005A0, "Member 'AWorldSetupActor::UnderwaterSoundMix' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, UnderwaterProcessMaterial) == 0x0005A8, "Member 'AWorldSetupActor::UnderwaterProcessMaterial' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapRenderTarget) == 0x0005B0, "Member 'AWorldSetupActor::MapRenderTarget' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapCaptureSource) == 0x0005B8, "Member 'AWorldSetupActor::MapCaptureSource' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapCaptureShowFlags) == 0x0005C0, "Member 'AWorldSetupActor::MapCaptureShowFlags' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapCapturePostProcessSettings) == 0x0005D0, "Member 'AWorldSetupActor::MapCapturePostProcessSettings' has a wrong offset!");
static_assert(offsetof(AWorldSetupActor, MapWorldBounds) == 0x000B30, "Member 'AWorldSetupActor::MapWorldBounds' has a wrong offset!");

// Class BrickRigs.WindowBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UWindowBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowBrickStaticInfo">();
	}
	static class UWindowBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowBrickStaticInfo>();
	}
};
static_assert(alignof(UWindowBrickStaticInfo) == 0x000008, "Wrong alignment on UWindowBrickStaticInfo");
static_assert(sizeof(UWindowBrickStaticInfo) == 0x000168, "Wrong size on UWindowBrickStaticInfo");

// Class BrickRigs.CharacterStaticInfo
// 0x02D8 (0x0300 - 0x0028)
class UCharacterStaticInfo : public UObject
{
public:
	float                                         MaxDrawDist;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysicalMaterial;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickPickupCapsuleInflation;                       // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHealth;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamage;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadialDamageScale;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionDamageScale;                              // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHealTime;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHealDelay;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBoneDamageGroup>               BoneDamageGroups;                                  // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFloatInterval                         FallDamageHeightRange;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunOverSpeed;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamage;                                        // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDamageInterval;                                // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoExtinguishDelay;                               // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FireEmitter;                                       // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FireSound;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventoryProperties                   InventoryProperties;                               // 0x0090(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBoneFlinchInfo>                BoneFlinchMap;                                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FlinchAnimationLength;                             // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRotationAnimationRate;                          // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterAction>           LandActionClass;                                   // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterAction>           MeleeActionClass;                                  // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewPitchRange;                                    // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewYawRange;                                      // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeHeightOffset;                                   // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoteViewRotationInterpSpeed;                     // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleViewInterpSpeed;                            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleViewBlendWeight;                            // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleViewDirectionChangeThreshold;               // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShakeBase>           LandedCameraShake;                                 // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         FootstepVolumeModulationRange;                     // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         FootstepPitchModulationRange;                      // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkFootstepVolume;                                // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkFoostepInterval;                               // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFootstepVolume;                              // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchFootstepVolume;                              // 0x0164(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkFootstepInterval;                              // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFootstepInterval;                            // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchFootstepInterval;                            // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      FoleyAttenuationSettings;                          // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoleySoundVolume;                                  // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             RagdollCollisionSound;                             // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCollisionSoundImpactSpeed;                      // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCollisionSoundDelay;                            // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AimInSound;                                        // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AimOutSound;                                       // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHUDIconProperties                     HUDIconProperties;                                 // 0x01A8(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         IconOffsetZ;                                       // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFriendlyIconDrawDist;                           // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNeutralIconDrawDist;                            // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHostileIconDrawDist;                            // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractionSocketName;                             // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSprintTime;                                   // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSprintTime;                                    // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintFireThreshold;                               // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimInTime;                                         // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimOutTime;                                        // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSoundTimeRatio;                                 // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWalkSwayParams                        WalkSwayParams;                                    // 0x0208(0x0080)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ItemSwayMaxAngle;                                  // 0x0288(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ItemSwaySpeed;                                     // 0x0294(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemSwayAimScale;                                  // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ItemLagMaxAngle;                                   // 0x02A4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemLagInterpSpeed;                                // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemLagMaxInputSpeed;                              // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemLagAimScale;                                   // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilFalloff;                                     // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemDropSpeed;                                     // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemThrowSpeed;                                    // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveThrowSpeed;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemThrowAngularSpeedScale;                        // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemDropLocation;                                  // 0x02D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ItemDropRotation;                                  // 0x02DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxBrickCarryMass;                                 // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickCarryDistance;                                // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickCarrySpeedCoefficient;                        // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickCarryAcceleration;                            // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrickThrowSpeed;                                   // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStaticInfo">();
	}
	static class UCharacterStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStaticInfo>();
	}
};
static_assert(alignof(UCharacterStaticInfo) == 0x000008, "Wrong alignment on UCharacterStaticInfo");
static_assert(sizeof(UCharacterStaticInfo) == 0x000300, "Wrong size on UCharacterStaticInfo");
static_assert(offsetof(UCharacterStaticInfo, MaxDrawDist) == 0x000028, "Member 'UCharacterStaticInfo::MaxDrawDist' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, PhysicalMaterial) == 0x000030, "Member 'UCharacterStaticInfo::PhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BrickPickupCapsuleInflation) == 0x000038, "Member 'UCharacterStaticInfo::BrickPickupCapsuleInflation' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MaxHealth) == 0x00003C, "Member 'UCharacterStaticInfo::MaxHealth' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MinDamage) == 0x000040, "Member 'UCharacterStaticInfo::MinDamage' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, RadialDamageScale) == 0x000044, "Member 'UCharacterStaticInfo::RadialDamageScale' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, CollisionDamageScale) == 0x000048, "Member 'UCharacterStaticInfo::CollisionDamageScale' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AutoHealTime) == 0x00004C, "Member 'UCharacterStaticInfo::AutoHealTime' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AutoHealDelay) == 0x000050, "Member 'UCharacterStaticInfo::AutoHealDelay' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BoneDamageGroups) == 0x000058, "Member 'UCharacterStaticInfo::BoneDamageGroups' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FallDamageHeightRange) == 0x000068, "Member 'UCharacterStaticInfo::FallDamageHeightRange' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, RunOverSpeed) == 0x000070, "Member 'UCharacterStaticInfo::RunOverSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FireDamage) == 0x000074, "Member 'UCharacterStaticInfo::FireDamage' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FireDamageInterval) == 0x000078, "Member 'UCharacterStaticInfo::FireDamageInterval' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AutoExtinguishDelay) == 0x00007C, "Member 'UCharacterStaticInfo::AutoExtinguishDelay' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FireEmitter) == 0x000080, "Member 'UCharacterStaticInfo::FireEmitter' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FireSound) == 0x000088, "Member 'UCharacterStaticInfo::FireSound' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, InventoryProperties) == 0x000090, "Member 'UCharacterStaticInfo::InventoryProperties' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BoneFlinchMap) == 0x0000F0, "Member 'UCharacterStaticInfo::BoneFlinchMap' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FlinchAnimationLength) == 0x000100, "Member 'UCharacterStaticInfo::FlinchAnimationLength' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MinRotationAnimationRate) == 0x000104, "Member 'UCharacterStaticInfo::MinRotationAnimationRate' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, LandActionClass) == 0x000108, "Member 'UCharacterStaticInfo::LandActionClass' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MeleeActionClass) == 0x000110, "Member 'UCharacterStaticInfo::MeleeActionClass' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ViewPitchRange) == 0x000118, "Member 'UCharacterStaticInfo::ViewPitchRange' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ViewYawRange) == 0x000120, "Member 'UCharacterStaticInfo::ViewYawRange' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, EyeHeightOffset) == 0x000128, "Member 'UCharacterStaticInfo::EyeHeightOffset' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, RemoteViewRotationInterpSpeed) == 0x00012C, "Member 'UCharacterStaticInfo::RemoteViewRotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, VehicleViewInterpSpeed) == 0x000130, "Member 'UCharacterStaticInfo::VehicleViewInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, VehicleViewBlendWeight) == 0x000134, "Member 'UCharacterStaticInfo::VehicleViewBlendWeight' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, VehicleViewDirectionChangeThreshold) == 0x000138, "Member 'UCharacterStaticInfo::VehicleViewDirectionChangeThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, LandedCameraShake) == 0x000140, "Member 'UCharacterStaticInfo::LandedCameraShake' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FootstepVolumeModulationRange) == 0x000148, "Member 'UCharacterStaticInfo::FootstepVolumeModulationRange' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FootstepPitchModulationRange) == 0x000150, "Member 'UCharacterStaticInfo::FootstepPitchModulationRange' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, WalkFootstepVolume) == 0x000158, "Member 'UCharacterStaticInfo::WalkFootstepVolume' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, WalkFoostepInterval) == 0x00015C, "Member 'UCharacterStaticInfo::WalkFoostepInterval' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, SprintFootstepVolume) == 0x000160, "Member 'UCharacterStaticInfo::SprintFootstepVolume' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, CrouchFootstepVolume) == 0x000164, "Member 'UCharacterStaticInfo::CrouchFootstepVolume' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, WalkFootstepInterval) == 0x000168, "Member 'UCharacterStaticInfo::WalkFootstepInterval' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, SprintFootstepInterval) == 0x00016C, "Member 'UCharacterStaticInfo::SprintFootstepInterval' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, CrouchFootstepInterval) == 0x000170, "Member 'UCharacterStaticInfo::CrouchFootstepInterval' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FoleyAttenuationSettings) == 0x000178, "Member 'UCharacterStaticInfo::FoleyAttenuationSettings' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, FoleySoundVolume) == 0x000180, "Member 'UCharacterStaticInfo::FoleySoundVolume' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, RagdollCollisionSound) == 0x000188, "Member 'UCharacterStaticInfo::RagdollCollisionSound' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MinCollisionSoundImpactSpeed) == 0x000190, "Member 'UCharacterStaticInfo::MinCollisionSoundImpactSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MinCollisionSoundDelay) == 0x000194, "Member 'UCharacterStaticInfo::MinCollisionSoundDelay' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AimInSound) == 0x000198, "Member 'UCharacterStaticInfo::AimInSound' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AimOutSound) == 0x0001A0, "Member 'UCharacterStaticInfo::AimOutSound' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, HUDIconProperties) == 0x0001A8, "Member 'UCharacterStaticInfo::HUDIconProperties' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, IconOffsetZ) == 0x0001D8, "Member 'UCharacterStaticInfo::IconOffsetZ' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MaxFriendlyIconDrawDist) == 0x0001DC, "Member 'UCharacterStaticInfo::MaxFriendlyIconDrawDist' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MaxNeutralIconDrawDist) == 0x0001E0, "Member 'UCharacterStaticInfo::MaxNeutralIconDrawDist' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MaxHostileIconDrawDist) == 0x0001E4, "Member 'UCharacterStaticInfo::MaxHostileIconDrawDist' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, InteractionSocketName) == 0x0001E8, "Member 'UCharacterStaticInfo::InteractionSocketName' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, StartSprintTime) == 0x0001F0, "Member 'UCharacterStaticInfo::StartSprintTime' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, StopSprintTime) == 0x0001F4, "Member 'UCharacterStaticInfo::StopSprintTime' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, SprintFireThreshold) == 0x0001F8, "Member 'UCharacterStaticInfo::SprintFireThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AimInTime) == 0x0001FC, "Member 'UCharacterStaticInfo::AimInTime' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AimOutTime) == 0x000200, "Member 'UCharacterStaticInfo::AimOutTime' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, AimSoundTimeRatio) == 0x000204, "Member 'UCharacterStaticInfo::AimSoundTimeRatio' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, WalkSwayParams) == 0x000208, "Member 'UCharacterStaticInfo::WalkSwayParams' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemSwayMaxAngle) == 0x000288, "Member 'UCharacterStaticInfo::ItemSwayMaxAngle' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemSwaySpeed) == 0x000294, "Member 'UCharacterStaticInfo::ItemSwaySpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemSwayAimScale) == 0x0002A0, "Member 'UCharacterStaticInfo::ItemSwayAimScale' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemLagMaxAngle) == 0x0002A4, "Member 'UCharacterStaticInfo::ItemLagMaxAngle' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemLagInterpSpeed) == 0x0002B0, "Member 'UCharacterStaticInfo::ItemLagInterpSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemLagMaxInputSpeed) == 0x0002B4, "Member 'UCharacterStaticInfo::ItemLagMaxInputSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemLagAimScale) == 0x0002B8, "Member 'UCharacterStaticInfo::ItemLagAimScale' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, RecoilFalloff) == 0x0002BC, "Member 'UCharacterStaticInfo::RecoilFalloff' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemDropSpeed) == 0x0002C0, "Member 'UCharacterStaticInfo::ItemDropSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemThrowSpeed) == 0x0002C4, "Member 'UCharacterStaticInfo::ItemThrowSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ExplosiveThrowSpeed) == 0x0002C8, "Member 'UCharacterStaticInfo::ExplosiveThrowSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemThrowAngularSpeedScale) == 0x0002CC, "Member 'UCharacterStaticInfo::ItemThrowAngularSpeedScale' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemDropLocation) == 0x0002D0, "Member 'UCharacterStaticInfo::ItemDropLocation' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, ItemDropRotation) == 0x0002DC, "Member 'UCharacterStaticInfo::ItemDropRotation' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, MaxBrickCarryMass) == 0x0002E8, "Member 'UCharacterStaticInfo::MaxBrickCarryMass' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BrickCarryDistance) == 0x0002EC, "Member 'UCharacterStaticInfo::BrickCarryDistance' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BrickCarrySpeedCoefficient) == 0x0002F0, "Member 'UCharacterStaticInfo::BrickCarrySpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BrickCarryAcceleration) == 0x0002F4, "Member 'UCharacterStaticInfo::BrickCarryAcceleration' has a wrong offset!");
static_assert(offsetof(UCharacterStaticInfo, BrickThrowSpeed) == 0x0002F8, "Member 'UCharacterStaticInfo::BrickThrowSpeed' has a wrong offset!");

// Class BrickRigs.ChatMessageInputComponent
// 0x00A8 (0x0218 - 0x0170)
class UChatMessageInputComponent final : public UBaseInputComponent
{
public:
	uint8                                         Pad_170[0xA8];                                     // 0x0170(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedKickPlayer();
	void OnPressedViewVehicle();

	bool GetKickPlayerEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatMessageInputComponent">();
	}
	static class UChatMessageInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatMessageInputComponent>();
	}
};
static_assert(alignof(UChatMessageInputComponent) == 0x000008, "Wrong alignment on UChatMessageInputComponent");
static_assert(sizeof(UChatMessageInputComponent) == 0x000218, "Wrong size on UChatMessageInputComponent");

// Class BrickRigs.ChatMessageWidget
// 0x00B0 (0x0310 - 0x0260)
class UChatMessageWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0xB0];                                     // 0x0260(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenContextMenu();
	void UpdateColorStyle(EBrickUIColorStyle NewColorStyle);
	void UpdateMessageText(const class FText& NewText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatMessageWidget">();
	}
	static class UChatMessageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatMessageWidget>();
	}
};
static_assert(alignof(UChatMessageWidget) == 0x000008, "Wrong alignment on UChatMessageWidget");
static_assert(sizeof(UChatMessageWidget) == 0x000310, "Wrong size on UChatMessageWidget");

// Class BrickRigs.WingBrick
// 0x0000 (0x00F8 - 0x00F8)
class UWingBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WingBrick">();
	}
	static class UWingBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWingBrick>();
	}
};
static_assert(alignof(UWingBrick) == 0x000008, "Wrong alignment on UWingBrick");
static_assert(sizeof(UWingBrick) == 0x0000F8, "Wrong size on UWingBrick");

// Class BrickRigs.CheatMenuWidget
// 0x0008 (0x02A0 - 0x0298)
class UCheatMenuWidget : public UPopupWidget
{
public:
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatMenuWidget">();
	}
	static class UCheatMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatMenuWidget>();
	}
};
static_assert(alignof(UCheatMenuWidget) == 0x000008, "Wrong alignment on UCheatMenuWidget");
static_assert(sizeof(UCheatMenuWidget) == 0x0002A0, "Wrong size on UCheatMenuWidget");
static_assert(offsetof(UCheatMenuWidget, PropertiesPanel) == 0x000298, "Member 'UCheatMenuWidget::PropertiesPanel' has a wrong offset!");

// Class BrickRigs.CockAction
// 0x0000 (0x0098 - 0x0098)
class UCockAction final : public UItemAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CockAction">();
	}
	static class UCockAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCockAction>();
	}
};
static_assert(alignof(UCockAction) == 0x000008, "Wrong alignment on UCockAction");
static_assert(sizeof(UCockAction) == 0x000098, "Wrong size on UCockAction");

// Class BrickRigs.ColorPaletteWidget
// 0x0048 (0x02B8 - 0x0270)
class UColorPaletteWidget : public UBrickUserWidget
{
public:
	TArray<struct FColor>                         ColorPaletteSamples;                               // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               Mid;                                               // 0x0280(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x10];                                     // 0x0288(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickImage*                            ColorImage;                                        // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumColorsX;                                        // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumColorsY;                                        // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FLinearColor& NewColor, EValueChangedEventType EventType)> OnColorChangedDelegate; // 0x02A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorPaletteWidget">();
	}
	static class UColorPaletteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorPaletteWidget>();
	}
};
static_assert(alignof(UColorPaletteWidget) == 0x000008, "Wrong alignment on UColorPaletteWidget");
static_assert(sizeof(UColorPaletteWidget) == 0x0002B8, "Wrong size on UColorPaletteWidget");
static_assert(offsetof(UColorPaletteWidget, ColorPaletteSamples) == 0x000270, "Member 'UColorPaletteWidget::ColorPaletteSamples' has a wrong offset!");
static_assert(offsetof(UColorPaletteWidget, Mid) == 0x000280, "Member 'UColorPaletteWidget::Mid' has a wrong offset!");
static_assert(offsetof(UColorPaletteWidget, ColorImage) == 0x000298, "Member 'UColorPaletteWidget::ColorImage' has a wrong offset!");
static_assert(offsetof(UColorPaletteWidget, NumColorsX) == 0x0002A0, "Member 'UColorPaletteWidget::NumColorsX' has a wrong offset!");
static_assert(offsetof(UColorPaletteWidget, NumColorsY) == 0x0002A4, "Member 'UColorPaletteWidget::NumColorsY' has a wrong offset!");
static_assert(offsetof(UColorPaletteWidget, OnColorChangedDelegate) == 0x0002A8, "Member 'UColorPaletteWidget::OnColorChangedDelegate' has a wrong offset!");

// Class BrickRigs.ColorPropertyWidget
// 0x0000 (0x0280 - 0x0280)
class UColorPropertyWidget : public UPropertyWidget
{
public:
	void SetColorPropertyValue(const struct FColor& Color, const EValueChangedEventType EventType);
	void UpdateColorPropertyValue(const struct FColor& NewColor, const bool bValueChanged);

	bool HasAlphaChannel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorPropertyWidget">();
	}
	static class UColorPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorPropertyWidget>();
	}
};
static_assert(alignof(UColorPropertyWidget) == 0x000008, "Wrong alignment on UColorPropertyWidget");
static_assert(sizeof(UColorPropertyWidget) == 0x000280, "Wrong size on UColorPropertyWidget");

// Class BrickRigs.ColorWheelWidget
// 0x00A8 (0x0308 - 0x0260)
class UColorWheelWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            CursorBrush;                                       // 0x0270(0x0088)(Edit, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FLinearColor& NewColor, EValueChangedEventType EventType)> OnColorChangedDelegate; // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetColor(const struct FLinearColor& NewColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorWheelWidget">();
	}
	static class UColorWheelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorWheelWidget>();
	}
};
static_assert(alignof(UColorWheelWidget) == 0x000008, "Wrong alignment on UColorWheelWidget");
static_assert(sizeof(UColorWheelWidget) == 0x000308, "Wrong size on UColorWheelWidget");
static_assert(offsetof(UColorWheelWidget, CursorBrush) == 0x000270, "Member 'UColorWheelWidget::CursorBrush' has a wrong offset!");
static_assert(offsetof(UColorWheelWidget, OnColorChangedDelegate) == 0x0002F8, "Member 'UColorWheelWidget::OnColorChangedDelegate' has a wrong offset!");

// Class BrickRigs.CompressorBrickStaticInfo
// 0x0008 (0x0170 - 0x0168)
class UCompressorBrickStaticInfo : public UBrickStaticInfo
{
public:
	float                                         BoostFactor;                                       // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompressorBrickStaticInfo">();
	}
	static class UCompressorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompressorBrickStaticInfo>();
	}
};
static_assert(alignof(UCompressorBrickStaticInfo) == 0x000008, "Wrong alignment on UCompressorBrickStaticInfo");
static_assert(sizeof(UCompressorBrickStaticInfo) == 0x000170, "Wrong size on UCompressorBrickStaticInfo");
static_assert(offsetof(UCompressorBrickStaticInfo, BoostFactor) == 0x000168, "Member 'UCompressorBrickStaticInfo::BoostFactor' has a wrong offset!");

// Class BrickRigs.ConeBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UConeBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConeBrickStaticInfo">();
	}
	static class UConeBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConeBrickStaticInfo>();
	}
};
static_assert(alignof(UConeBrickStaticInfo) == 0x000008, "Wrong alignment on UConeBrickStaticInfo");
static_assert(sizeof(UConeBrickStaticInfo) == 0x000168, "Wrong size on UConeBrickStaticInfo");

// Class BrickRigs.ConfirmResolutionPopupWidget
// 0x0010 (0x02A8 - 0x0298)
class UConfirmResolutionPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0xC];                                      // 0x0298(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevertTime;                                        // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConfirmResolutionPopupWidget">();
	}
	static class UConfirmResolutionPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfirmResolutionPopupWidget>();
	}
};
static_assert(alignof(UConfirmResolutionPopupWidget) == 0x000008, "Wrong alignment on UConfirmResolutionPopupWidget");
static_assert(sizeof(UConfirmResolutionPopupWidget) == 0x0002A8, "Wrong size on UConfirmResolutionPopupWidget");
static_assert(offsetof(UConfirmResolutionPopupWidget, RevertTime) == 0x0002A4, "Member 'UConfirmResolutionPopupWidget::RevertTime' has a wrong offset!");

// Class BrickRigs.DeathmatchGameMode
// 0x0000 (0x03F8 - 0x03F8)
class ADeathmatchGameMode : public ABrickGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathmatchGameMode">();
	}
	static class ADeathmatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeathmatchGameMode>();
	}
};
static_assert(alignof(ADeathmatchGameMode) == 0x000008, "Wrong alignment on ADeathmatchGameMode");
static_assert(sizeof(ADeathmatchGameMode) == 0x0003F8, "Wrong size on ADeathmatchGameMode");

// Class BrickRigs.ConquestGameMode
// 0x0010 (0x0408 - 0x03F8)
class AConquestGameMode : public ADeathmatchGameMode
{
public:
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateCapturePointsInterval;                       // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HoldCapturePointTeamScore;                         // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConquestGameMode">();
	}
	static class AConquestGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConquestGameMode>();
	}
};
static_assert(alignof(AConquestGameMode) == 0x000008, "Wrong alignment on AConquestGameMode");
static_assert(sizeof(AConquestGameMode) == 0x000408, "Wrong size on AConquestGameMode");
static_assert(offsetof(AConquestGameMode, UpdateCapturePointsInterval) == 0x000400, "Member 'AConquestGameMode::UpdateCapturePointsInterval' has a wrong offset!");
static_assert(offsetof(AConquestGameMode, HoldCapturePointTeamScore) == 0x000404, "Member 'AConquestGameMode::HoldCapturePointTeamScore' has a wrong offset!");

// Class BrickRigs.ContactModifyInterface
// 0x0000 (0x0000 - 0x0000)
class IContactModifyInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContactModifyInterface">();
	}
	static class IContactModifyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContactModifyInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IContactModifyInterface) == 0x000001, "Wrong alignment on IContactModifyInterface");
static_assert(sizeof(IContactModifyInterface) == 0x000001, "Wrong size on IContactModifyInterface");

// Class BrickRigs.ControlHintWidget
// 0x00F8 (0x0358 - 0x0260)
class UControlHintWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x88];                                     // 0x0260(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UScaleBox*                              InputChordScaleBox;                                // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputChordWidget*                      InputChordWidget;                                  // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        TextBlock;                                         // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            IconImage;                                         // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionName;                                        // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputActionTriggerType                       TriggerType;                                       // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowUnboundKey;                                   // 0x0311(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInputChord;                                   // 0x0312(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_313[0x5];                                      // 0x0313(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDisplayInfo                           CustomDisplayInfo;                                 // 0x0318(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	EControlHintDisplayInfoMode                   DisplayInfoMode;                                   // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0341(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBrickUIStyleState                            StyleState;                                        // 0x0342(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_343[0x1];                                      // 0x0343(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextSpacing;                                       // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoldProgressInterpSpeed;                           // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              PressedKeyPadding;                                 // 0x034C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KeyPaddingInterpSpeed;                             // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInputMethodChanged(EInputMethod NewInputMethod);
	void SetAction(class FName InActionName, EInputActionTriggerType InTriggerType);
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetDisplayInfo(const struct FDisplayInfo& InDisplayInfo);
	void SetDisplayInfoMode(EControlHintDisplayInfoMode NewMode);
	void SetInputChordScale(float InScale);
	void SetShowInputChord(bool bShow);
	void SetShowUnboundKey(bool bShow);
	void SetStyleState(EBrickUIStyleState NewState);
	void SetTextStyle(EBrickUITextStyle NewStyle);
	void UpdateDisplayInfo(const struct FDisplayInfo& NewDisplayInfo);
	void UpdateHoldProgress(float InHoldProgress);
	void UpdateIconVisibility(bool bNewVisible);
	void UpdateInputChordStyleState(EBrickUIStyleState InStyleState, bool bInIsHoldAction);
	void UpdateInputChordVisibility(bool bNewVisible);
	void UpdateIsHoldAction(bool bIsHoldAction);
	void UpdateTextVisibility(bool bNewVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlHintWidget">();
	}
	static class UControlHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlHintWidget>();
	}
};
static_assert(alignof(UControlHintWidget) == 0x000008, "Wrong alignment on UControlHintWidget");
static_assert(sizeof(UControlHintWidget) == 0x000358, "Wrong size on UControlHintWidget");
static_assert(offsetof(UControlHintWidget, InputChordScaleBox) == 0x0002E8, "Member 'UControlHintWidget::InputChordScaleBox' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, InputChordWidget) == 0x0002F0, "Member 'UControlHintWidget::InputChordWidget' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, TextBlock) == 0x0002F8, "Member 'UControlHintWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, IconImage) == 0x000300, "Member 'UControlHintWidget::IconImage' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, ActionName) == 0x000308, "Member 'UControlHintWidget::ActionName' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, TriggerType) == 0x000310, "Member 'UControlHintWidget::TriggerType' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, bShowUnboundKey) == 0x000311, "Member 'UControlHintWidget::bShowUnboundKey' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, bShowInputChord) == 0x000312, "Member 'UControlHintWidget::bShowInputChord' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, CustomDisplayInfo) == 0x000318, "Member 'UControlHintWidget::CustomDisplayInfo' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, DisplayInfoMode) == 0x000340, "Member 'UControlHintWidget::DisplayInfoMode' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, ColorStyle) == 0x000341, "Member 'UControlHintWidget::ColorStyle' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, StyleState) == 0x000342, "Member 'UControlHintWidget::StyleState' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, TextSpacing) == 0x000344, "Member 'UControlHintWidget::TextSpacing' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, HoldProgressInterpSpeed) == 0x000348, "Member 'UControlHintWidget::HoldProgressInterpSpeed' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, PressedKeyPadding) == 0x00034C, "Member 'UControlHintWidget::PressedKeyPadding' has a wrong offset!");
static_assert(offsetof(UControlHintWidget, KeyPaddingInterpSpeed) == 0x000354, "Member 'UControlHintWidget::KeyPaddingInterpSpeed' has a wrong offset!");

// Class BrickRigs.CouplingBrickStaticInfo
// 0x0010 (0x0178 - 0x0168)
class UCouplingBrickStaticInfo : public UCouplingBrickBaseStaticInfo
{
public:
	struct FRotator                               AngularLimits;                                     // 0x0168(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CouplingBrickStaticInfo">();
	}
	static class UCouplingBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCouplingBrickStaticInfo>();
	}
};
static_assert(alignof(UCouplingBrickStaticInfo) == 0x000008, "Wrong alignment on UCouplingBrickStaticInfo");
static_assert(sizeof(UCouplingBrickStaticInfo) == 0x000178, "Wrong size on UCouplingBrickStaticInfo");
static_assert(offsetof(UCouplingBrickStaticInfo, AngularLimits) == 0x000168, "Member 'UCouplingBrickStaticInfo::AngularLimits' has a wrong offset!");

// Class BrickRigs.CrosshairWidget
// 0x0068 (0x02C8 - 0x0260)
class UCrosshairWidget : public UUserWidget
{
public:
	class ABaseCharacter*                         Character;                                         // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInventoryItem*                         CurrentItem;                                       // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUserWidget*>                    CrosshairWidgets;                                  // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           CrosshairCanvas;                                   // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            HitMarkerImage;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDVisibility                                CrosshairHUDVisibility;                            // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDVisibility                                HitMarkerHUDVisibility;                            // 0x02A1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                CrosshairWidgetClass;                              // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumCrosshairWidgets;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairRotationOffset;                           // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairAngleStep;                                // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairRadiusScale;                              // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCrosshairRadius;                                // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHUDVisibilityChanged(EHUDVisibility NewVisibility);
	void PlayHitAnimation(const struct FClientDamageInfo& DamageInfo);
	void UpdateIsAttachingWinch(bool bNewAttaching);
	void UpdateWinchAttachment(bool bBlockingHit, bool bWithinRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrosshairWidget">();
	}
	static class UCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrosshairWidget>();
	}
};
static_assert(alignof(UCrosshairWidget) == 0x000008, "Wrong alignment on UCrosshairWidget");
static_assert(sizeof(UCrosshairWidget) == 0x0002C8, "Wrong size on UCrosshairWidget");
static_assert(offsetof(UCrosshairWidget, Character) == 0x000260, "Member 'UCrosshairWidget::Character' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CurrentItem) == 0x000268, "Member 'UCrosshairWidget::CurrentItem' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairWidgets) == 0x000270, "Member 'UCrosshairWidget::CrosshairWidgets' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairCanvas) == 0x000290, "Member 'UCrosshairWidget::CrosshairCanvas' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, HitMarkerImage) == 0x000298, "Member 'UCrosshairWidget::HitMarkerImage' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairHUDVisibility) == 0x0002A0, "Member 'UCrosshairWidget::CrosshairHUDVisibility' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, HitMarkerHUDVisibility) == 0x0002A1, "Member 'UCrosshairWidget::HitMarkerHUDVisibility' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairWidgetClass) == 0x0002A8, "Member 'UCrosshairWidget::CrosshairWidgetClass' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, NumCrosshairWidgets) == 0x0002B0, "Member 'UCrosshairWidget::NumCrosshairWidgets' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairRotationOffset) == 0x0002B4, "Member 'UCrosshairWidget::CrosshairRotationOffset' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairAngleStep) == 0x0002B8, "Member 'UCrosshairWidget::CrosshairAngleStep' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, CrosshairRadiusScale) == 0x0002BC, "Member 'UCrosshairWidget::CrosshairRadiusScale' has a wrong offset!");
static_assert(offsetof(UCrosshairWidget, MinCrosshairRadius) == 0x0002C0, "Member 'UCrosshairWidget::MinCrosshairRadius' has a wrong offset!");

// Class BrickRigs.CylinderBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UCylinderBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CylinderBrickStaticInfo">();
	}
	static class UCylinderBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCylinderBrickStaticInfo>();
	}
};
static_assert(alignof(UCylinderBrickStaticInfo) == 0x000008, "Wrong alignment on UCylinderBrickStaticInfo");
static_assert(sizeof(UCylinderBrickStaticInfo) == 0x000168, "Wrong size on UCylinderBrickStaticInfo");

// Class BrickRigs.DamageType_BuildingCollapse
// 0x0000 (0x0040 - 0x0040)
class UDamageType_BuildingCollapse final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_BuildingCollapse">();
	}
	static class UDamageType_BuildingCollapse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_BuildingCollapse>();
	}
};
static_assert(alignof(UDamageType_BuildingCollapse) == 0x000008, "Wrong alignment on UDamageType_BuildingCollapse");
static_assert(sizeof(UDamageType_BuildingCollapse) == 0x000040, "Wrong size on UDamageType_BuildingCollapse");

// Class BrickRigs.DamageType_Collision
// 0x0000 (0x0040 - 0x0040)
class UDamageType_Collision final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_Collision">();
	}
	static class UDamageType_Collision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_Collision>();
	}
};
static_assert(alignof(UDamageType_Collision) == 0x000008, "Wrong alignment on UDamageType_Collision");
static_assert(sizeof(UDamageType_Collision) == 0x000040, "Wrong size on UDamageType_Collision");

// Class BrickRigs.DamageType_Explosion
// 0x0008 (0x0048 - 0x0040)
class UDamageType_Explosion : public UDamageType
{
public:
	float                                         FireProbability;                                   // 0x0040(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_Explosion">();
	}
	static class UDamageType_Explosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_Explosion>();
	}
};
static_assert(alignof(UDamageType_Explosion) == 0x000008, "Wrong alignment on UDamageType_Explosion");
static_assert(sizeof(UDamageType_Explosion) == 0x000048, "Wrong size on UDamageType_Explosion");
static_assert(offsetof(UDamageType_Explosion, FireProbability) == 0x000040, "Member 'UDamageType_Explosion::FireProbability' has a wrong offset!");

// Class BrickRigs.DamageType_ForceKill
// 0x0000 (0x0040 - 0x0040)
class UDamageType_ForceKill final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_ForceKill">();
	}
	static class UDamageType_ForceKill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_ForceKill>();
	}
};
static_assert(alignof(UDamageType_ForceKill) == 0x000008, "Wrong alignment on UDamageType_ForceKill");
static_assert(sizeof(UDamageType_ForceKill) == 0x000040, "Wrong size on UDamageType_ForceKill");

// Class BrickRigs.DamageType_Melee
// 0x0000 (0x0040 - 0x0040)
class UDamageType_Melee final : public UDamageType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamageType_Melee">();
	}
	static class UDamageType_Melee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamageType_Melee>();
	}
};
static_assert(alignof(UDamageType_Melee) == 0x000008, "Wrong alignment on UDamageType_Melee");
static_assert(sizeof(UDamageType_Melee) == 0x000040, "Wrong size on UDamageType_Melee");

// Class BrickRigs.DashboardIconWidget
// 0x0010 (0x0270 - 0x0260)
class UDashboardIconWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateIconImage(bool bInVisible, EBrickUIColorStyle InColorStyle, int32 InIconIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashboardIconWidget">();
	}
	static class UDashboardIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashboardIconWidget>();
	}
};
static_assert(alignof(UDashboardIconWidget) == 0x000008, "Wrong alignment on UDashboardIconWidget");
static_assert(sizeof(UDashboardIconWidget) == 0x000270, "Wrong size on UDashboardIconWidget");

// Class BrickRigs.DashboardWidget
// 0x0058 (0x02B8 - 0x0260)
class UDashboardWidget : public UUserWidget
{
public:
	class ABrickVehicle*                          Vehicle;                                           // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x10];                                     // 0x0268(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDashboardIconWidget*>           IconWidgets;                                       // 0x0278(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UDashboardSliderWidget*>         SliderWidgets;                                     // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDashboardIconWidget>       IconWidgetClass;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDashboardSliderWidget>     SliderWidgetClass;                                 // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowResourceWarningThreshold;                       // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIconWidget(class UDashboardIconWidget* Widget, int32 Index_0);
	void AddSliderWidget(class UDashboardSliderWidget* Widget);
	void UpdateSliderWidgetSlot(class UDashboardSliderWidget* Widget, int32 Index_0, int32 NumSliders);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DashboardWidget">();
	}
	static class UDashboardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDashboardWidget>();
	}
};
static_assert(alignof(UDashboardWidget) == 0x000008, "Wrong alignment on UDashboardWidget");
static_assert(sizeof(UDashboardWidget) == 0x0002B8, "Wrong size on UDashboardWidget");
static_assert(offsetof(UDashboardWidget, Vehicle) == 0x000260, "Member 'UDashboardWidget::Vehicle' has a wrong offset!");
static_assert(offsetof(UDashboardWidget, IconWidgets) == 0x000278, "Member 'UDashboardWidget::IconWidgets' has a wrong offset!");
static_assert(offsetof(UDashboardWidget, SliderWidgets) == 0x000288, "Member 'UDashboardWidget::SliderWidgets' has a wrong offset!");
static_assert(offsetof(UDashboardWidget, IconWidgetClass) == 0x0002A0, "Member 'UDashboardWidget::IconWidgetClass' has a wrong offset!");
static_assert(offsetof(UDashboardWidget, SliderWidgetClass) == 0x0002A8, "Member 'UDashboardWidget::SliderWidgetClass' has a wrong offset!");
static_assert(offsetof(UDashboardWidget, LowResourceWarningThreshold) == 0x0002B0, "Member 'UDashboardWidget::LowResourceWarningThreshold' has a wrong offset!");

// Class BrickRigs.DestructibleInstancesComponent
// 0x0150 (0x0350 - 0x0200)
class UDestructibleInstancesComponent final : public USceneComponent
{
public:
	TArray<struct FDestructibleInstanceArray>     InstanceArrays;                                    // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FDestructibleInstanceDamageArray       ReplicatedDamage;                                  // 0x0208(0x0120)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x24];                                     // 0x0328(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseHierarchicalISM;                               // 0x034C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFullFloatPrecision;                          // 0x034D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34E[0x2];                                      // 0x034E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleInstancesComponent">();
	}
	static class UDestructibleInstancesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestructibleInstancesComponent>();
	}
};
static_assert(alignof(UDestructibleInstancesComponent) == 0x000010, "Wrong alignment on UDestructibleInstancesComponent");
static_assert(sizeof(UDestructibleInstancesComponent) == 0x000350, "Wrong size on UDestructibleInstancesComponent");
static_assert(offsetof(UDestructibleInstancesComponent, InstanceArrays) == 0x0001F8, "Member 'UDestructibleInstancesComponent::InstanceArrays' has a wrong offset!");
static_assert(offsetof(UDestructibleInstancesComponent, ReplicatedDamage) == 0x000208, "Member 'UDestructibleInstancesComponent::ReplicatedDamage' has a wrong offset!");
static_assert(offsetof(UDestructibleInstancesComponent, bUseHierarchicalISM) == 0x00034C, "Member 'UDestructibleInstancesComponent::bUseHierarchicalISM' has a wrong offset!");
static_assert(offsetof(UDestructibleInstancesComponent, bForceFullFloatPrecision) == 0x00034D, "Member 'UDestructibleInstancesComponent::bForceFullFloatPrecision' has a wrong offset!");

// Class BrickRigs.DestructibleISMComponentInterface
// 0x0000 (0x0000 - 0x0000)
class IDestructibleISMComponentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestructibleISMComponentInterface">();
	}
	static class IDestructibleISMComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDestructibleISMComponentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDestructibleISMComponentInterface) == 0x000001, "Wrong alignment on IDestructibleISMComponentInterface");
static_assert(sizeof(IDestructibleISMComponentInterface) == 0x000001, "Wrong size on IDestructibleISMComponentInterface");

// Class BrickRigs.ScalableBrickBaseStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UScalableBrickBaseStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableBrickBaseStaticInfo">();
	}
	static class UScalableBrickBaseStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableBrickBaseStaticInfo>();
	}
};
static_assert(alignof(UScalableBrickBaseStaticInfo) == 0x000008, "Wrong alignment on UScalableBrickBaseStaticInfo");
static_assert(sizeof(UScalableBrickBaseStaticInfo) == 0x000168, "Wrong size on UScalableBrickBaseStaticInfo");

// Class BrickRigs.ScalableBrickStaticInfo
// 0x0038 (0x01A0 - 0x0168)
class UScalableBrickStaticInfo : public UScalableBrickBaseStaticInfo
{
public:
	float                                         ScalableLiftSurfaceRadiiYZ[0x2];                   // 0x0168(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalableLiftSurfaceNormalsYZ[0x2];                 // 0x0170(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EScalableBrickShape                           ScalableShape;                                     // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScalableBrickReplacementMesh>  ReplacementMeshes;                                 // 0x0190(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScalableBrickStaticInfo">();
	}
	static class UScalableBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScalableBrickStaticInfo>();
	}
};
static_assert(alignof(UScalableBrickStaticInfo) == 0x000008, "Wrong alignment on UScalableBrickStaticInfo");
static_assert(sizeof(UScalableBrickStaticInfo) == 0x0001A0, "Wrong size on UScalableBrickStaticInfo");
static_assert(offsetof(UScalableBrickStaticInfo, ScalableLiftSurfaceRadiiYZ) == 0x000168, "Member 'UScalableBrickStaticInfo::ScalableLiftSurfaceRadiiYZ' has a wrong offset!");
static_assert(offsetof(UScalableBrickStaticInfo, ScalableLiftSurfaceNormalsYZ) == 0x000170, "Member 'UScalableBrickStaticInfo::ScalableLiftSurfaceNormalsYZ' has a wrong offset!");
static_assert(offsetof(UScalableBrickStaticInfo, ScalableShape) == 0x000188, "Member 'UScalableBrickStaticInfo::ScalableShape' has a wrong offset!");
static_assert(offsetof(UScalableBrickStaticInfo, ReplacementMeshes) == 0x000190, "Member 'UScalableBrickStaticInfo::ReplacementMeshes' has a wrong offset!");

// Class BrickRigs.DetonatorBrickStaticInfo
// 0x0018 (0x01B8 - 0x01A0)
class UDetonatorBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	float                                         Damage;                                            // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TriggerEmitter;                                    // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTriggerEmitterDrawDistance;                     // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetonatorBrickStaticInfo">();
	}
	static class UDetonatorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetonatorBrickStaticInfo>();
	}
};
static_assert(alignof(UDetonatorBrickStaticInfo) == 0x000008, "Wrong alignment on UDetonatorBrickStaticInfo");
static_assert(sizeof(UDetonatorBrickStaticInfo) == 0x0001B8, "Wrong size on UDetonatorBrickStaticInfo");
static_assert(offsetof(UDetonatorBrickStaticInfo, Damage) == 0x0001A0, "Member 'UDetonatorBrickStaticInfo::Damage' has a wrong offset!");
static_assert(offsetof(UDetonatorBrickStaticInfo, TriggerEmitter) == 0x0001A8, "Member 'UDetonatorBrickStaticInfo::TriggerEmitter' has a wrong offset!");
static_assert(offsetof(UDetonatorBrickStaticInfo, MaxTriggerEmitterDrawDistance) == 0x0001B0, "Member 'UDetonatorBrickStaticInfo::MaxTriggerEmitterDrawDistance' has a wrong offset!");

// Class BrickRigs.DisplayBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class UDisplayBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayBrickStaticInfo">();
	}
	static class UDisplayBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayBrickStaticInfo>();
	}
};
static_assert(alignof(UDisplayBrickStaticInfo) == 0x000008, "Wrong alignment on UDisplayBrickStaticInfo");
static_assert(sizeof(UDisplayBrickStaticInfo) == 0x0001A0, "Wrong size on UDisplayBrickStaticInfo");

// Class BrickRigs.DoorBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UDoorBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorBrickStaticInfo">();
	}
	static class UDoorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorBrickStaticInfo>();
	}
};
static_assert(alignof(UDoorBrickStaticInfo) == 0x000008, "Wrong alignment on UDoorBrickStaticInfo");
static_assert(sizeof(UDoorBrickStaticInfo) == 0x000168, "Wrong size on UDoorBrickStaticInfo");

// Class BrickRigs.VehicleInputComponent
// 0x00A0 (0x02A0 - 0x0200)
class UVehicleInputComponent : public UPlayerPawnInputComponent
{
public:
	uint8                                         Pad_200[0x40];                                     // 0x0200(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class USeatBrick*                             VehicleSeat;                                       // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x58];                                     // 0x0248(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Brake(float Val);
	void OnHeldCycleCamera();
	void OnHeldCycleFireActionMode();
	void OnHeldCycleSeats();
	void OnHeldCycleSiren();
	void OnHeldPinVehicle();
	void OnHeldToggleSteering();
	void OnPressedAction1();
	void OnPressedAction2();
	void OnPressedAction3();
	void OnPressedAction4();
	void OnPressedAction5();
	void OnPressedAction6();
	void OnPressedAction7();
	void OnPressedAction8();
	void OnPressedBeacon();
	void OnPressedCaptureVehicleThumbnail();
	void OnPressedCycleCamera();
	void OnPressedCycleCameraMode();
	void OnPressedCycleFireActionMode();
	void OnPressedCycleSeats();
	void OnPressedCycleSiren();
	void OnPressedExitVehicle();
	void OnPressedHandBrake();
	void OnPressedHeadlight();
	void OnPressedHorn();
	void OnPressedOperationMode();
	void OnPressedPinVehicle();
	void OnPressedShiftDown();
	void OnPressedShiftUp();
	void OnPressedToggleSteering();
	void OnPressedWarningLight();
	void OnReleasedAction1();
	void OnReleasedAction2();
	void OnReleasedAction3();
	void OnReleasedAction4();
	void OnReleasedAction5();
	void OnReleasedAction6();
	void OnReleasedAction7();
	void OnReleasedAction8();
	void OnReleasedCycleCamera();
	void OnReleasedCycleFireActionMode();
	void OnReleasedCycleSeats();
	void OnReleasedCycleSiren();
	void OnReleasedHandBrake();
	void OnReleasedHorn();
	void OnReleasedOperationMode();
	void OnReleasedPinVehicle();
	void OnReleasedToggleSteering();
	void OnTappedCycleCamera();
	void OnTappedCycleFireActionMode();
	void OnTappedCycleSeats();
	void OnTappedCycleSiren();
	void OnTappedPinVehicle();
	void OnTappedToggleSteering();
	void OnToggleOperationMode();
	void Pitch(float Val);
	void Steering(float Val);
	void Throttle(float Val);
	void ViewPitch(float Val);
	void ViewYaw(float Val);

	class FText GetCycleCameraModeValueText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleInputComponent">();
	}
	static class UVehicleInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleInputComponent>();
	}
};
static_assert(alignof(UVehicleInputComponent) == 0x000008, "Wrong alignment on UVehicleInputComponent");
static_assert(sizeof(UVehicleInputComponent) == 0x0002A0, "Wrong size on UVehicleInputComponent");
static_assert(offsetof(UVehicleInputComponent, VehicleSeat) == 0x000240, "Member 'UVehicleInputComponent::VehicleSeat' has a wrong offset!");

// Class BrickRigs.DriverInputComponent
// 0x0008 (0x02A8 - 0x02A0)
class UDriverInputComponent final : public UVehicleInputComponent
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedCycleTransmissionMode();
	void OnPressedToggleAutoCounterSteering();

	class FText GetCycleTransmissionModeValueText() const;
	class FText GetToggleAutoCounterSteeringValueText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriverInputComponent">();
	}
	static class UDriverInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDriverInputComponent>();
	}
};
static_assert(alignof(UDriverInputComponent) == 0x000008, "Wrong alignment on UDriverInputComponent");
static_assert(sizeof(UDriverInputComponent) == 0x0002A8, "Wrong size on UDriverInputComponent");

// Class BrickRigs.EditorInputComponent
// 0x0010 (0x0190 - 0x0180)
class UEditorInputComponent final : public UBaseEditorInputComponent
{
public:
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveForward(float Val);
	void MoveRight(float Val);
	void MoveUp(float Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorInputComponent">();
	}
	static class UEditorInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorInputComponent>();
	}
};
static_assert(alignof(UEditorInputComponent) == 0x000008, "Wrong alignment on UEditorInputComponent");
static_assert(sizeof(UEditorInputComponent) == 0x000190, "Wrong size on UEditorInputComponent");

// Class BrickRigs.EnumPropertyWidget
// 0x0018 (0x0298 - 0x0280)
class UEnumPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComboBoxWidget*                   ComboBox;                                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void OnItemSelected(int32 Item, EValueChangedEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnumPropertyWidget">();
	}
	static class UEnumPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnumPropertyWidget>();
	}
};
static_assert(alignof(UEnumPropertyWidget) == 0x000008, "Wrong alignment on UEnumPropertyWidget");
static_assert(sizeof(UEnumPropertyWidget) == 0x000298, "Wrong size on UEnumPropertyWidget");
static_assert(offsetof(UEnumPropertyWidget, ComboBox) == 0x000290, "Member 'UEnumPropertyWidget::ComboBox' has a wrong offset!");

// Class BrickRigs.EquipAction
// 0x0000 (0x0098 - 0x0098)
class UEquipAction final : public UItemAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipAction">();
	}
	static class UEquipAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipAction>();
	}
};
static_assert(alignof(UEquipAction) == 0x000008, "Wrong alignment on UEquipAction");
static_assert(sizeof(UEquipAction) == 0x000098, "Wrong size on UEquipAction");

// Class BrickRigs.ExhaustBrickStaticInfo
// 0x0008 (0x01A8 - 0x01A0)
class UExhaustBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	class UExhaustEffect*                         DefaultExhaustEffect;                              // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExhaustBrickStaticInfo">();
	}
	static class UExhaustBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExhaustBrickStaticInfo>();
	}
};
static_assert(alignof(UExhaustBrickStaticInfo) == 0x000008, "Wrong alignment on UExhaustBrickStaticInfo");
static_assert(sizeof(UExhaustBrickStaticInfo) == 0x0001A8, "Wrong size on UExhaustBrickStaticInfo");
static_assert(offsetof(UExhaustBrickStaticInfo, DefaultExhaustEffect) == 0x0001A0, "Member 'UExhaustBrickStaticInfo::DefaultExhaustEffect' has a wrong offset!");

// Class BrickRigs.ExhaustEffect
// 0x0030 (0x0060 - 0x0030)
class UExhaustEffect final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0038(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExhaustEmitter;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BackfireEmitter;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExhaustEffect">();
	}
	static class UExhaustEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExhaustEffect>();
	}
};
static_assert(alignof(UExhaustEffect) == 0x000008, "Wrong alignment on UExhaustEffect");
static_assert(sizeof(UExhaustEffect) == 0x000060, "Wrong size on UExhaustEffect");
static_assert(offsetof(UExhaustEffect, DisplayName) == 0x000038, "Member 'UExhaustEffect::DisplayName' has a wrong offset!");
static_assert(offsetof(UExhaustEffect, ExhaustEmitter) == 0x000050, "Member 'UExhaustEffect::ExhaustEmitter' has a wrong offset!");
static_assert(offsetof(UExhaustEffect, BackfireEmitter) == 0x000058, "Member 'UExhaustEffect::BackfireEmitter' has a wrong offset!");

// Class BrickRigs.Explosion
// 0x0050 (0x0270 - 0x0220)
class AExplosion : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UExplosiveMaterial>         ExplosiveMaterial;                                 // 0x0228(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosiveVolume;                                   // 0x0230(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            ComponentsToIgnore;                                // 0x0238(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AActor*                                 DamageCauser;                                      // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AudioComponent;                                    // 0x0258(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCameraShakeBase>           CameraShakeEffect;                                 // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCameraShakeScaleRadius;                         // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Explosion">();
	}
	static class AExplosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<AExplosion>();
	}
};
static_assert(alignof(AExplosion) == 0x000008, "Wrong alignment on AExplosion");
static_assert(sizeof(AExplosion) == 0x000270, "Wrong size on AExplosion");
static_assert(offsetof(AExplosion, ExplosiveMaterial) == 0x000228, "Member 'AExplosion::ExplosiveMaterial' has a wrong offset!");
static_assert(offsetof(AExplosion, ExplosiveVolume) == 0x000230, "Member 'AExplosion::ExplosiveVolume' has a wrong offset!");
static_assert(offsetof(AExplosion, ComponentsToIgnore) == 0x000238, "Member 'AExplosion::ComponentsToIgnore' has a wrong offset!");
static_assert(offsetof(AExplosion, DamageCauser) == 0x000248, "Member 'AExplosion::DamageCauser' has a wrong offset!");
static_assert(offsetof(AExplosion, ParticleSystemComponent) == 0x000250, "Member 'AExplosion::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(AExplosion, AudioComponent) == 0x000258, "Member 'AExplosion::AudioComponent' has a wrong offset!");
static_assert(offsetof(AExplosion, CameraShakeEffect) == 0x000260, "Member 'AExplosion::CameraShakeEffect' has a wrong offset!");
static_assert(offsetof(AExplosion, MaxCameraShakeScaleRadius) == 0x000268, "Member 'AExplosion::MaxCameraShakeScaleRadius' has a wrong offset!");

// Class BrickRigs.ExplosiveItemStaticInfo
// 0x00F0 (0x0480 - 0x0390)
#pragma pack(push, 0x1)
class alignas(0x10) UExplosiveItemStaticInfo : public UItemStaticInfo
{
public:
	TSubclassOf<class UExplosiveMaterial>         ExplosiveMaterial;                                 // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosiveVolume;                                   // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinExplosionDamage;                                // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeDefused;                                     // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FThrowAnimation                        ThrowAnimation;                                    // 0x03A8(0x00D0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveItemStaticInfo">();
	}
	static class UExplosiveItemStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosiveItemStaticInfo>();
	}
};
#pragma pack(pop)
static_assert(alignof(UExplosiveItemStaticInfo) == 0x000010, "Wrong alignment on UExplosiveItemStaticInfo");
static_assert(sizeof(UExplosiveItemStaticInfo) == 0x000480, "Wrong size on UExplosiveItemStaticInfo");
static_assert(offsetof(UExplosiveItemStaticInfo, ExplosiveMaterial) == 0x000390, "Member 'UExplosiveItemStaticInfo::ExplosiveMaterial' has a wrong offset!");
static_assert(offsetof(UExplosiveItemStaticInfo, ExplosiveVolume) == 0x000398, "Member 'UExplosiveItemStaticInfo::ExplosiveVolume' has a wrong offset!");
static_assert(offsetof(UExplosiveItemStaticInfo, MinExplosionDamage) == 0x00039C, "Member 'UExplosiveItemStaticInfo::MinExplosionDamage' has a wrong offset!");
static_assert(offsetof(UExplosiveItemStaticInfo, bCanBeDefused) == 0x0003A0, "Member 'UExplosiveItemStaticInfo::bCanBeDefused' has a wrong offset!");
static_assert(offsetof(UExplosiveItemStaticInfo, ThrowAnimation) == 0x0003A8, "Member 'UExplosiveItemStaticInfo::ThrowAnimation' has a wrong offset!");

// Class BrickRigs.ExplosiveMaterial
// 0x0060 (0x0088 - 0x0028)
class UExplosiveMaterial : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactResistance;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageResistance;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeIncrease;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bIsFuel : 1;                                       // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AExplosion>                 ExplosionClass;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionEmitter;                                  // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExplosionSound;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplosiveMaterial">();
	}
	static class UExplosiveMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExplosiveMaterial>();
	}
};
static_assert(alignof(UExplosiveMaterial) == 0x000008, "Wrong alignment on UExplosiveMaterial");
static_assert(sizeof(UExplosiveMaterial) == 0x000088, "Wrong size on UExplosiveMaterial");
static_assert(offsetof(UExplosiveMaterial, DisplayName) == 0x000030, "Member 'UExplosiveMaterial::DisplayName' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, Price) == 0x000048, "Member 'UExplosiveMaterial::Price' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, ImpactResistance) == 0x00004C, "Member 'UExplosiveMaterial::ImpactResistance' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, DamageResistance) == 0x000050, "Member 'UExplosiveMaterial::DamageResistance' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, VolumeIncrease) == 0x000054, "Member 'UExplosiveMaterial::VolumeIncrease' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, DamageScale) == 0x000058, "Member 'UExplosiveMaterial::DamageScale' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, DamageType) == 0x000060, "Member 'UExplosiveMaterial::DamageType' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, ExplosionClass) == 0x000070, "Member 'UExplosiveMaterial::ExplosionClass' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, ExplosionEmitter) == 0x000078, "Member 'UExplosiveMaterial::ExplosionEmitter' has a wrong offset!");
static_assert(offsetof(UExplosiveMaterial, ExplosionSound) == 0x000080, "Member 'UExplosiveMaterial::ExplosionSound' has a wrong offset!");

// Class BrickRigs.ExtinguishAction
// 0x0000 (0x0098 - 0x0098)
class UExtinguishAction final : public UItemAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExtinguishAction">();
	}
	static class UExtinguishAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExtinguishAction>();
	}
};
static_assert(alignof(UExtinguishAction) == 0x000008, "Wrong alignment on UExtinguishAction");
static_assert(sizeof(UExtinguishAction) == 0x000098, "Wrong size on UExtinguishAction");

// Class BrickRigs.FadingPanelWidget
// 0x0028 (0x0288 - 0x0260)
class UFadingPanelWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamedSlot*                             ContentSlot;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeTime;                                          // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFadedOutDelegate;                                // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void FadeIn(bool bImmediate);
	void FadeInTimer();
	void FadeOut(bool bImmediate);
	void FadeOutTimer();
	void UpdateFadeAnimation(float FadeAmount);

	bool IsFadedIn() const;
	bool IsFadingIn() const;
	bool IsFadingOut() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadingPanelWidget">();
	}
	static class UFadingPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadingPanelWidget>();
	}
};
static_assert(alignof(UFadingPanelWidget) == 0x000008, "Wrong alignment on UFadingPanelWidget");
static_assert(sizeof(UFadingPanelWidget) == 0x000288, "Wrong size on UFadingPanelWidget");
static_assert(offsetof(UFadingPanelWidget, ContentSlot) == 0x000268, "Member 'UFadingPanelWidget::ContentSlot' has a wrong offset!");
static_assert(offsetof(UFadingPanelWidget, FadeTime) == 0x000270, "Member 'UFadingPanelWidget::FadeTime' has a wrong offset!");
static_assert(offsetof(UFadingPanelWidget, OnFadedOutDelegate) == 0x000278, "Member 'UFadingPanelWidget::OnFadedOutDelegate' has a wrong offset!");

// Class BrickRigs.FenceElement
// 0x0040 (0x0070 - 0x0030)
class UFenceElement final : public UDataAsset
{
public:
	class UDestructibleInstanceTemplate*          Template;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAxis                                         ForwardAxis;                                       // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Spacing;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationJitter;                                    // 0x0040(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationJitter;                                    // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleJitter;                                       // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StretchRange;                                      // 0x0064(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FenceElement">();
	}
	static class UFenceElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFenceElement>();
	}
};
static_assert(alignof(UFenceElement) == 0x000008, "Wrong alignment on UFenceElement");
static_assert(sizeof(UFenceElement) == 0x000070, "Wrong size on UFenceElement");
static_assert(offsetof(UFenceElement, Template) == 0x000030, "Member 'UFenceElement::Template' has a wrong offset!");
static_assert(offsetof(UFenceElement, ForwardAxis) == 0x000038, "Member 'UFenceElement::ForwardAxis' has a wrong offset!");
static_assert(offsetof(UFenceElement, Spacing) == 0x00003C, "Member 'UFenceElement::Spacing' has a wrong offset!");
static_assert(offsetof(UFenceElement, LocationJitter) == 0x000040, "Member 'UFenceElement::LocationJitter' has a wrong offset!");
static_assert(offsetof(UFenceElement, RotationJitter) == 0x00004C, "Member 'UFenceElement::RotationJitter' has a wrong offset!");
static_assert(offsetof(UFenceElement, ScaleJitter) == 0x000058, "Member 'UFenceElement::ScaleJitter' has a wrong offset!");
static_assert(offsetof(UFenceElement, StretchRange) == 0x000064, "Member 'UFenceElement::StretchRange' has a wrong offset!");

// Class BrickRigs.FenceManager
// 0x0008 (0x0228 - 0x0220)
class AFenceManager final : public AActor
{
public:
	class UDestructibleInstancesComponent*        InstancesComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FenceManager">();
	}
	static class AFenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFenceManager>();
	}
};
static_assert(alignof(AFenceManager) == 0x000008, "Wrong alignment on AFenceManager");
static_assert(sizeof(AFenceManager) == 0x000228, "Wrong size on AFenceManager");
static_assert(offsetof(AFenceManager, InstancesComponent) == 0x000220, "Member 'AFenceManager::InstancesComponent' has a wrong offset!");

// Class BrickRigs.SirenBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class USirenBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SirenBrickStaticInfo">();
	}
	static class USirenBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USirenBrickStaticInfo>();
	}
};
static_assert(alignof(USirenBrickStaticInfo) == 0x000008, "Wrong alignment on USirenBrickStaticInfo");
static_assert(sizeof(USirenBrickStaticInfo) == 0x000168, "Wrong size on USirenBrickStaticInfo");

// Class BrickRigs.Fence
// 0x0000 (0x0220 - 0x0220)
class AFence final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fence">();
	}
	static class AFence* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFence>();
	}
};
static_assert(alignof(AFence) == 0x000008, "Wrong alignment on AFence");
static_assert(sizeof(AFence) == 0x000220, "Wrong size on AFence");

// Class BrickRigs.Firearm
// 0x0028 (0x0298 - 0x0270)
class AFirearm : public AInventoryItem
{
public:
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirearmComponent*                      FirearmComponent;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ShellPSC;                                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CockIfNeeded();
	void EjectShell(bool bFromManualReload);
	void ReloadIfNeeded();
	void ResetFirearm();
	void ServerOnReleasedBolt();
	void ServerOnReloaded();
	void SetFireMode(EFireMode NewMode);

	bool CanCock() const;
	bool CanReload() const;
	class ABarrelAttachment* GetBarrel() const;
	EChamberState GetChamberState() const;
	EFireMode GetFireMode() const;
	int32 GetMagazine() const;
	int32 GetMagazineCapacity() const;
	int32 GetNumFireModes() const;
	class ASightAttachment* GetSight() const;
	bool HasFireMode(EFireMode NewMode) const;
	bool HasMagazine() const;
	bool HasToCock() const;
	bool HasToReload() const;
	bool IsFiring() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Firearm">();
	}
	static class AFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirearm>();
	}
};
static_assert(alignof(AFirearm) == 0x000008, "Wrong alignment on AFirearm");
static_assert(sizeof(AFirearm) == 0x000298, "Wrong size on AFirearm");
static_assert(offsetof(AFirearm, FirearmComponent) == 0x000288, "Member 'AFirearm::FirearmComponent' has a wrong offset!");
static_assert(offsetof(AFirearm, ShellPSC) == 0x000290, "Member 'AFirearm::ShellPSC' has a wrong offset!");

// Class BrickRigs.PingIndicatorWidget
// 0x0020 (0x0280 - 0x0260)
class UPingIndicatorWidget : public UUserWidget
{
public:
	class ABrickPlayerState*                      PlayerState;                                       // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBlock*                        PingTextBlock;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinDisplayPing;                                    // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayFrameRate;                                 // 0x027C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetMinDisplayPing(int32 InPing);
	void SetPing(int32 InPing);
	void SetPlayerState(class ABrickPlayerState* InPlayerState);
	void SetStyleState(EBrickUIStyleState NewState);
	void SetTextStyle(EBrickUITextStyle NewStyle);
	void UpdatePing(int32 InPing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingIndicatorWidget">();
	}
	static class UPingIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingIndicatorWidget>();
	}
};
static_assert(alignof(UPingIndicatorWidget) == 0x000008, "Wrong alignment on UPingIndicatorWidget");
static_assert(sizeof(UPingIndicatorWidget) == 0x000280, "Wrong size on UPingIndicatorWidget");
static_assert(offsetof(UPingIndicatorWidget, PlayerState) == 0x000260, "Member 'UPingIndicatorWidget::PlayerState' has a wrong offset!");
static_assert(offsetof(UPingIndicatorWidget, PingTextBlock) == 0x000270, "Member 'UPingIndicatorWidget::PingTextBlock' has a wrong offset!");
static_assert(offsetof(UPingIndicatorWidget, MinDisplayPing) == 0x000278, "Member 'UPingIndicatorWidget::MinDisplayPing' has a wrong offset!");
static_assert(offsetof(UPingIndicatorWidget, bDisplayFrameRate) == 0x00027C, "Member 'UPingIndicatorWidget::bDisplayFrameRate' has a wrong offset!");

// Class BrickRigs.ItemAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UItemAnimInstance : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAnimInstance">();
	}
	static class UItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAnimInstance>();
	}
};
static_assert(alignof(UItemAnimInstance) == 0x000010, "Wrong alignment on UItemAnimInstance");
static_assert(sizeof(UItemAnimInstance) == 0x0002C0, "Wrong size on UItemAnimInstance");

// Class BrickRigs.FirearmAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UFirearmAnimInstance final : public UItemAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirearmAnimInstance">();
	}
	static class UFirearmAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirearmAnimInstance>();
	}
};
static_assert(alignof(UFirearmAnimInstance) == 0x000010, "Wrong alignment on UFirearmAnimInstance");
static_assert(sizeof(UFirearmAnimInstance) == 0x0002C0, "Wrong size on UFirearmAnimInstance");

// Class BrickRigs.FirearmComponent
// 0x0230 (0x02E0 - 0x00B0)
class UFirearmComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFirearmState                          FirearmState;                                      // 0x00D8(0x0006)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DE[0x72];                                      // 0x00DE(0x0072)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        FireAC;                                            // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               FirePSC;                                           // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        FireEmitter;                                       // 0x0160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundBase*                             FireSound;                                         // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_170[0x170];                                    // 0x0170(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FirearmState(const struct FFirearmState& PrevState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirearmComponent">();
	}
	static class UFirearmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirearmComponent>();
	}
};
static_assert(alignof(UFirearmComponent) == 0x000008, "Wrong alignment on UFirearmComponent");
static_assert(sizeof(UFirearmComponent) == 0x0002E0, "Wrong size on UFirearmComponent");
static_assert(offsetof(UFirearmComponent, FirearmState) == 0x0000D8, "Member 'UFirearmComponent::FirearmState' has a wrong offset!");
static_assert(offsetof(UFirearmComponent, FireAC) == 0x000150, "Member 'UFirearmComponent::FireAC' has a wrong offset!");
static_assert(offsetof(UFirearmComponent, FirePSC) == 0x000158, "Member 'UFirearmComponent::FirePSC' has a wrong offset!");
static_assert(offsetof(UFirearmComponent, FireEmitter) == 0x000160, "Member 'UFirearmComponent::FireEmitter' has a wrong offset!");
static_assert(offsetof(UFirearmComponent, FireSound) == 0x000168, "Member 'UFirearmComponent::FireSound' has a wrong offset!");

// Class BrickRigs.FirearmInventoryComponent
// 0x0000 (0x0298 - 0x0298)
class UFirearmInventoryComponent final : public UInventoryComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirearmInventoryComponent">();
	}
	static class UFirearmInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirearmInventoryComponent>();
	}
};
static_assert(alignof(UFirearmInventoryComponent) == 0x000008, "Wrong alignment on UFirearmInventoryComponent");
static_assert(sizeof(UFirearmInventoryComponent) == 0x000298, "Wrong size on UFirearmInventoryComponent");

// Class BrickRigs.SightAttachment
// 0x0048 (0x02B8 - 0x0270)
class ASightAttachment : public AAttachment
{
public:
	uint8                                         Pad_270[0x20];                                     // 0x0270(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               OcclusionMID;                                      // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ReticleMaterial;                                   // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x18];                                     // 0x02A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SightAttachment">();
	}
	static class ASightAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASightAttachment>();
	}
};
static_assert(alignof(ASightAttachment) == 0x000008, "Wrong alignment on ASightAttachment");
static_assert(sizeof(ASightAttachment) == 0x0002B8, "Wrong size on ASightAttachment");
static_assert(offsetof(ASightAttachment, OcclusionMID) == 0x000290, "Member 'ASightAttachment::OcclusionMID' has a wrong offset!");
static_assert(offsetof(ASightAttachment, ReticleMaterial) == 0x000298, "Member 'ASightAttachment::ReticleMaterial' has a wrong offset!");

// Class BrickRigs.FirearmStaticInfo
// 0x0480 (0x0810 - 0x0390)
class UFirearmStaticInfo : public UItemStaticInfo
{
public:
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFirearmProperties                     FirearmProperties;                                 // 0x0398(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   BulletsBoneName;                                   // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAimWhileCocking;                               // 0x0430(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_431[0x3];                                      // 0x0431(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         HorizontalRecoilRange;                             // 0x0434(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         VerticalRecoilRange;                               // 0x043C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilOffsetDeviation;                             // 0x0444(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RecoilRotationDeviation;                           // 0x0450(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RecoilDuration;                                    // 0x045C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           FiringCameraShake;                                 // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeScale;                                  // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSightRailRearBlocked : 1;                         // 0x046C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSightRailFrontBlocked : 1;                        // 0x046C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRailLength;                                   // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_474[0x4];                                      // 0x0474(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AttachmentTags;                                    // 0x0478(0x0020)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              AttachmentAddedSound;                              // 0x0498(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PaintLayerIndex;                                   // 0x04C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C4[0x4];                                      // 0x04C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         ShellEmitter;                                      // 0x04C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShellScale;                                        // 0x04F0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShellEjectionVelocity;                             // 0x04FC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShellEjectionAngularVelocity;                      // 0x0508(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualShellEjectionSpeed;                          // 0x0514(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShellEjectionSpeedDeviation;                       // 0x0518(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SwitchFireModeSound;                               // 0x0520(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFireAnimation                         FireAnimation;                                     // 0x0528(0x00F8)(Edit, NativeAccessSpecifierPublic)
	struct FReloadAnimation                       ReloadAnimation;                                   // 0x0620(0x00D0)(Edit, NativeAccessSpecifierPublic)
	struct FCockAnimation                         CockAnimation;                                     // 0x06F0(0x00D0)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FItemRefPoseOverride>           SightPoseOverrides;                                // 0x07C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FTransform                             HammerCockedTransform;                             // 0x07D0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FItemRefPoseOverride>           BoltLockedPoseOverrides;                           // 0x0800(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirearmStaticInfo">();
	}
	static class UFirearmStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirearmStaticInfo>();
	}
};
static_assert(alignof(UFirearmStaticInfo) == 0x000010, "Wrong alignment on UFirearmStaticInfo");
static_assert(sizeof(UFirearmStaticInfo) == 0x000810, "Wrong size on UFirearmStaticInfo");
static_assert(offsetof(UFirearmStaticInfo, FirearmProperties) == 0x000398, "Member 'UFirearmStaticInfo::FirearmProperties' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, BulletsBoneName) == 0x000428, "Member 'UFirearmStaticInfo::BulletsBoneName' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, bCanAimWhileCocking) == 0x000430, "Member 'UFirearmStaticInfo::bCanAimWhileCocking' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, HorizontalRecoilRange) == 0x000434, "Member 'UFirearmStaticInfo::HorizontalRecoilRange' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, VerticalRecoilRange) == 0x00043C, "Member 'UFirearmStaticInfo::VerticalRecoilRange' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, RecoilOffsetDeviation) == 0x000444, "Member 'UFirearmStaticInfo::RecoilOffsetDeviation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, RecoilRotationDeviation) == 0x000450, "Member 'UFirearmStaticInfo::RecoilRotationDeviation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, RecoilDuration) == 0x00045C, "Member 'UFirearmStaticInfo::RecoilDuration' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, FiringCameraShake) == 0x000460, "Member 'UFirearmStaticInfo::FiringCameraShake' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, CameraShakeScale) == 0x000468, "Member 'UFirearmStaticInfo::CameraShakeScale' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, SightRailLength) == 0x000470, "Member 'UFirearmStaticInfo::SightRailLength' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, AttachmentTags) == 0x000478, "Member 'UFirearmStaticInfo::AttachmentTags' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, AttachmentAddedSound) == 0x000498, "Member 'UFirearmStaticInfo::AttachmentAddedSound' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, PaintLayerIndex) == 0x0004C0, "Member 'UFirearmStaticInfo::PaintLayerIndex' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ShellEmitter) == 0x0004C8, "Member 'UFirearmStaticInfo::ShellEmitter' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ShellScale) == 0x0004F0, "Member 'UFirearmStaticInfo::ShellScale' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ShellEjectionVelocity) == 0x0004FC, "Member 'UFirearmStaticInfo::ShellEjectionVelocity' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ShellEjectionAngularVelocity) == 0x000508, "Member 'UFirearmStaticInfo::ShellEjectionAngularVelocity' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ManualShellEjectionSpeed) == 0x000514, "Member 'UFirearmStaticInfo::ManualShellEjectionSpeed' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ShellEjectionSpeedDeviation) == 0x000518, "Member 'UFirearmStaticInfo::ShellEjectionSpeedDeviation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, SwitchFireModeSound) == 0x000520, "Member 'UFirearmStaticInfo::SwitchFireModeSound' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, FireAnimation) == 0x000528, "Member 'UFirearmStaticInfo::FireAnimation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, ReloadAnimation) == 0x000620, "Member 'UFirearmStaticInfo::ReloadAnimation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, CockAnimation) == 0x0006F0, "Member 'UFirearmStaticInfo::CockAnimation' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, SightPoseOverrides) == 0x0007C0, "Member 'UFirearmStaticInfo::SightPoseOverrides' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, HammerCockedTransform) == 0x0007D0, "Member 'UFirearmStaticInfo::HammerCockedTransform' has a wrong offset!");
static_assert(offsetof(UFirearmStaticInfo, BoltLockedPoseOverrides) == 0x000800, "Member 'UFirearmStaticInfo::BoltLockedPoseOverrides' has a wrong offset!");

// Class BrickRigs.FireExtinguisherStaticInfo
// 0x0150 (0x04E0 - 0x0390)
class UFireExtinguisherStaticInfo : public UItemStaticInfo
{
public:
	struct FFireExtinguisherProperties            ExtinguisherProperties;                            // 0x0390(0x0068)(Edit, NativeAccessSpecifierPublic)
	float                                         ExtinguishStartDistance;                           // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExtinguishAnimation                   ExtinguishAnimation;                               // 0x0400(0x00D8)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x8];                                      // 0x04D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireExtinguisherStaticInfo">();
	}
	static class UFireExtinguisherStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireExtinguisherStaticInfo>();
	}
};
static_assert(alignof(UFireExtinguisherStaticInfo) == 0x000010, "Wrong alignment on UFireExtinguisherStaticInfo");
static_assert(sizeof(UFireExtinguisherStaticInfo) == 0x0004E0, "Wrong size on UFireExtinguisherStaticInfo");
static_assert(offsetof(UFireExtinguisherStaticInfo, ExtinguisherProperties) == 0x000390, "Member 'UFireExtinguisherStaticInfo::ExtinguisherProperties' has a wrong offset!");
static_assert(offsetof(UFireExtinguisherStaticInfo, ExtinguishStartDistance) == 0x0003F8, "Member 'UFireExtinguisherStaticInfo::ExtinguishStartDistance' has a wrong offset!");
static_assert(offsetof(UFireExtinguisherStaticInfo, ExtinguishAnimation) == 0x000400, "Member 'UFireExtinguisherStaticInfo::ExtinguishAnimation' has a wrong offset!");

// Class BrickRigs.PawnIconWidget
// 0x0010 (0x0298 - 0x0288)
class UPawnIconWidget : public UHUDIconWidget
{
public:
	class APawn*                                  OwningPawn;                                        // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnIconWidget">();
	}
	static class UPawnIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnIconWidget>();
	}
};
static_assert(alignof(UPawnIconWidget) == 0x000008, "Wrong alignment on UPawnIconWidget");
static_assert(sizeof(UPawnIconWidget) == 0x000298, "Wrong size on UPawnIconWidget");
static_assert(offsetof(UPawnIconWidget, OwningPawn) == 0x000288, "Member 'UPawnIconWidget::OwningPawn' has a wrong offset!");

// Class BrickRigs.FireExtinguisher
// 0x0008 (0x0278 - 0x0270)
class AFireExtinguisher : public AInventoryItem
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireExtinguisher">();
	}
	static class AFireExtinguisher* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFireExtinguisher>();
	}
};
static_assert(alignof(AFireExtinguisher) == 0x000008, "Wrong alignment on AFireExtinguisher");
static_assert(sizeof(AFireExtinguisher) == 0x000278, "Wrong size on AFireExtinguisher");

// Class BrickRigs.FireExtinguisherComponent
// 0x00C0 (0x0170 - 0x00B0)
class UFireExtinguisherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x88];                                      // 0x00B0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleComp;                                      // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AudioComp;                                         // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x28];                                     // 0x0148(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireExtinguisherComponent">();
	}
	static class UFireExtinguisherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireExtinguisherComponent>();
	}
};
static_assert(alignof(UFireExtinguisherComponent) == 0x000008, "Wrong alignment on UFireExtinguisherComponent");
static_assert(sizeof(UFireExtinguisherComponent) == 0x000170, "Wrong size on UFireExtinguisherComponent");
static_assert(offsetof(UFireExtinguisherComponent, ParticleComp) == 0x000138, "Member 'UFireExtinguisherComponent::ParticleComp' has a wrong offset!");
static_assert(offsetof(UFireExtinguisherComponent, AudioComp) == 0x000140, "Member 'UFireExtinguisherComponent::AudioComp' has a wrong offset!");

// Class BrickRigs.PopupContainerWidget
// 0x0030 (0x02A8 - 0x0278)
class UPopupContainerWidget : public UMainWidgetBase
{
public:
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPopupParams*                           PopupParams;                                       // 0x0290(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupWidget*                           PopupWidget;                                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPopupWidget(class UPopupWidget* Widget);
	void CancelPopup();
	void ConfirmPopup();
	class UMenuButtonWidget* CreateCancelButton();
	class UMenuButtonWidget* CreateConfirmButton();
	void SetButtonPanelVisibility(bool bNewVisible);
	void SetColorStyle(EBrickUIColorStyle InColorStyle);
	void UpdateButtonPanelVisibility(bool bNewVisible);
	void UpdateColorStyle(EBrickUIColorStyle InColorStyle);
	void UpdateContentSlot(bool bShowContent, EPopupSizeRule SizeRule);
	void UpdateTitleText(const class FText& NewTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupContainerWidget">();
	}
	static class UPopupContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupContainerWidget>();
	}
};
static_assert(alignof(UPopupContainerWidget) == 0x000008, "Wrong alignment on UPopupContainerWidget");
static_assert(sizeof(UPopupContainerWidget) == 0x0002A8, "Wrong size on UPopupContainerWidget");
static_assert(offsetof(UPopupContainerWidget, PopupParams) == 0x000290, "Member 'UPopupContainerWidget::PopupParams' has a wrong offset!");
static_assert(offsetof(UPopupContainerWidget, PopupWidget) == 0x000298, "Member 'UPopupContainerWidget::PopupWidget' has a wrong offset!");

// Class BrickRigs.FireInterface
// 0x0000 (0x0000 - 0x0000)
class IFireInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireInterface">();
	}
	static class IFireInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFireInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFireInterface) == 0x000001, "Wrong alignment on IFireInterface");
static_assert(sizeof(IFireInterface) == 0x000001, "Wrong size on IFireInterface");

// Class BrickRigs.FirstAidKit
// 0x0008 (0x0278 - 0x0270)
class AFirstAidKit : public AInventoryItem
{
public:
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstAidKit">();
	}
	static class AFirstAidKit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirstAidKit>();
	}
};
static_assert(alignof(AFirstAidKit) == 0x000008, "Wrong alignment on AFirstAidKit");
static_assert(sizeof(AFirstAidKit) == 0x000278, "Wrong size on AFirstAidKit");

// Class BrickRigs.PlacableObjectWidget
// 0x0038 (0x02A8 - 0x0270)
class UPlacableObjectWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x20];                                     // 0x0270(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            ThumbnailImage;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnButtonClicked();
	void OpenContextMenu();
	void UpdateIsFilterWidget(bool bNewIsFilter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacableObjectWidget">();
	}
	static class UPlacableObjectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlacableObjectWidget>();
	}
};
static_assert(alignof(UPlacableObjectWidget) == 0x000008, "Wrong alignment on UPlacableObjectWidget");
static_assert(sizeof(UPlacableObjectWidget) == 0x0002A8, "Wrong size on UPlacableObjectWidget");
static_assert(offsetof(UPlacableObjectWidget, Button) == 0x000290, "Member 'UPlacableObjectWidget::Button' has a wrong offset!");
static_assert(offsetof(UPlacableObjectWidget, ThumbnailImage) == 0x000298, "Member 'UPlacableObjectWidget::ThumbnailImage' has a wrong offset!");
static_assert(offsetof(UPlacableObjectWidget, NameTextBlock) == 0x0002A0, "Member 'UPlacableObjectWidget::NameTextBlock' has a wrong offset!");

// Class BrickRigs.FirstAidKitStaticInfo
// 0x0010 (0x03A0 - 0x0390)
class UFirstAidKitStaticInfo : public UItemStaticInfo
{
public:
	int32                                         NumBandages;                                       // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPerBandage;                                  // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealDelay;                                         // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealTime;                                          // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstAidKitStaticInfo">();
	}
	static class UFirstAidKitStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstAidKitStaticInfo>();
	}
};
static_assert(alignof(UFirstAidKitStaticInfo) == 0x000010, "Wrong alignment on UFirstAidKitStaticInfo");
static_assert(sizeof(UFirstAidKitStaticInfo) == 0x0003A0, "Wrong size on UFirstAidKitStaticInfo");
static_assert(offsetof(UFirstAidKitStaticInfo, NumBandages) == 0x000390, "Member 'UFirstAidKitStaticInfo::NumBandages' has a wrong offset!");
static_assert(offsetof(UFirstAidKitStaticInfo, HealthPerBandage) == 0x000394, "Member 'UFirstAidKitStaticInfo::HealthPerBandage' has a wrong offset!");
static_assert(offsetof(UFirstAidKitStaticInfo, HealDelay) == 0x000398, "Member 'UFirstAidKitStaticInfo::HealDelay' has a wrong offset!");
static_assert(offsetof(UFirstAidKitStaticInfo, HealTime) == 0x00039C, "Member 'UFirstAidKitStaticInfo::HealTime' has a wrong offset!");

// Class BrickRigs.FuelConsumerBrickStaticInfo
// 0x0018 (0x0180 - 0x0168)
class UFuelConsumerBrickStaticInfo : public UBrickStaticInfo
{
public:
	struct FFuelTankParams                        FuelTankParams;                                    // 0x0168(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FuelConsumption;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FuelConsumerBrickStaticInfo">();
	}
	static class UFuelConsumerBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFuelConsumerBrickStaticInfo>();
	}
};
static_assert(alignof(UFuelConsumerBrickStaticInfo) == 0x000008, "Wrong alignment on UFuelConsumerBrickStaticInfo");
static_assert(sizeof(UFuelConsumerBrickStaticInfo) == 0x000180, "Wrong size on UFuelConsumerBrickStaticInfo");
static_assert(offsetof(UFuelConsumerBrickStaticInfo, FuelTankParams) == 0x000168, "Member 'UFuelConsumerBrickStaticInfo::FuelTankParams' has a wrong offset!");
static_assert(offsetof(UFuelConsumerBrickStaticInfo, FuelConsumption) == 0x000178, "Member 'UFuelConsumerBrickStaticInfo::FuelConsumption' has a wrong offset!");

// Class BrickRigs.PaintAttachment
// 0x0040 (0x02B0 - 0x0270)
class APaintAttachment : public AAttachment
{
public:
	class FText                                   PaintDisplayName;                                  // 0x0270(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Metallic;                                          // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness;                                         // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tiling;                                            // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaintAttachment">();
	}
	static class APaintAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<APaintAttachment>();
	}
};
static_assert(alignof(APaintAttachment) == 0x000008, "Wrong alignment on APaintAttachment");
static_assert(sizeof(APaintAttachment) == 0x0002B0, "Wrong size on APaintAttachment");
static_assert(offsetof(APaintAttachment, PaintDisplayName) == 0x000270, "Member 'APaintAttachment::PaintDisplayName' has a wrong offset!");
static_assert(offsetof(APaintAttachment, Color) == 0x000288, "Member 'APaintAttachment::Color' has a wrong offset!");
static_assert(offsetof(APaintAttachment, Metallic) == 0x000298, "Member 'APaintAttachment::Metallic' has a wrong offset!");
static_assert(offsetof(APaintAttachment, Roughness) == 0x00029C, "Member 'APaintAttachment::Roughness' has a wrong offset!");
static_assert(offsetof(APaintAttachment, Texture) == 0x0002A0, "Member 'APaintAttachment::Texture' has a wrong offset!");
static_assert(offsetof(APaintAttachment, Tiling) == 0x0002A8, "Member 'APaintAttachment::Tiling' has a wrong offset!");

// Class BrickRigs.FlamethrowerBrickStaticInfo
// 0x0020 (0x01A0 - 0x0180)
class UFlamethrowerBrickStaticInfo : public UFuelConsumerBrickStaticInfo
{
public:
	class UParticleSystem*                        FireEmitter;                                       // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FireSound;                                         // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameLength;                                       // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRadius;                                       // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameDamage;                                       // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInterval;                                    // 0x019C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerBrickStaticInfo">();
	}
	static class UFlamethrowerBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamethrowerBrickStaticInfo>();
	}
};
static_assert(alignof(UFlamethrowerBrickStaticInfo) == 0x000008, "Wrong alignment on UFlamethrowerBrickStaticInfo");
static_assert(sizeof(UFlamethrowerBrickStaticInfo) == 0x0001A0, "Wrong size on UFlamethrowerBrickStaticInfo");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, FireEmitter) == 0x000180, "Member 'UFlamethrowerBrickStaticInfo::FireEmitter' has a wrong offset!");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, FireSound) == 0x000188, "Member 'UFlamethrowerBrickStaticInfo::FireSound' has a wrong offset!");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, FlameLength) == 0x000190, "Member 'UFlamethrowerBrickStaticInfo::FlameLength' has a wrong offset!");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, FlameRadius) == 0x000194, "Member 'UFlamethrowerBrickStaticInfo::FlameRadius' has a wrong offset!");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, FlameDamage) == 0x000198, "Member 'UFlamethrowerBrickStaticInfo::FlameDamage' has a wrong offset!");
static_assert(offsetof(UFlamethrowerBrickStaticInfo, DamageInterval) == 0x00019C, "Member 'UFlamethrowerBrickStaticInfo::DamageInterval' has a wrong offset!");

// Class BrickRigs.FuelConsumerBrick
// 0x0008 (0x0100 - 0x00F8)
class UFuelConsumerBrick : public UBrick
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FuelConsumerBrick">();
	}
	static class UFuelConsumerBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFuelConsumerBrick>();
	}
};
static_assert(alignof(UFuelConsumerBrick) == 0x000008, "Wrong alignment on UFuelConsumerBrick");
static_assert(sizeof(UFuelConsumerBrick) == 0x000100, "Wrong size on UFuelConsumerBrick");

// Class BrickRigs.PlayersMenuWidget
// 0x0008 (0x0278 - 0x0270)
class UPlayersMenuWidget : public UMenuPageWidget
{
public:
	class UScoreboardWidget*                      Scoreboard;                                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void KickPlayer();
	void ShowPlayerProfile();
	void UpdateCanKickPlayer(bool bCanKick);
	void UpdateCanShowPlayerProfile(bool bCanShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayersMenuWidget">();
	}
	static class UPlayersMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayersMenuWidget>();
	}
};
static_assert(alignof(UPlayersMenuWidget) == 0x000008, "Wrong alignment on UPlayersMenuWidget");
static_assert(sizeof(UPlayersMenuWidget) == 0x000278, "Wrong size on UPlayersMenuWidget");
static_assert(offsetof(UPlayersMenuWidget, Scoreboard) == 0x000270, "Member 'UPlayersMenuWidget::Scoreboard' has a wrong offset!");

// Class BrickRigs.FlamethrowerBrick
// 0x0090 (0x0190 - 0x0100)
class alignas(0x10) UFlamethrowerBrick final : public UFuelConsumerBrick
{
public:
	uint8                                         Pad_100[0x60];                                     // 0x0100(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlamethrowerBrick">();
	}
	static class UFlamethrowerBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlamethrowerBrick>();
	}
};
static_assert(alignof(UFlamethrowerBrick) == 0x000010, "Wrong alignment on UFlamethrowerBrick");
static_assert(sizeof(UFlamethrowerBrick) == 0x000190, "Wrong size on UFlamethrowerBrick");
static_assert(offsetof(UFlamethrowerBrick, InputChannel) == 0x000160, "Member 'UFlamethrowerBrick::InputChannel' has a wrong offset!");

// Class BrickRigs.FlapBrickStaticInfo
// 0x0008 (0x01A8 - 0x01A0)
class UFlapBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	float                                         FlapInterpSpeed;                                   // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlapBrickStaticInfo">();
	}
	static class UFlapBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlapBrickStaticInfo>();
	}
};
static_assert(alignof(UFlapBrickStaticInfo) == 0x000008, "Wrong alignment on UFlapBrickStaticInfo");
static_assert(sizeof(UFlapBrickStaticInfo) == 0x0001A8, "Wrong size on UFlapBrickStaticInfo");
static_assert(offsetof(UFlapBrickStaticInfo, FlapInterpSpeed) == 0x0001A0, "Member 'UFlapBrickStaticInfo::FlapInterpSpeed' has a wrong offset!");

// Class BrickRigs.PropertyContainerInputComponent
// 0x0010 (0x0180 - 0x0170)
class UPropertyContainerInputComponent final : public UBaseInputComponent
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedCopyValue();
	void OnPressedPasteValue();
	void OnPressedPickValue();
	void OnPressedSelectByValue();

	bool GetCopyValueEnabled() const;
	bool GetPasteValueEnabled() const;
	bool GetPickValueEnabled() const;
	bool GetSelectByValueEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyContainerInputComponent">();
	}
	static class UPropertyContainerInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyContainerInputComponent>();
	}
};
static_assert(alignof(UPropertyContainerInputComponent) == 0x000008, "Wrong alignment on UPropertyContainerInputComponent");
static_assert(sizeof(UPropertyContainerInputComponent) == 0x000180, "Wrong size on UPropertyContainerInputComponent");

// Class BrickRigs.FlapBrick
// 0x0048 (0x0168 - 0x0120)
class UFlapBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         InputScale;                                        // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinAngle;                                          // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngle;                                          // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAccumulateInput;                                  // 0x0164(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlapBrick">();
	}
	static class UFlapBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlapBrick>();
	}
};
static_assert(alignof(UFlapBrick) == 0x000008, "Wrong alignment on UFlapBrick");
static_assert(sizeof(UFlapBrick) == 0x000168, "Wrong size on UFlapBrick");
static_assert(offsetof(UFlapBrick, InputChannel) == 0x000130, "Member 'UFlapBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UFlapBrick, InputScale) == 0x000158, "Member 'UFlapBrick::InputScale' has a wrong offset!");
static_assert(offsetof(UFlapBrick, MinAngle) == 0x00015C, "Member 'UFlapBrick::MinAngle' has a wrong offset!");
static_assert(offsetof(UFlapBrick, MaxAngle) == 0x000160, "Member 'UFlapBrick::MaxAngle' has a wrong offset!");
static_assert(offsetof(UFlapBrick, bAccumulateInput) == 0x000164, "Member 'UFlapBrick::bAccumulateInput' has a wrong offset!");

// Class BrickRigs.ProjectileImpactInterface
// 0x0000 (0x0000 - 0x0000)
class IProjectileImpactInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileImpactInterface">();
	}
	static class IProjectileImpactInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileImpactInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProjectileImpactInterface) == 0x000001, "Wrong alignment on IProjectileImpactInterface");
static_assert(sizeof(IProjectileImpactInterface) == 0x000001, "Wrong size on IProjectileImpactInterface");

// Class BrickRigs.FlareBrickStaticInfo
// 0x0000 (0x02A0 - 0x02A0)
class UFlareBrickStaticInfo : public UGunBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlareBrickStaticInfo">();
	}
	static class UFlareBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlareBrickStaticInfo>();
	}
};
static_assert(alignof(UFlareBrickStaticInfo) == 0x000010, "Wrong alignment on UFlareBrickStaticInfo");
static_assert(sizeof(UFlareBrickStaticInfo) == 0x0002A0, "Wrong size on UFlareBrickStaticInfo");

// Class BrickRigs.FlashSequenceItemWidget
// 0x0010 (0x02D8 - 0x02C8)
class UFlashSequenceItemWidget : public UBrickComboBoxItemWidget
{
public:
	TSubclassOf<class USirenSequence>             FlashSequenceClass;                                // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateIsLit(bool bNewLit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashSequenceItemWidget">();
	}
	static class UFlashSequenceItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashSequenceItemWidget>();
	}
};
static_assert(alignof(UFlashSequenceItemWidget) == 0x000008, "Wrong alignment on UFlashSequenceItemWidget");
static_assert(sizeof(UFlashSequenceItemWidget) == 0x0002D8, "Wrong size on UFlashSequenceItemWidget");
static_assert(offsetof(UFlashSequenceItemWidget, FlashSequenceClass) == 0x0002C8, "Member 'UFlashSequenceItemWidget::FlashSequenceClass' has a wrong offset!");

// Class BrickRigs.PlayerIconWidget
// 0x0018 (0x02B0 - 0x0298)
class UPlayerIconWidget : public UPawnIconWidget
{
public:
	class ABaseCharacter*                         Character;                                         // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickPlayerState*                      CharacterPlayerState;                              // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdatePlayerIcon(bool bNewIsLocalPlayer, bool bNewIsTeamLeader, ECharacterStateOfHealth NewStateOfHealth, bool bNewCanBeDamaged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerIconWidget">();
	}
	static class UPlayerIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerIconWidget>();
	}
};
static_assert(alignof(UPlayerIconWidget) == 0x000008, "Wrong alignment on UPlayerIconWidget");
static_assert(sizeof(UPlayerIconWidget) == 0x0002B0, "Wrong size on UPlayerIconWidget");
static_assert(offsetof(UPlayerIconWidget, Character) == 0x000298, "Member 'UPlayerIconWidget::Character' has a wrong offset!");
static_assert(offsetof(UPlayerIconWidget, CharacterPlayerState) == 0x0002A0, "Member 'UPlayerIconWidget::CharacterPlayerState' has a wrong offset!");

// Class BrickRigs.PropertiesPanelWidget
// 0x0070 (0x02D0 - 0x0260)
class UPropertiesPanelWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPropertyCategoryWidget*>        PropertyCategoryWidgets;                           // 0x0278(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPropertyContainerWidget*>       PropertyContainerWidgets;                          // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x15];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FName										  FocusedSubPropertyName;
	TSubclassOf<class UPropertyCategoryWidget>    CategoryWidgetClass;                               // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPropertyContainerWidget>   ContainerWidgetClass;                              // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPropertiesPerRow;                               // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrientation                                  Orientation;                                       // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCategoryWidget(class UPropertyCategoryWidget* Widget, int32 Index_0);
	void AddProperties(const TArray<class UObject*>& InContainers, const struct FBrickPropertyReflectionFilter& InFilter);
	void ClearProperties();
	void UpdateProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertiesPanelWidget">();
	}
	static class UPropertiesPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertiesPanelWidget>();
	}
};
static_assert(alignof(UPropertiesPanelWidget) == 0x000008, "Wrong alignment on UPropertiesPanelWidget");
static_assert(sizeof(UPropertiesPanelWidget) == 0x0002D0, "Wrong size on UPropertiesPanelWidget");
static_assert(offsetof(UPropertiesPanelWidget, PropertyCategoryWidgets) == 0x000278, "Member 'UPropertiesPanelWidget::PropertyCategoryWidgets' has a wrong offset!");
static_assert(offsetof(UPropertiesPanelWidget, PropertyContainerWidgets) == 0x000288, "Member 'UPropertiesPanelWidget::PropertyContainerWidgets' has a wrong offset!");
static_assert(offsetof(UPropertiesPanelWidget, CategoryWidgetClass) == 0x0002B8, "Member 'UPropertiesPanelWidget::CategoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UPropertiesPanelWidget, ContainerWidgetClass) == 0x0002C0, "Member 'UPropertiesPanelWidget::ContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UPropertiesPanelWidget, NumPropertiesPerRow) == 0x0002C8, "Member 'UPropertiesPanelWidget::NumPropertiesPerRow' has a wrong offset!");
static_assert(offsetof(UPropertiesPanelWidget, Orientation) == 0x0002CC, "Member 'UPropertiesPanelWidget::Orientation' has a wrong offset!");

// Class BrickRigs.FloatBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class UFloatBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatBrickStaticInfo">();
	}
	static class UFloatBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatBrickStaticInfo>();
	}
};
static_assert(alignof(UFloatBrickStaticInfo) == 0x000008, "Wrong alignment on UFloatBrickStaticInfo");
static_assert(sizeof(UFloatBrickStaticInfo) == 0x0001A0, "Wrong size on UFloatBrickStaticInfo");

// Class BrickRigs.FloatBrick
// 0x0010 (0x0130 - 0x0120)
class UFloatBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatBrick">();
	}
	static class UFloatBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatBrick>();
	}
};
static_assert(alignof(UFloatBrick) == 0x000008, "Wrong alignment on UFloatBrick");
static_assert(sizeof(UFloatBrick) == 0x000130, "Wrong size on UFloatBrick");

// Class BrickRigs.RampBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class URampBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RampBrickStaticInfo">();
	}
	static class URampBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URampBrickStaticInfo>();
	}
};
static_assert(alignof(URampBrickStaticInfo) == 0x000008, "Wrong alignment on URampBrickStaticInfo");
static_assert(sizeof(URampBrickStaticInfo) == 0x000168, "Wrong size on URampBrickStaticInfo");

// Class BrickRigs.FluMathStatics
// 0x0000 (0x0028 - 0x0028)
class UFluMathStatics final : public UBlueprintFunctionLibrary
{
public:
	static int32 AxisToIndex(const EAxis Axis);
	static bool BitmaskHasFlag(const int32 BitMask, const uint8 Index_0);
	static int32 BitmaskSetFlag(const int32 BitMask, const uint8 Index_0, const bool bFlag);
	static EAxis IndexToAxis(const int32 Index_0);
	static float IntegrateEllipseArcLength(const struct FVector2D& Radius, const float AngleRad, const int32 Steps);
	static bool IsAxisSignedPositive(const EFluAxisSigned Axis);
	static EFluAxisSigned MakeAxisSigned(const EAxis Axis, const bool bPositiveAxis);
	static int32 MakeBitmask(const uint8 Index_0);
	static struct FRotator QuatToNiceRotator(const struct FQuat& Quat);
	static EAxis RemapAxisLockAxis(const EFluAxisLock AxisLock, const EAxis Axis);
	static int32 RemapAxisLockIndex(const EFluAxisLock AxisLock, const int32 AxisIndex);
	static struct FVector2D RotateVector2D90(const struct FVector2D& Vector, const int32 NumFlips);
	static void SplitAxisSigned(const EFluAxisSigned Axis, EAxis* OutAxis, bool* bOutPositiveAxis);
	static float Vector2DAngle2Deg(const struct FVector2D& A, const struct FVector2D& B);
	static float Vector2DAngle2Rad(const struct FVector2D& A, const struct FVector2D& B);
	static float Vector2DAngleDeg(const struct FVector2D& Vector);
	static float Vector2DAngleRad(const struct FVector2D& Vector);
	static int32 WrapIndex(const int32 Index_0, const int32 Num);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluMathStatics">();
	}
	static class UFluMathStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFluMathStatics>();
	}
};
static_assert(alignof(UFluMathStatics) == 0x000008, "Wrong alignment on UFluMathStatics");
static_assert(sizeof(UFluMathStatics) == 0x000028, "Wrong size on UFluMathStatics");

// Class BrickRigs.PropertyListInterface
// 0x0000 (0x0000 - 0x0000)
class IPropertyListInterface final
{
public:
	void AddPropertyContainerWidget(class UPropertyContainerWidget* Widget);
	void UpdatePropertyContainerWidgetSlot(class UPropertyContainerWidget* Widget, int32 Index_0, int32 NumPerRow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyListInterface">();
	}
	static class IPropertyListInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPropertyListInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPropertyListInterface) == 0x000001, "Wrong alignment on IPropertyListInterface");
static_assert(sizeof(IPropertyListInterface) == 0x000001, "Wrong size on IPropertyListInterface");

// Class BrickRigs.GameModeInfo
// 0x0070 (0x00A0 - 0x0030)
class UGameModeInfo final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftClassPath                         GameModeClass;                                     // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0050(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescriptionText;                                   // 0x0070(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 Alias;                                             // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequiresPrefixedSubLevel;                         // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesRoundDuration;                                // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoundBased;                                     // 0x009A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesInfiniteMoney;                                // 0x009B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesSandboxSettings;                              // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsSingleplayer;                             // 0x009D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsMultiplayer;                              // 0x009E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeInfo">();
	}
	static class UGameModeInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameModeInfo>();
	}
};
static_assert(alignof(UGameModeInfo) == 0x000008, "Wrong alignment on UGameModeInfo");
static_assert(sizeof(UGameModeInfo) == 0x0000A0, "Wrong size on UGameModeInfo");
static_assert(offsetof(UGameModeInfo, GameModeClass) == 0x000038, "Member 'UGameModeInfo::GameModeClass' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, DisplayName) == 0x000050, "Member 'UGameModeInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, SortPriority) == 0x000068, "Member 'UGameModeInfo::SortPriority' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, DescriptionText) == 0x000070, "Member 'UGameModeInfo::DescriptionText' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, Alias) == 0x000088, "Member 'UGameModeInfo::Alias' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bRequiresPrefixedSubLevel) == 0x000098, "Member 'UGameModeInfo::bRequiresPrefixedSubLevel' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bUsesRoundDuration) == 0x000099, "Member 'UGameModeInfo::bUsesRoundDuration' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bIsRoundBased) == 0x00009A, "Member 'UGameModeInfo::bIsRoundBased' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bUsesInfiniteMoney) == 0x00009B, "Member 'UGameModeInfo::bUsesInfiniteMoney' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bUsesSandboxSettings) == 0x00009C, "Member 'UGameModeInfo::bUsesSandboxSettings' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bSupportsSingleplayer) == 0x00009D, "Member 'UGameModeInfo::bSupportsSingleplayer' has a wrong offset!");
static_assert(offsetof(UGameModeInfo, bSupportsMultiplayer) == 0x00009E, "Member 'UGameModeInfo::bSupportsMultiplayer' has a wrong offset!");

// Class BrickRigs.GameOverlayWidget
// 0x00B8 (0x0318 - 0x0260)
class UGameOverlayWidget : public UUserWidget
{
public:
	class UChatWidget*                            ChatWidget;                                        // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputHelpWidget*                       InputHelpWidget;                                   // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMatchTimerWidget*                      MatchTimerWidget;                                  // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMatchStateWidget*                      MatchStateWidget;                                  // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTeamScoreWidget*>               TeamScoreWidgets;                                  // 0x0280(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UHUDNotificationWidget*>         HUDNotificationWidgets;                            // 0x0290(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASpectatorPawn*                         SpectatorPawn;                                     // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseCharacter*                         ViewedCharacter;                                   // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickEditor*                           BrickEditor;                                       // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPingIndicatorWidget*                   HighPingIndicator;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInputHelpWidget>           InputHelpClass;                                    // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHUDNotificationWidget>     HUDNotificationClass;                              // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatchTimerWidget>          MatchTimerWidgetClass;                             // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatchStateWidget>          MatchStateWidgetClass;                             // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UTeamScoreWidget>           TeamScoreWidgetClass;                              // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChatWidget>                ChatWidgetClass;                                   // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinimalHUDMaxMatchTimerRemaining;                  // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameOverlayWidget* Get(const class UObject* WorldContextObject);

	void AddChatWidget(class UChatWidget* Widget);
	void AddHUDNotification(class UHUDNotificationWidget* Widget, int32 Index_0);
	void AddInputHelpWidget(class UInputHelpWidget* Widget);
	void AddMatchStateWidget(class UMatchStateWidget* Widget);
	void AddMatchTimerWidget(class UMatchTimerWidget* Widget);
	void AddTeamScoreWidget(class UTeamScoreWidget* Widget, ETeamAttitude TeamAttitude);
	class UHUDNotificationWidget* CreateHUDNotification(const class FName& Context, bool bShouldFadeOut);
	void OnCameraModeChanged(ECameraMode NewMode);
	void OnHUDVisibilityChanged(EHUDVisibility NewVisibility);
	bool ToggleInputHelpOpen(bool bUpdateFocus);
	void UpdateCameraModeNotification(class UHUDNotificationWidget* Widget, ECameraMode NewMode);
	void UpdateCameraSpeedNotification(class UHUDNotificationWidget* Widget, float NewSpeedRatio, float NewMaxSpeed);
	void UpdateCameraZoomNotification(class UHUDNotificationWidget* Widget, float NewZoomRatio);
	void UpdateFreeCamNotification(class UHUDNotificationWidget* Widget, bool bIsInFreeCam, EFreeCamMode InFreeCamMode, bool bIsFixedCam);
	void UpdateHUDVisibilityNotification(class UHUDNotificationWidget* Widget, EHUDVisibility NewVisibility);
	void UpdateMoneyNotification(class UHUDNotificationWidget* Widget, float NewAmount, float AmountAdded);
	void UpdateProjectileCameraNotification(class UHUDNotificationWidget* Widget, bool bNewEnabled);
	void UpdateRespawnDelayNotification(class UHUDNotificationWidget* Widget, float Remaining);
	void UpdateRestartFailedNotification(class UHUDNotificationWidget* Widget, const class FText& Message);
	void UpdateSaveNotification(class UHUDNotificationWidget* Widget, bool bSuccess, bool bIsAutoSave);
	void UpdateSlomoNotification(class UHUDNotificationWidget* Widget, float SlomoSpeed, bool bInvertSpeed, bool bSlomoEnabled, bool bIsPaused);
	void UpdateThumbnailNotification(class UHUDNotificationWidget* Widget);
	void UpdateVehicleCameraNotification(class UHUDNotificationWidget* Widget, const class FText& CameraDisplayName);
	void UpdateVehicleConstructionNotification(class UHUDNotificationWidget* Widget, const class FText& VehicleDisplayName, float Progress);
	void UpdateVehicleDownloadNotification(class UHUDNotificationWidget* Widget, const class FText& VehicleDisplayName, float Progress);
	void UpdateVehicleSeatNotification(class UHUDNotificationWidget* Widget, const class FText& SeatDisplayName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameOverlayWidget">();
	}
	static class UGameOverlayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameOverlayWidget>();
	}
};
static_assert(alignof(UGameOverlayWidget) == 0x000008, "Wrong alignment on UGameOverlayWidget");
static_assert(sizeof(UGameOverlayWidget) == 0x000318, "Wrong size on UGameOverlayWidget");
static_assert(offsetof(UGameOverlayWidget, ChatWidget) == 0x000260, "Member 'UGameOverlayWidget::ChatWidget' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, InputHelpWidget) == 0x000268, "Member 'UGameOverlayWidget::InputHelpWidget' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, MatchTimerWidget) == 0x000270, "Member 'UGameOverlayWidget::MatchTimerWidget' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, MatchStateWidget) == 0x000278, "Member 'UGameOverlayWidget::MatchStateWidget' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, TeamScoreWidgets) == 0x000280, "Member 'UGameOverlayWidget::TeamScoreWidgets' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, HUDNotificationWidgets) == 0x000290, "Member 'UGameOverlayWidget::HUDNotificationWidgets' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, SpectatorPawn) == 0x0002A8, "Member 'UGameOverlayWidget::SpectatorPawn' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, ViewedCharacter) == 0x0002B0, "Member 'UGameOverlayWidget::ViewedCharacter' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, BrickEditor) == 0x0002C0, "Member 'UGameOverlayWidget::BrickEditor' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, HighPingIndicator) == 0x0002D8, "Member 'UGameOverlayWidget::HighPingIndicator' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, InputHelpClass) == 0x0002E0, "Member 'UGameOverlayWidget::InputHelpClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, HUDNotificationClass) == 0x0002E8, "Member 'UGameOverlayWidget::HUDNotificationClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, MatchTimerWidgetClass) == 0x0002F0, "Member 'UGameOverlayWidget::MatchTimerWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, MatchStateWidgetClass) == 0x0002F8, "Member 'UGameOverlayWidget::MatchStateWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, TeamScoreWidgetClass) == 0x000300, "Member 'UGameOverlayWidget::TeamScoreWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, ChatWidgetClass) == 0x000308, "Member 'UGameOverlayWidget::ChatWidgetClass' has a wrong offset!");
static_assert(offsetof(UGameOverlayWidget, MinimalHUDMaxMatchTimerRemaining) == 0x000310, "Member 'UGameOverlayWidget::MinimalHUDMaxMatchTimerRemaining' has a wrong offset!");

// Class BrickRigs.PropellerBrickStaticInfo
// 0x0008 (0x0170 - 0x0168)
class UPropellerBrickStaticInfo : public UBrickStaticInfo
{
public:
	float                                         PropellerRadius;                                   // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thrust;                                            // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropellerBrickStaticInfo">();
	}
	static class UPropellerBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropellerBrickStaticInfo>();
	}
};
static_assert(alignof(UPropellerBrickStaticInfo) == 0x000008, "Wrong alignment on UPropellerBrickStaticInfo");
static_assert(sizeof(UPropellerBrickStaticInfo) == 0x000170, "Wrong size on UPropellerBrickStaticInfo");
static_assert(offsetof(UPropellerBrickStaticInfo, PropellerRadius) == 0x000168, "Member 'UPropellerBrickStaticInfo::PropellerRadius' has a wrong offset!");
static_assert(offsetof(UPropellerBrickStaticInfo, Thrust) == 0x00016C, "Member 'UPropellerBrickStaticInfo::Thrust' has a wrong offset!");

// Class BrickRigs.Garage
// 0x0080 (0x0340 - 0x02C0)
class AGarage : public ABrickBuilding
{
public:
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDIconComponent*                      HUDIconComponent;                                  // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionComponent*                  InteractionComponent;                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        PlayerSpawnPoint;                                  // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FHUDIconProperties                     HUDIconProperties;                                 // 0x02E0(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVector                                VehicleSpawnExtent;                                // 0x0310(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                VehicleSpawnOffset;                                // 0x031C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               VehicleSpawnRotation;                              // 0x0328(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0xC];                                      // 0x0334(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_EnterEditor(class ABrickPlayerController* PC);
	void Interact_Inventory(class ABrickPlayerController* PC);
	void Interact_SpawnVehicle(class ABrickPlayerController* PC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Garage">();
	}
	static class AGarage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGarage>();
	}
};
static_assert(alignof(AGarage) == 0x000010, "Wrong alignment on AGarage");
static_assert(sizeof(AGarage) == 0x000340, "Wrong size on AGarage");
static_assert(offsetof(AGarage, HUDIconComponent) == 0x0002C8, "Member 'AGarage::HUDIconComponent' has a wrong offset!");
static_assert(offsetof(AGarage, InteractionComponent) == 0x0002D0, "Member 'AGarage::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AGarage, PlayerSpawnPoint) == 0x0002D8, "Member 'AGarage::PlayerSpawnPoint' has a wrong offset!");
static_assert(offsetof(AGarage, HUDIconProperties) == 0x0002E0, "Member 'AGarage::HUDIconProperties' has a wrong offset!");
static_assert(offsetof(AGarage, VehicleSpawnExtent) == 0x000310, "Member 'AGarage::VehicleSpawnExtent' has a wrong offset!");
static_assert(offsetof(AGarage, VehicleSpawnOffset) == 0x00031C, "Member 'AGarage::VehicleSpawnOffset' has a wrong offset!");
static_assert(offsetof(AGarage, VehicleSpawnRotation) == 0x000328, "Member 'AGarage::VehicleSpawnRotation' has a wrong offset!");

// Class BrickRigs.GenericPropertyWidget
// 0x0008 (0x0288 - 0x0280)
class UGenericPropertyWidget : public UPropertyWidget
{
public:
	class UBrickTextBoxWidget*                    TextBox;                                           // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnTextChanged(const class FText& Text, EValueChangedEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPropertyWidget">();
	}
	static class UGenericPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPropertyWidget>();
	}
};
static_assert(alignof(UGenericPropertyWidget) == 0x000008, "Wrong alignment on UGenericPropertyWidget");
static_assert(sizeof(UGenericPropertyWidget) == 0x000288, "Wrong size on UGenericPropertyWidget");
static_assert(offsetof(UGenericPropertyWidget, TextBox) == 0x000280, "Member 'UGenericPropertyWidget::TextBox' has a wrong offset!");

// Class BrickRigs.GrenadeStaticInfo
// 0x0000 (0x0480 - 0x0480)
class UGrenadeStaticInfo : public UExplosiveItemStaticInfo
{
public:
	float                                         FuseDelay;                                         // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeStaticInfo">();
	}
	static class UGrenadeStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrenadeStaticInfo>();
	}
};
static_assert(alignof(UGrenadeStaticInfo) == 0x000010, "Wrong alignment on UGrenadeStaticInfo");
static_assert(sizeof(UGrenadeStaticInfo) == 0x000480, "Wrong size on UGrenadeStaticInfo");
static_assert(offsetof(UGrenadeStaticInfo, FuseDelay) == 0x000478, "Member 'UGrenadeStaticInfo::FuseDelay' has a wrong offset!");

// Class BrickRigs.ReuploadPopupWidget
// 0x0030 (0x02C8 - 0x0298)
class UReuploadPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ViewOriginalAuthorInBrowser();
	void ViewOriginalItemInBrowser();

	bool GetOriginalAuthorName(class FText* OutName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReuploadPopupWidget">();
	}
	static class UReuploadPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReuploadPopupWidget>();
	}
};
static_assert(alignof(UReuploadPopupWidget) == 0x000008, "Wrong alignment on UReuploadPopupWidget");
static_assert(sizeof(UReuploadPopupWidget) == 0x0002C8, "Wrong size on UReuploadPopupWidget");

// Class BrickRigs.GrenadeAnimInstance
// 0x0000 (0x02C0 - 0x02C0)
class UGrenadeAnimInstance final : public UItemAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GrenadeAnimInstance">();
	}
	static class UGrenadeAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGrenadeAnimInstance>();
	}
};
static_assert(alignof(UGrenadeAnimInstance) == 0x000010, "Wrong alignment on UGrenadeAnimInstance");
static_assert(sizeof(UGrenadeAnimInstance) == 0x0002C0, "Wrong size on UGrenadeAnimInstance");

// Class BrickRigs.Grenade
// 0x0008 (0x0280 - 0x0278)
class AGrenade : public AExplosiveItem
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Grenade">();
	}
	static class AGrenade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGrenade>();
	}
};
static_assert(alignof(AGrenade) == 0x000008, "Wrong alignment on AGrenade");
static_assert(sizeof(AGrenade) == 0x000280, "Wrong size on AGrenade");

// Class BrickRigs.LauncherBrickStaticInfo
// 0x0000 (0x02A0 - 0x02A0)
class ULauncherBrickStaticInfo : public UGunBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LauncherBrickStaticInfo">();
	}
	static class ULauncherBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULauncherBrickStaticInfo>();
	}
};
static_assert(alignof(ULauncherBrickStaticInfo) == 0x000010, "Wrong alignment on ULauncherBrickStaticInfo");
static_assert(sizeof(ULauncherBrickStaticInfo) == 0x0002A0, "Wrong size on ULauncherBrickStaticInfo");

// Class BrickRigs.GunBrick
// 0x00A8 (0x01A0 - 0x00F8)
class alignas(0x10) UGunBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirearmComponent*                      FirearmComponent;                                  // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ShellEmitterPtr;                                   // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x38];                                     // 0x0130(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	EAmmoType                                     AmmoType;                                          // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_191[0xF];                                      // 0x0191(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunBrick">();
	}
	static class UGunBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunBrick>();
	}
};
static_assert(alignof(UGunBrick) == 0x000010, "Wrong alignment on UGunBrick");
static_assert(sizeof(UGunBrick) == 0x0001A0, "Wrong size on UGunBrick");
static_assert(offsetof(UGunBrick, FirearmComponent) == 0x000110, "Member 'UGunBrick::FirearmComponent' has a wrong offset!");
static_assert(offsetof(UGunBrick, ShellEmitterPtr) == 0x000128, "Member 'UGunBrick::ShellEmitterPtr' has a wrong offset!");
static_assert(offsetof(UGunBrick, InputChannel) == 0x000168, "Member 'UGunBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UGunBrick, AmmoType) == 0x000190, "Member 'UGunBrick::AmmoType' has a wrong offset!");

// Class BrickRigs.HandleBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UHandleBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandleBrickStaticInfo">();
	}
	static class UHandleBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHandleBrickStaticInfo>();
	}
};
static_assert(alignof(UHandleBrickStaticInfo) == 0x000008, "Wrong alignment on UHandleBrickStaticInfo");
static_assert(sizeof(UHandleBrickStaticInfo) == 0x000168, "Wrong size on UHandleBrickStaticInfo");

// Class BrickRigs.RestrictedAreaWidget
// 0x0018 (0x0278 - 0x0260)
class URestrictedAreaWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadedOut();
	void PlayFadeInAnim();
	void PlayFadeOutAnim();
	void UpdateTimerRemaining(float TimeRemaining);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedAreaWidget">();
	}
	static class URestrictedAreaWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedAreaWidget>();
	}
};
static_assert(alignof(URestrictedAreaWidget) == 0x000008, "Wrong alignment on URestrictedAreaWidget");
static_assert(sizeof(URestrictedAreaWidget) == 0x000278, "Wrong size on URestrictedAreaWidget");

// Class BrickRigs.HealthBarWidget
// 0x0018 (0x0278 - 0x0260)
class UHealthBarWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x14];                                     // 0x0260(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HealthInterpSpeed;                                 // 0x0274(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHUDVisibilityChanged(EHUDVisibility NewVisibility);
	void UpdateCanBeDamaged(bool bNewCanBeDamaged);
	void UpdateHealingState(ECharacterHealingState NewState);
	void UpdateHealth(float NewHealth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthBarWidget">();
	}
	static class UHealthBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthBarWidget>();
	}
};
static_assert(alignof(UHealthBarWidget) == 0x000008, "Wrong alignment on UHealthBarWidget");
static_assert(sizeof(UHealthBarWidget) == 0x000278, "Wrong size on UHealthBarWidget");
static_assert(offsetof(UHealthBarWidget, HealthInterpSpeed) == 0x000274, "Member 'UHealthBarWidget::HealthInterpSpeed' has a wrong offset!");

// Class BrickRigs.MenuSettingsPageWidget
// 0x0028 (0x0298 - 0x0270)
class UMenuSettingsPageWidget : public UMenuPageWidget
{
public:
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SettingsCategories;                                // 0x0278(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AddProperties();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuSettingsPageWidget">();
	}
	static class UMenuSettingsPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuSettingsPageWidget>();
	}
};
static_assert(alignof(UMenuSettingsPageWidget) == 0x000008, "Wrong alignment on UMenuSettingsPageWidget");
static_assert(sizeof(UMenuSettingsPageWidget) == 0x000298, "Wrong size on UMenuSettingsPageWidget");
static_assert(offsetof(UMenuSettingsPageWidget, PropertiesPanel) == 0x000270, "Member 'UMenuSettingsPageWidget::PropertiesPanel' has a wrong offset!");
static_assert(offsetof(UMenuSettingsPageWidget, SettingsCategories) == 0x000278, "Member 'UMenuSettingsPageWidget::SettingsCategories' has a wrong offset!");

// Class BrickRigs.ScoreboardPlayerWidget
// 0x0090 (0x02F0 - 0x0260)
class UScoreboardPlayerWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickPlayerState*                      PlayerState;                                       // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x20];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        PositionTextBlock;                                 // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        KillsTextBlock;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        DeathsTextBlock;                                   // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        ScoreTextBlock;                                    // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingIndicatorWidget*                   PingIndicator;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClicked();
	void UpdateButtonStyle(bool bNewSelected, bool bIsLocalPlayer, ETeamAttitude TeamAttitude);
	void UpdateIsAdmin(bool bIsAdmin);
	void UpdateIsAlive(bool bIsAlive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreboardPlayerWidget">();
	}
	static class UScoreboardPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoreboardPlayerWidget>();
	}
};
static_assert(alignof(UScoreboardPlayerWidget) == 0x000008, "Wrong alignment on UScoreboardPlayerWidget");
static_assert(sizeof(UScoreboardPlayerWidget) == 0x0002F0, "Wrong size on UScoreboardPlayerWidget");
static_assert(offsetof(UScoreboardPlayerWidget, PlayerState) == 0x000270, "Member 'UScoreboardPlayerWidget::PlayerState' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, Button) == 0x000298, "Member 'UScoreboardPlayerWidget::Button' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, PositionTextBlock) == 0x0002A0, "Member 'UScoreboardPlayerWidget::PositionTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, NameTextBlock) == 0x0002A8, "Member 'UScoreboardPlayerWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, KillsTextBlock) == 0x0002B0, "Member 'UScoreboardPlayerWidget::KillsTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, DeathsTextBlock) == 0x0002B8, "Member 'UScoreboardPlayerWidget::DeathsTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, ScoreTextBlock) == 0x0002C0, "Member 'UScoreboardPlayerWidget::ScoreTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardPlayerWidget, PingIndicator) == 0x0002C8, "Member 'UScoreboardPlayerWidget::PingIndicator' has a wrong offset!");

// Class BrickRigs.HostGamePageWidget
// 0x0000 (0x0298 - 0x0298)
class UHostGamePageWidget : public UMenuSettingsPageWidget
{
public:
	void StartGame();
	void UpdatePlayButton(bool bCanPlay, bool bIsOnline);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HostGamePageWidget">();
	}
	static class UHostGamePageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHostGamePageWidget>();
	}
};
static_assert(alignof(UHostGamePageWidget) == 0x000008, "Wrong alignment on UHostGamePageWidget");
static_assert(sizeof(UHostGamePageWidget) == 0x000298, "Wrong size on UHostGamePageWidget");

// Class BrickRigs.HUDIconPanelWidget
// 0x0098 (0x02F8 - 0x0260)
class UHUDIconPanelWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x68];                                     // 0x0260(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHUDIconContainerWidget>    IconContainerWidgetClass;                          // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInteractionWidget>         InteractionWidgetClass;                            // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDIconDomain                                IconDomain;                                        // 0x02D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x1F];                                     // 0x02D9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDIconPanelWidget">();
	}
	static class UHUDIconPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDIconPanelWidget>();
	}
};
static_assert(alignof(UHUDIconPanelWidget) == 0x000008, "Wrong alignment on UHUDIconPanelWidget");
static_assert(sizeof(UHUDIconPanelWidget) == 0x0002F8, "Wrong size on UHUDIconPanelWidget");
static_assert(offsetof(UHUDIconPanelWidget, IconContainerWidgetClass) == 0x0002C8, "Member 'UHUDIconPanelWidget::IconContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UHUDIconPanelWidget, InteractionWidgetClass) == 0x0002D0, "Member 'UHUDIconPanelWidget::InteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UHUDIconPanelWidget, IconDomain) == 0x0002D8, "Member 'UHUDIconPanelWidget::IconDomain' has a wrong offset!");

// Class BrickRigs.ReloadAction
// 0x0008 (0x00A0 - 0x0098)
class UReloadAction final : public UItemAction
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReloadAction">();
	}
	static class UReloadAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReloadAction>();
	}
};
static_assert(alignof(UReloadAction) == 0x000008, "Wrong alignment on UReloadAction");
static_assert(sizeof(UReloadAction) == 0x0000A0, "Wrong size on UReloadAction");

// Class BrickRigs.HUDIconCanvasWidget
// 0x0018 (0x0310 - 0x02F8)
class UHUDIconCanvasWidget : public UHUDIconPanelWidget
{
public:
	class UInteractionWidget*                     InteractionWidget;                                 // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           MainCanvasPanel;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         IconScaleRange;                                    // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDIconCanvasWidget">();
	}
	static class UHUDIconCanvasWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDIconCanvasWidget>();
	}
};
static_assert(alignof(UHUDIconCanvasWidget) == 0x000008, "Wrong alignment on UHUDIconCanvasWidget");
static_assert(sizeof(UHUDIconCanvasWidget) == 0x000310, "Wrong size on UHUDIconCanvasWidget");
static_assert(offsetof(UHUDIconCanvasWidget, InteractionWidget) == 0x0002F8, "Member 'UHUDIconCanvasWidget::InteractionWidget' has a wrong offset!");
static_assert(offsetof(UHUDIconCanvasWidget, MainCanvasPanel) == 0x000300, "Member 'UHUDIconCanvasWidget::MainCanvasPanel' has a wrong offset!");
static_assert(offsetof(UHUDIconCanvasWidget, IconScaleRange) == 0x000308, "Member 'UHUDIconCanvasWidget::IconScaleRange' has a wrong offset!");

// Class BrickRigs.HUDIconComponent
// 0x0088 (0x0138 - 0x00B0)
class UHUDIconComponent : public UActorComponent
{
public:
	struct FHUDIconProperties                     HUDIconProperties;                                 // 0x00B0(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTestLineOfSight;                                  // 0x0100(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x37];                                     // 0x0101(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FInteractionOption MakeAxisInteractionOption(const class FText& DisplayText, bool bIsEnabled, TDelegate<void(class ABrickPlayerController* InPC, float Val)> OnInteractionAxis);
	static struct FInteractionOption MakeInteractionOption(const class FText& DisplayText, bool bIsEnabled, TDelegate<void(class ABrickPlayerController* InPC)> OnInteraction);

	void Interact_PlaceMarker(class ABrickPlayerController* PC);
	void Interact_Spawn(class ABrickPlayerController* PC);
	void SetGetInteractionOptionsDelegate(TDelegate<void(class ABrickPlayerController* PC, struct FInteractionOptions* OutOptions)> Delegate);
	void SetGetMaxDrawDistDelegate(TDelegate<void(class ABrickPlayerController* PC)> Delegate);
	void SetIconLocation(const struct FVector& NewLocation);
	void SetIconLocationDelegate(TDelegate<void()> Delegate);
	void SetShouldIconBeVisibleDelegate(TDelegate<void(class ABrickPlayerController* PC, const struct FHUDIconContext& Context)> Delegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDIconComponent">();
	}
	static class UHUDIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDIconComponent>();
	}
};
static_assert(alignof(UHUDIconComponent) == 0x000008, "Wrong alignment on UHUDIconComponent");
static_assert(sizeof(UHUDIconComponent) == 0x000138, "Wrong size on UHUDIconComponent");
static_assert(offsetof(UHUDIconComponent, HUDIconProperties) == 0x0000B0, "Member 'UHUDIconComponent::HUDIconProperties' has a wrong offset!");
static_assert(offsetof(UHUDIconComponent, bTestLineOfSight) == 0x000100, "Member 'UHUDIconComponent::bTestLineOfSight' has a wrong offset!");

// Class BrickRigs.SandboxGameMode
// 0x0000 (0x03F8 - 0x03F8)
class ASandboxGameMode : public ABrickGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandboxGameMode">();
	}
	static class ASandboxGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASandboxGameMode>();
	}
};
static_assert(alignof(ASandboxGameMode) == 0x000008, "Wrong alignment on ASandboxGameMode");
static_assert(sizeof(ASandboxGameMode) == 0x0003F8, "Wrong size on ASandboxGameMode");

// Class BrickRigs.HUDIconContainerWidget
// 0x0070 (0x02D0 - 0x0260)
class UHUDIconContainerWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDIconWidget*                         IconWidget;                                        // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMapCrosshairWidget*>            CrosshairWidgets;                                  // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x20];                                     // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     SpawnButton;                                       // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxNameDrawDist;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCrosshairWidgets(const TArray<class UMapCrosshairWidget*>& Widgets);
	void AddIconWidget(class UHUDIconWidget* Widget);
	void AddInteractionWidget(class UInteractionWidget* Widget);
	void OnSpawnButtonClicked();
	void OnSpawnButtonDoubleClicked();
	void OnUpdateButtonContentStyle(EBrickUIColorStyle InColorStyle, EBrickUIStyleState InContentStyleState);
	void UpdateContainerStyle(bool bNewSelected, bool bNewCanSpawn, EBrickUIColorStyle NewColorStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDIconContainerWidget">();
	}
	static class UHUDIconContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDIconContainerWidget>();
	}
};
static_assert(alignof(UHUDIconContainerWidget) == 0x000008, "Wrong alignment on UHUDIconContainerWidget");
static_assert(sizeof(UHUDIconContainerWidget) == 0x0002D0, "Wrong size on UHUDIconContainerWidget");
static_assert(offsetof(UHUDIconContainerWidget, IconWidget) == 0x000280, "Member 'UHUDIconContainerWidget::IconWidget' has a wrong offset!");
static_assert(offsetof(UHUDIconContainerWidget, CrosshairWidgets) == 0x000288, "Member 'UHUDIconContainerWidget::CrosshairWidgets' has a wrong offset!");
static_assert(offsetof(UHUDIconContainerWidget, SpawnButton) == 0x0002B8, "Member 'UHUDIconContainerWidget::SpawnButton' has a wrong offset!");
static_assert(offsetof(UHUDIconContainerWidget, NameTextBlock) == 0x0002C0, "Member 'UHUDIconContainerWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UHUDIconContainerWidget, MaxNameDrawDist) == 0x0002C8, "Member 'UHUDIconContainerWidget::MaxNameDrawDist' has a wrong offset!");

// Class BrickRigs.HUDNotificationWidget
// 0x0040 (0x02A0 - 0x0260)
class UHUDNotificationWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBlock*                        TextBlock;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            IconImage;                                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            ThumbnailImage;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotificationDisplayTime;                           // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeNotification(const struct FBrickUIIconSlot& InIconSlot, const class FText& InText, EBrickUIColorStyle InColorStyle);
	void OnFadedOut();
	void PlayFadeInAnim();
	void PlayFadeOutAnim();
	void UpdateIsThumbnailNotification(bool bNewIsThumbnail);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDNotificationWidget">();
	}
	static class UHUDNotificationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDNotificationWidget>();
	}
};
static_assert(alignof(UHUDNotificationWidget) == 0x000008, "Wrong alignment on UHUDNotificationWidget");
static_assert(sizeof(UHUDNotificationWidget) == 0x0002A0, "Wrong size on UHUDNotificationWidget");
static_assert(offsetof(UHUDNotificationWidget, TextBlock) == 0x000280, "Member 'UHUDNotificationWidget::TextBlock' has a wrong offset!");
static_assert(offsetof(UHUDNotificationWidget, IconImage) == 0x000288, "Member 'UHUDNotificationWidget::IconImage' has a wrong offset!");
static_assert(offsetof(UHUDNotificationWidget, ThumbnailImage) == 0x000290, "Member 'UHUDNotificationWidget::ThumbnailImage' has a wrong offset!");
static_assert(offsetof(UHUDNotificationWidget, NotificationDisplayTime) == 0x000298, "Member 'UHUDNotificationWidget::NotificationDisplayTime' has a wrong offset!");

// Class BrickRigs.SensorBrickBase
// 0x0038 (0x0158 - 0x0120)
class USensorBrickBase : public UScalableBrick
{
public:
	struct FSensorOutputChannel                   OutputChannel;                                     // 0x0120(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SensorBrickBase">();
	}
	static class USensorBrickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USensorBrickBase>();
	}
};
static_assert(alignof(USensorBrickBase) == 0x000008, "Wrong alignment on USensorBrickBase");
static_assert(sizeof(USensorBrickBase) == 0x000158, "Wrong size on USensorBrickBase");
static_assert(offsetof(USensorBrickBase, OutputChannel) == 0x000120, "Member 'USensorBrickBase::OutputChannel' has a wrong offset!");

// Class BrickRigs.HUDWidgetInterface
// 0x0000 (0x0000 - 0x0000)
class IHUDWidgetInterface final
{
public:
	bool AddGameOverlayWidget(class UGameOverlayWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDWidgetInterface">();
	}
	static class IHUDWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHUDWidgetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHUDWidgetInterface) == 0x000001, "Wrong alignment on IHUDWidgetInterface");
static_assert(sizeof(IHUDWidgetInterface) == 0x000001, "Wrong size on IHUDWidgetInterface");

// Class BrickRigs.HurtMarkerWidget
// 0x0010 (0x0270 - 0x0260)
class UHurtMarkerWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayHurtMarkerAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HurtMarkerWidget">();
	}
	static class UHurtMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHurtMarkerWidget>();
	}
};
static_assert(alignof(UHurtMarkerWidget) == 0x000008, "Wrong alignment on UHurtMarkerWidget");
static_assert(sizeof(UHurtMarkerWidget) == 0x000270, "Wrong size on UHurtMarkerWidget");

// Class BrickRigs.ScoreboardTeamWidget
// 0x0050 (0x02B0 - 0x0260)
class UScoreboardTeamWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTeam*                             BrickTeam;                                         // 0x0268(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UScoreboardPlayerWidget*>        PlayerWidgets;                                     // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBlock*                        TeamNameTextBlock;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        ScoreTextBlock;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickGridPanel*                        PlayersPanel;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumPlayersPerRow;                                  // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SortPlayersDelay;                                  // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void JoinTeam();
	void UpdateCanEverJoinTeam(bool bCanJoin);
	void UpdateCanJoinTeam(bool bCanJoin);
	void UpdateTeamAttitude(bool bIsOwnTeam, ETeamAttitude NewAttitude);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreboardTeamWidget">();
	}
	static class UScoreboardTeamWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoreboardTeamWidget>();
	}
};
static_assert(alignof(UScoreboardTeamWidget) == 0x000008, "Wrong alignment on UScoreboardTeamWidget");
static_assert(sizeof(UScoreboardTeamWidget) == 0x0002B0, "Wrong size on UScoreboardTeamWidget");
static_assert(offsetof(UScoreboardTeamWidget, BrickTeam) == 0x000268, "Member 'UScoreboardTeamWidget::BrickTeam' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, PlayerWidgets) == 0x000270, "Member 'UScoreboardTeamWidget::PlayerWidgets' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, TeamNameTextBlock) == 0x000290, "Member 'UScoreboardTeamWidget::TeamNameTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, ScoreTextBlock) == 0x000298, "Member 'UScoreboardTeamWidget::ScoreTextBlock' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, PlayersPanel) == 0x0002A0, "Member 'UScoreboardTeamWidget::PlayersPanel' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, NumPlayersPerRow) == 0x0002A8, "Member 'UScoreboardTeamWidget::NumPlayersPerRow' has a wrong offset!");
static_assert(offsetof(UScoreboardTeamWidget, SortPlayersDelay) == 0x0002AC, "Member 'UScoreboardTeamWidget::SortPlayersDelay' has a wrong offset!");

// Class BrickRigs.TrackWheelBrickStaticInfo
// 0x0000 (0x0188 - 0x0188)
class UTrackWheelBrickStaticInfo : public UWheelBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackWheelBrickStaticInfo">();
	}
	static class UTrackWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackWheelBrickStaticInfo>();
	}
};
static_assert(alignof(UTrackWheelBrickStaticInfo) == 0x000008, "Wrong alignment on UTrackWheelBrickStaticInfo");
static_assert(sizeof(UTrackWheelBrickStaticInfo) == 0x000188, "Wrong size on UTrackWheelBrickStaticInfo");

// Class BrickRigs.IdlerWheelBrickStaticInfo
// 0x0000 (0x0188 - 0x0188)
class UIdlerWheelBrickStaticInfo : public UTrackWheelBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdlerWheelBrickStaticInfo">();
	}
	static class UIdlerWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdlerWheelBrickStaticInfo>();
	}
};
static_assert(alignof(UIdlerWheelBrickStaticInfo) == 0x000008, "Wrong alignment on UIdlerWheelBrickStaticInfo");
static_assert(sizeof(UIdlerWheelBrickStaticInfo) == 0x000188, "Wrong size on UIdlerWheelBrickStaticInfo");

// Class BrickRigs.RotorBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class URotorBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotorBrickStaticInfo">();
	}
	static class URotorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URotorBrickStaticInfo>();
	}
};
static_assert(alignof(URotorBrickStaticInfo) == 0x000008, "Wrong alignment on URotorBrickStaticInfo");
static_assert(sizeof(URotorBrickStaticInfo) == 0x000168, "Wrong size on URotorBrickStaticInfo");

// Class BrickRigs.TrackWheelBrick
// 0x0000 (0x0118 - 0x0118)
class UTrackWheelBrick : public UWheelBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrackWheelBrick">();
	}
	static class UTrackWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrackWheelBrick>();
	}
};
static_assert(alignof(UTrackWheelBrick) == 0x000008, "Wrong alignment on UTrackWheelBrick");
static_assert(sizeof(UTrackWheelBrick) == 0x000118, "Wrong size on UTrackWheelBrick");

// Class BrickRigs.IdlerWheelBrick
// 0x0010 (0x0128 - 0x0118)
class UIdlerWheelBrick final : public UTrackWheelBrick
{
public:
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdlerWheelBrick">();
	}
	static class UIdlerWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdlerWheelBrick>();
	}
};
static_assert(alignof(UIdlerWheelBrick) == 0x000008, "Wrong alignment on UIdlerWheelBrick");
static_assert(sizeof(UIdlerWheelBrick) == 0x000128, "Wrong size on UIdlerWheelBrick");

// Class BrickRigs.SensorBrickBaseStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class USensorBrickBaseStaticInfo : public UScalableBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SensorBrickBaseStaticInfo">();
	}
	static class USensorBrickBaseStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USensorBrickBaseStaticInfo>();
	}
};
static_assert(alignof(USensorBrickBaseStaticInfo) == 0x000008, "Wrong alignment on USensorBrickBaseStaticInfo");
static_assert(sizeof(USensorBrickBaseStaticInfo) == 0x0001A0, "Wrong size on USensorBrickBaseStaticInfo");

// Class BrickRigs.ImageBrickStaticInfo
// 0x0010 (0x01B0 - 0x01A0)
class UImageBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	float                                         ImageMargin;                                       // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A4[0x4];                                      // 0x01A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ImageMesh;                                         // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageBrickStaticInfo">();
	}
	static class UImageBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageBrickStaticInfo>();
	}
};
static_assert(alignof(UImageBrickStaticInfo) == 0x000008, "Wrong alignment on UImageBrickStaticInfo");
static_assert(sizeof(UImageBrickStaticInfo) == 0x0001B0, "Wrong size on UImageBrickStaticInfo");
static_assert(offsetof(UImageBrickStaticInfo, ImageMargin) == 0x0001A0, "Member 'UImageBrickStaticInfo::ImageMargin' has a wrong offset!");
static_assert(offsetof(UImageBrickStaticInfo, ImageMesh) == 0x0001A8, "Member 'UImageBrickStaticInfo::ImageMesh' has a wrong offset!");

// Class BrickRigs.ImageBrick
// 0x0020 (0x0140 - 0x0120)
class UImageBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickDecal*                            Image;                                             // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 ImageColor;                                        // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageBrick">();
	}
	static class UImageBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageBrick>();
	}
};
static_assert(alignof(UImageBrick) == 0x000008, "Wrong alignment on UImageBrick");
static_assert(sizeof(UImageBrick) == 0x000140, "Wrong size on UImageBrick");
static_assert(offsetof(UImageBrick, Image) == 0x000130, "Member 'UImageBrick::Image' has a wrong offset!");
static_assert(offsetof(UImageBrick, ImageColor) == 0x000138, "Member 'UImageBrick::ImageColor' has a wrong offset!");

// Class BrickRigs.ImpactDecalComponent
// 0x0010 (0x0250 - 0x0240)
class UImpactDecalComponent final : public UDecalComponent
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactDecalComponent">();
	}
	static class UImpactDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpactDecalComponent>();
	}
};
static_assert(alignof(UImpactDecalComponent) == 0x000010, "Wrong alignment on UImpactDecalComponent");
static_assert(sizeof(UImpactDecalComponent) == 0x000250, "Wrong size on UImpactDecalComponent");

// Class BrickRigs.ServerBrowserWidget
// 0x0038 (0x02A8 - 0x0270)
class UServerBrowserWidget : public UMenuPageWidget
{
public:
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPagedListWidget*                       PagedList;                                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESearchSessionType                            SearchSessionType;                                 // 0x0290(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EServerSortMethod                             ServerSortMethod;                                  // 0x0291(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchPrivateServers;                             // 0x0292(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSearchServersWithDifferentMods;                   // 0x0293(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerSearchText;                                  // 0x0298(0x0010)(ZeroConstructor, Config, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void JoinServer();
	void OnListEntrySelected(class UPagedListEntryWidget* Widget, bool bDoubleClick);
	void OnLoadListPage(int32 NewPage);
	void RefreshServers();
	void UpdateCanJoin(bool bCanJoin);
	void UpdateCanRefresh(bool bCanRefresh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerBrowserWidget">();
	}
	static class UServerBrowserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerBrowserWidget>();
	}
};
static_assert(alignof(UServerBrowserWidget) == 0x000008, "Wrong alignment on UServerBrowserWidget");
static_assert(sizeof(UServerBrowserWidget) == 0x0002A8, "Wrong size on UServerBrowserWidget");
static_assert(offsetof(UServerBrowserWidget, PagedList) == 0x000288, "Member 'UServerBrowserWidget::PagedList' has a wrong offset!");
static_assert(offsetof(UServerBrowserWidget, SearchSessionType) == 0x000290, "Member 'UServerBrowserWidget::SearchSessionType' has a wrong offset!");
static_assert(offsetof(UServerBrowserWidget, ServerSortMethod) == 0x000291, "Member 'UServerBrowserWidget::ServerSortMethod' has a wrong offset!");
static_assert(offsetof(UServerBrowserWidget, bSearchPrivateServers) == 0x000292, "Member 'UServerBrowserWidget::bSearchPrivateServers' has a wrong offset!");
static_assert(offsetof(UServerBrowserWidget, bSearchServersWithDifferentMods) == 0x000293, "Member 'UServerBrowserWidget::bSearchServersWithDifferentMods' has a wrong offset!");
static_assert(offsetof(UServerBrowserWidget, ServerSearchText) == 0x000298, "Member 'UServerBrowserWidget::ServerSearchText' has a wrong offset!");

// Class BrickRigs.InputActionCategoryWidget
// 0x0020 (0x0280 - 0x0260)
class UInputActionCategoryWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputCategory*                         InputCategory;                                     // 0x0270(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeCategory(const class FText& InCategoryName);
	void OpenCategory();
	void UpdateInputActionListMode(EInputActionListMode NewMode);
	void UpdateIsSelected(bool bNewSelected);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionCategoryWidget">();
	}
	static class UInputActionCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionCategoryWidget>();
	}
};
static_assert(alignof(UInputActionCategoryWidget) == 0x000008, "Wrong alignment on UInputActionCategoryWidget");
static_assert(sizeof(UInputActionCategoryWidget) == 0x000280, "Wrong size on UInputActionCategoryWidget");
static_assert(offsetof(UInputActionCategoryWidget, InputCategory) == 0x000270, "Member 'UInputActionCategoryWidget::InputCategory' has a wrong offset!");

// Class BrickRigs.InputActionListWidget
// 0x00F8 (0x0358 - 0x0260)
class UInputActionListWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputActionCategoryWidget*>     CategoryWidgets;                                   // 0x0268(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UInputActionWidget*>             ActionWidgets;                                     // 0x0278(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x68];                                     // 0x0288(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickGridPanel*                        MainGridPanel;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInputActionCategoryWidget> CategoryWidgetClass;                               // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UInputActionWidget>         ActionWidgetClass;                                 // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BindKeyPopupClass;                                 // 0x0308(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInputCategory*>                 InputCategories;                                   // 0x0330(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EInputActionListMode                          InputActionListMode;                               // 0x0340(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         QuickAccessDisplayTime;                            // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const class FName& ActionName, bool bReleased)> OnActionTriggeredDelegate; // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddActionWidget(class UInputActionWidget* Widget, int32 ActionIndex);
	void AddCategoryWidget(class UInputActionCategoryWidget* Widget, int32 CategoryIndex);
	void FadeIn();
	void UpdateInputActionListMode(EInputActionListMode NewMode);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionListWidget">();
	}
	static class UInputActionListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionListWidget>();
	}
};
static_assert(alignof(UInputActionListWidget) == 0x000008, "Wrong alignment on UInputActionListWidget");
static_assert(sizeof(UInputActionListWidget) == 0x000358, "Wrong size on UInputActionListWidget");
static_assert(offsetof(UInputActionListWidget, CategoryWidgets) == 0x000268, "Member 'UInputActionListWidget::CategoryWidgets' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, ActionWidgets) == 0x000278, "Member 'UInputActionListWidget::ActionWidgets' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, MainGridPanel) == 0x0002F0, "Member 'UInputActionListWidget::MainGridPanel' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, CategoryWidgetClass) == 0x0002F8, "Member 'UInputActionListWidget::CategoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, ActionWidgetClass) == 0x000300, "Member 'UInputActionListWidget::ActionWidgetClass' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, BindKeyPopupClass) == 0x000308, "Member 'UInputActionListWidget::BindKeyPopupClass' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, InputCategories) == 0x000330, "Member 'UInputActionListWidget::InputCategories' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, InputActionListMode) == 0x000340, "Member 'UInputActionListWidget::InputActionListMode' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, QuickAccessDisplayTime) == 0x000344, "Member 'UInputActionListWidget::QuickAccessDisplayTime' has a wrong offset!");
static_assert(offsetof(UInputActionListWidget, OnActionTriggeredDelegate) == 0x000348, "Member 'UInputActionListWidget::OnActionTriggeredDelegate' has a wrong offset!");

// Class BrickRigs.SeatBrickStaticInfo
// 0x0050 (0x01B8 - 0x0168)
class USeatBrickStaticInfo : public UBrickStaticInfo
{
public:
	struct FFloatInterval                         ViewPitchRange;                                    // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewPitchRangeItem;                                // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewYawRange;                                      // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ViewYawRangeItem;                                  // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterDamageScale;                              // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCharacterDamage;                                // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     EditorCharacterMaterial;                           // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CharacterIdleSequence;                             // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCapsuleHalfHeight;                        // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterIdleCameraSocketLocation;                 // 0x01A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumInventorySlots;                                 // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeatBrickStaticInfo">();
	}
	static class USeatBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeatBrickStaticInfo>();
	}
};
static_assert(alignof(USeatBrickStaticInfo) == 0x000008, "Wrong alignment on USeatBrickStaticInfo");
static_assert(sizeof(USeatBrickStaticInfo) == 0x0001B8, "Wrong size on USeatBrickStaticInfo");
static_assert(offsetof(USeatBrickStaticInfo, ViewPitchRange) == 0x000168, "Member 'USeatBrickStaticInfo::ViewPitchRange' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, ViewPitchRangeItem) == 0x000170, "Member 'USeatBrickStaticInfo::ViewPitchRangeItem' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, ViewYawRange) == 0x000178, "Member 'USeatBrickStaticInfo::ViewYawRange' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, ViewYawRangeItem) == 0x000180, "Member 'USeatBrickStaticInfo::ViewYawRangeItem' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, CharacterDamageScale) == 0x000188, "Member 'USeatBrickStaticInfo::CharacterDamageScale' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, MinCharacterDamage) == 0x00018C, "Member 'USeatBrickStaticInfo::MinCharacterDamage' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, EditorCharacterMaterial) == 0x000190, "Member 'USeatBrickStaticInfo::EditorCharacterMaterial' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, CharacterIdleSequence) == 0x000198, "Member 'USeatBrickStaticInfo::CharacterIdleSequence' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, CharacterCapsuleHalfHeight) == 0x0001A0, "Member 'USeatBrickStaticInfo::CharacterCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, CharacterIdleCameraSocketLocation) == 0x0001A4, "Member 'USeatBrickStaticInfo::CharacterIdleCameraSocketLocation' has a wrong offset!");
static_assert(offsetof(USeatBrickStaticInfo, NumInventorySlots) == 0x0001B0, "Member 'USeatBrickStaticInfo::NumInventorySlots' has a wrong offset!");

// Class BrickRigs.InputActionWidget
// 0x00D0 (0x0340 - 0x0270)
class UInputActionWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0xC0];                                     // 0x0270(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UControlHintWidget*                     ControlHintWidget;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnActionClicked();
	void OnActionPressed();
	void OnActionReleased();
	void RebindAction();
	void UpdateCanActionBeRebound(bool bInCanBeRebound);
	void UpdateDisplayInfo(const struct FDisplayInfo& InDisplayInfo);
	void UpdateInputActionListMode(EInputActionListMode NewMode);
	void UpdateIsActionEnabled(bool bInCanBeExecuted);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputActionWidget">();
	}
	static class UInputActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputActionWidget>();
	}
};
static_assert(alignof(UInputActionWidget) == 0x000008, "Wrong alignment on UInputActionWidget");
static_assert(sizeof(UInputActionWidget) == 0x000340, "Wrong size on UInputActionWidget");
static_assert(offsetof(UInputActionWidget, Button) == 0x000330, "Member 'UInputActionWidget::Button' has a wrong offset!");
static_assert(offsetof(UInputActionWidget, ControlHintWidget) == 0x000338, "Member 'UInputActionWidget::ControlHintWidget' has a wrong offset!");

// Class BrickRigs.InputCategory
// 0x0030 (0x0060 - 0x0030)
class UInputCategory final : public UDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDisplayInfo                           DisplayInfo;                                       // 0x0038(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputCategory">();
	}
	static class UInputCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputCategory>();
	}
};
static_assert(alignof(UInputCategory) == 0x000008, "Wrong alignment on UInputCategory");
static_assert(sizeof(UInputCategory) == 0x000060, "Wrong size on UInputCategory");
static_assert(offsetof(UInputCategory, DisplayInfo) == 0x000038, "Member 'UInputCategory::DisplayInfo' has a wrong offset!");

// Class BrickRigs.WearableStaticInfo
// 0x0010 (0x03A0 - 0x0390)
class UWearableStaticInfo : public UItemStaticInfo
{
public:
	EWearableTag                                  WearableType;                                      // 0x0390(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0xF];                                      // 0x0391(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WearableStaticInfo">();
	}
	static class UWearableStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWearableStaticInfo>();
	}
};
static_assert(alignof(UWearableStaticInfo) == 0x000010, "Wrong alignment on UWearableStaticInfo");
static_assert(sizeof(UWearableStaticInfo) == 0x0003A0, "Wrong size on UWearableStaticInfo");
static_assert(offsetof(UWearableStaticInfo, WearableType) == 0x000390, "Member 'UWearableStaticInfo::WearableType' has a wrong offset!");

// Class BrickRigs.InputChordWidget
// 0x0060 (0x02C0 - 0x0260)
class UInputChordWidget : public UUserWidget
{
public:
	TArray<class UInputKeyWidget*>                KeyWidgets;                                        // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUserWidget*>                    SpacerWidgets;                                     // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInputKeyWidget>            KeyWidgetClass;                                    // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                SpacerWidgetClass;                                 // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInputChord                            InputChord;                                        // 0x0298(0x0020)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowUnboundKey;                                   // 0x02B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddKeyWidget(class UInputKeyWidget* Widget);
	void AddSpacerWidget(class UUserWidget* Widget);
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetInputChord(const struct FInputChord& InInputChord, bool bShowAsGamepadKey);
	void SetShowUnboundKey(bool bShow);
	void SetStyleState(EBrickUIStyleState NewState);
	void UpdateSpacerColorStyleAndStyleState(class UUserWidget* Widget, EBrickUIColorStyle NewColorStyle, EBrickUIStyleState NewStyleState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputChordWidget">();
	}
	static class UInputChordWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputChordWidget>();
	}
};
static_assert(alignof(UInputChordWidget) == 0x000008, "Wrong alignment on UInputChordWidget");
static_assert(sizeof(UInputChordWidget) == 0x0002C0, "Wrong size on UInputChordWidget");
static_assert(offsetof(UInputChordWidget, KeyWidgets) == 0x000260, "Member 'UInputChordWidget::KeyWidgets' has a wrong offset!");
static_assert(offsetof(UInputChordWidget, SpacerWidgets) == 0x000270, "Member 'UInputChordWidget::SpacerWidgets' has a wrong offset!");
static_assert(offsetof(UInputChordWidget, KeyWidgetClass) == 0x000288, "Member 'UInputChordWidget::KeyWidgetClass' has a wrong offset!");
static_assert(offsetof(UInputChordWidget, SpacerWidgetClass) == 0x000290, "Member 'UInputChordWidget::SpacerWidgetClass' has a wrong offset!");
static_assert(offsetof(UInputChordWidget, InputChord) == 0x000298, "Member 'UInputChordWidget::InputChord' has a wrong offset!");
static_assert(offsetof(UInputChordWidget, bShowUnboundKey) == 0x0002B8, "Member 'UInputChordWidget::bShowUnboundKey' has a wrong offset!");

// Class BrickRigs.InputHelpWidget
// 0x0018 (0x0278 - 0x0260)
class UInputHelpWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputActionListWidget*                 ActionListWidget;                                  // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UGameOverlayWidget* GetGameOverlay() const;
	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputHelpWidget">();
	}
	static class UInputHelpWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputHelpWidget>();
	}
};
static_assert(alignof(UInputHelpWidget) == 0x000008, "Wrong alignment on UInputHelpWidget");
static_assert(sizeof(UInputHelpWidget) == 0x000278, "Wrong size on UInputHelpWidget");
static_assert(offsetof(UInputHelpWidget, ActionListWidget) == 0x000270, "Member 'UInputHelpWidget::ActionListWidget' has a wrong offset!");

// Class BrickRigs.SpectatorInputComponent
// 0x0008 (0x01D8 - 0x01D0)
class USpectatorInputComponent final : public UPawnInputComponent
{
public:
	class ABrickSpectatorPawn*                    SpectatorPawn;                                     // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void MoveForward(float Val);
	void MoveRight(float Val);
	void MoveUp(float Val);
	void OnPressedCaptureVehicleThumbnail();
	void OnPressedPlacePawn();
	void OnPressedShiftSpeed();
	void OnPressedSpawnDummy();
	void OnReleasedPlacePawn();
	void OnReleasedShiftSpeed();
	void OnReleasedSpawnDummy();
	void RotatePawnCW(float Val);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorInputComponent">();
	}
	static class USpectatorInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorInputComponent>();
	}
};
static_assert(alignof(USpectatorInputComponent) == 0x000008, "Wrong alignment on USpectatorInputComponent");
static_assert(sizeof(USpectatorInputComponent) == 0x0001D8, "Wrong size on USpectatorInputComponent");
static_assert(offsetof(USpectatorInputComponent, SpectatorPawn) == 0x0001D0, "Member 'USpectatorInputComponent::SpectatorPawn' has a wrong offset!");

// Class BrickRigs.InputKeyWidget
// 0x0028 (0x0288 - 0x0260)
class UInputKeyWidget : public UUserWidget
{
public:
	class UDataTable*                             KeyDisplayTable;                                   // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FKey                                   Key;                                               // 0x0268(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUsedAsModifier;                                 // 0x0280(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnboundRenderOpacity;                              // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetKey(const struct FKey& InKey, bool bInUsedAsModifier);
	void UpdateDisplayInfo(const struct FKeyDisplayTableRow& DisplayInfo, bool bIsGamepadKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputKeyWidget">();
	}
	static class UInputKeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputKeyWidget>();
	}
};
static_assert(alignof(UInputKeyWidget) == 0x000008, "Wrong alignment on UInputKeyWidget");
static_assert(sizeof(UInputKeyWidget) == 0x000288, "Wrong size on UInputKeyWidget");
static_assert(offsetof(UInputKeyWidget, KeyDisplayTable) == 0x000260, "Member 'UInputKeyWidget::KeyDisplayTable' has a wrong offset!");
static_assert(offsetof(UInputKeyWidget, Key) == 0x000268, "Member 'UInputKeyWidget::Key' has a wrong offset!");
static_assert(offsetof(UInputKeyWidget, bIsUsedAsModifier) == 0x000280, "Member 'UInputKeyWidget::bIsUsedAsModifier' has a wrong offset!");
static_assert(offsetof(UInputKeyWidget, UnboundRenderOpacity) == 0x000284, "Member 'UInputKeyWidget::UnboundRenderOpacity' has a wrong offset!");

// Class BrickRigs.InputMappingKeyWidget
// 0x0058 (0x02B8 - 0x0260)
class UInputMappingKeyWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x38];                                     // 0x0260(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputChordWidget*                      InputChordWidget;                                  // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClickedButton();
	void UpdateConflictedState(bool bNewConflicted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMappingKeyWidget">();
	}
	static class UInputMappingKeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMappingKeyWidget>();
	}
};
static_assert(alignof(UInputMappingKeyWidget) == 0x000008, "Wrong alignment on UInputMappingKeyWidget");
static_assert(sizeof(UInputMappingKeyWidget) == 0x0002B8, "Wrong size on UInputMappingKeyWidget");
static_assert(offsetof(UInputMappingKeyWidget, Button) == 0x000298, "Member 'UInputMappingKeyWidget::Button' has a wrong offset!");
static_assert(offsetof(UInputMappingKeyWidget, InputChordWidget) == 0x0002A0, "Member 'UInputMappingKeyWidget::InputChordWidget' has a wrong offset!");

// Class BrickRigs.WinchBrick
// 0x0098 (0x0190 - 0x00F8)
class UWinchBrick final : public UBrick
{
public:
	struct FWinchAttachTarget                     AttachTarget;                                      // 0x00F8(0x001C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         RepRopeLength;                                     // 0x0114(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x48];                                     // 0x0118(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         WinchSpeed;                                        // 0x0188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_AttachWinch(class ABrickPlayerController* OtherPC);
	void Interact_DetachWinch(class ABrickPlayerController* OtherPC);
	void OnRep_AttachTarget(const struct FWinchAttachTarget& PrevAttachTarget);
	void OnRep_RepRopeLength();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinchBrick">();
	}
	static class UWinchBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinchBrick>();
	}
};
static_assert(alignof(UWinchBrick) == 0x000008, "Wrong alignment on UWinchBrick");
static_assert(sizeof(UWinchBrick) == 0x000190, "Wrong size on UWinchBrick");
static_assert(offsetof(UWinchBrick, AttachTarget) == 0x0000F8, "Member 'UWinchBrick::AttachTarget' has a wrong offset!");
static_assert(offsetof(UWinchBrick, RepRopeLength) == 0x000114, "Member 'UWinchBrick::RepRopeLength' has a wrong offset!");
static_assert(offsetof(UWinchBrick, InputChannel) == 0x000160, "Member 'UWinchBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UWinchBrick, WinchSpeed) == 0x000188, "Member 'UWinchBrick::WinchSpeed' has a wrong offset!");

// Class BrickRigs.InputMappingPropertyWidget
// 0x0050 (0x02D0 - 0x0280)
class UInputMappingPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingKeyWidget*>         KeyWidgets;                                        // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInputMappingKeyWidget>     KeyWidgetClass;                                    // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BindKeyPopupClass;                                 // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxInputMappings;                                  // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddKeyWidget(class UInputMappingKeyWidget* Widget, int32 Index_0);
	void AddMapping();
	void UpdateCanAddMapping(bool bCanAdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputMappingPropertyWidget">();
	}
	static class UInputMappingPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputMappingPropertyWidget>();
	}
};
static_assert(alignof(UInputMappingPropertyWidget) == 0x000008, "Wrong alignment on UInputMappingPropertyWidget");
static_assert(sizeof(UInputMappingPropertyWidget) == 0x0002D0, "Wrong size on UInputMappingPropertyWidget");
static_assert(offsetof(UInputMappingPropertyWidget, KeyWidgets) == 0x000288, "Member 'UInputMappingPropertyWidget::KeyWidgets' has a wrong offset!");
static_assert(offsetof(UInputMappingPropertyWidget, KeyWidgetClass) == 0x000298, "Member 'UInputMappingPropertyWidget::KeyWidgetClass' has a wrong offset!");
static_assert(offsetof(UInputMappingPropertyWidget, BindKeyPopupClass) == 0x0002A0, "Member 'UInputMappingPropertyWidget::BindKeyPopupClass' has a wrong offset!");
static_assert(offsetof(UInputMappingPropertyWidget, MaxInputMappings) == 0x0002C8, "Member 'UInputMappingPropertyWidget::MaxInputMappings' has a wrong offset!");

// Class BrickRigs.InputSettingsPageWidget
// 0x0000 (0x0298 - 0x0298)
class UInputSettingsPageWidget : public UMenuSettingsPageWidget
{
public:
	void RevertInputMappings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsPageWidget">();
	}
	static class UInputSettingsPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsPageWidget>();
	}
};
static_assert(alignof(UInputSettingsPageWidget) == 0x000008, "Wrong alignment on UInputSettingsPageWidget");
static_assert(sizeof(UInputSettingsPageWidget) == 0x000298, "Wrong size on UInputSettingsPageWidget");

// Class BrickRigs.ViewTargetInterface
// 0x0000 (0x0000 - 0x0000)
class IViewTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewTargetInterface">();
	}
	static class IViewTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IViewTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IViewTargetInterface) == 0x000001, "Wrong alignment on IViewTargetInterface");
static_assert(sizeof(IViewTargetInterface) == 0x000001, "Wrong size on IViewTargetInterface");

// Class BrickRigs.InteractionComponent
// 0x0008 (0x0140 - 0x0138)
class UInteractionComponent final : public UHUDIconComponent
{
public:
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000008, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x000140, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, ColorStyle) == 0x000138, "Member 'UInteractionComponent::ColorStyle' has a wrong offset!");

// Class BrickRigs.SpawnPointPanelWidget
// 0x0010 (0x0308 - 0x02F8)
class USpawnPointPanelWidget : public UHUDIconPanelWidget
{
public:
	class UBrickGridPanel*                        GridPanel;                                         // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSpawnPointsPerRow;                              // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointPanelWidget">();
	}
	static class USpawnPointPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnPointPanelWidget>();
	}
};
static_assert(alignof(USpawnPointPanelWidget) == 0x000008, "Wrong alignment on USpawnPointPanelWidget");
static_assert(sizeof(USpawnPointPanelWidget) == 0x000308, "Wrong size on USpawnPointPanelWidget");
static_assert(offsetof(USpawnPointPanelWidget, GridPanel) == 0x0002F8, "Member 'USpawnPointPanelWidget::GridPanel' has a wrong offset!");
static_assert(offsetof(USpawnPointPanelWidget, NumSpawnPointsPerRow) == 0x000300, "Member 'USpawnPointPanelWidget::NumSpawnPointsPerRow' has a wrong offset!");

// Class BrickRigs.InteractionOptionWidget
// 0x0060 (0x02C0 - 0x0260)
class UInteractionOptionWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x58];                                     // 0x0260(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UControlHintWidget*                     ControlHintWidget;                                 // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickedInteract();
	void UpdateCanBeClicked(bool bInCanBeClicked);
	void UpdateColorStyle(EBrickUIColorStyle InColorStyle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionOptionWidget">();
	}
	static class UInteractionOptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionOptionWidget>();
	}
};
static_assert(alignof(UInteractionOptionWidget) == 0x000008, "Wrong alignment on UInteractionOptionWidget");
static_assert(sizeof(UInteractionOptionWidget) == 0x0002C0, "Wrong size on UInteractionOptionWidget");
static_assert(offsetof(UInteractionOptionWidget, ControlHintWidget) == 0x0002B8, "Member 'UInteractionOptionWidget::ControlHintWidget' has a wrong offset!");

// Class BrickRigs.InteractionWidget
// 0x0028 (0x0288 - 0x0260)
class UInteractionWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionOptionWidget*>       OptionWidgets;                                     // 0x0268(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInteractionOptionWidget>   OptionWidgetClass;                                 // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddOptionWidget(class UInteractionOptionWidget* Widget, int32 OptionIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionWidget">();
	}
	static class UInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionWidget>();
	}
};
static_assert(alignof(UInteractionWidget) == 0x000008, "Wrong alignment on UInteractionWidget");
static_assert(sizeof(UInteractionWidget) == 0x000288, "Wrong size on UInteractionWidget");
static_assert(offsetof(UInteractionWidget, OptionWidgets) == 0x000268, "Member 'UInteractionWidget::OptionWidgets' has a wrong offset!");
static_assert(offsetof(UInteractionWidget, OptionWidgetClass) == 0x000280, "Member 'UInteractionWidget::OptionWidgetClass' has a wrong offset!");

// Class BrickRigs.SwitchBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class USwitchBrickStaticInfo : public USensorBrickBaseStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchBrickStaticInfo">();
	}
	static class USwitchBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchBrickStaticInfo>();
	}
};
static_assert(alignof(USwitchBrickStaticInfo) == 0x000008, "Wrong alignment on USwitchBrickStaticInfo");
static_assert(sizeof(USwitchBrickStaticInfo) == 0x0001A0, "Wrong size on USwitchBrickStaticInfo");

// Class BrickRigs.InventoryContainerWidget
// 0x0010 (0x0270 - 0x0260)
class UInventoryContainerWidget : public UUserWidget
{
public:
	class UInventoryWidget*                       InventoryWidget;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateHasInventory(bool bHasInventory);
	void UpdateOwnerMoney(float NewMoney);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryContainerWidget">();
	}
	static class UInventoryContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryContainerWidget>();
	}
};
static_assert(alignof(UInventoryContainerWidget) == 0x000008, "Wrong alignment on UInventoryContainerWidget");
static_assert(sizeof(UInventoryContainerWidget) == 0x000270, "Wrong size on UInventoryContainerWidget");
static_assert(offsetof(UInventoryContainerWidget, InventoryWidget) == 0x000260, "Member 'UInventoryContainerWidget::InventoryWidget' has a wrong offset!");
static_assert(offsetof(UInventoryContainerWidget, NameTextBlock) == 0x000268, "Member 'UInventoryContainerWidget::NameTextBlock' has a wrong offset!");

// Class BrickRigs.SpinnerBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class USpinnerBrickStaticInfo : public UScalableBrickBaseStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinnerBrickStaticInfo">();
	}
	static class USpinnerBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinnerBrickStaticInfo>();
	}
};
static_assert(alignof(USpinnerBrickStaticInfo) == 0x000008, "Wrong alignment on USpinnerBrickStaticInfo");
static_assert(sizeof(USpinnerBrickStaticInfo) == 0x000168, "Wrong size on USpinnerBrickStaticInfo");

// Class BrickRigs.InventorySlotWidget
// 0x00A8 (0x0308 - 0x0260)
class UInventorySlotWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x70];                                     // 0x0260(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryContainerWidget*              SubInventoryContainerWidget;                       // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickButtonWidget*                     Button;                                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        AmountTextBlock;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickImage*                            IconImage;                                         // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddSubInventoryWidget(class UInventoryContainerWidget* Widget);
	void OnButtonClicked();
	struct FEventReply OnButtonDragged(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent);
	void UpdateSlotApperance(bool bInIsDragWidget, bool bInIsSpecialSlot, bool bInIsValidSlot, bool bInCanDrag, bool bInIsDragging, bool bInCanDrop, bool bInDropReplace, bool bInIsDragOver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventorySlotWidget">();
	}
	static class UInventorySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventorySlotWidget>();
	}
};
static_assert(alignof(UInventorySlotWidget) == 0x000008, "Wrong alignment on UInventorySlotWidget");
static_assert(sizeof(UInventorySlotWidget) == 0x000308, "Wrong size on UInventorySlotWidget");
static_assert(offsetof(UInventorySlotWidget, SubInventoryContainerWidget) == 0x0002D0, "Member 'UInventorySlotWidget::SubInventoryContainerWidget' has a wrong offset!");
static_assert(offsetof(UInventorySlotWidget, Button) == 0x0002E8, "Member 'UInventorySlotWidget::Button' has a wrong offset!");
static_assert(offsetof(UInventorySlotWidget, NameTextBlock) == 0x0002F0, "Member 'UInventorySlotWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UInventorySlotWidget, AmountTextBlock) == 0x0002F8, "Member 'UInventorySlotWidget::AmountTextBlock' has a wrong offset!");
static_assert(offsetof(UInventorySlotWidget, IconImage) == 0x000300, "Member 'UInventorySlotWidget::IconImage' has a wrong offset!");

// Class BrickRigs.InventoryWidget
// 0x0038 (0x0298 - 0x0260)
class UInventoryWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInventorySlotWidget*>           SlotWidgets;                                       // 0x0270(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickGridPanel*                        SlotsPanel;                                        // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSlotsPerRow;                                    // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryWidget">();
	}
	static class UInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryWidget>();
	}
};
static_assert(alignof(UInventoryWidget) == 0x000008, "Wrong alignment on UInventoryWidget");
static_assert(sizeof(UInventoryWidget) == 0x000298, "Wrong size on UInventoryWidget");
static_assert(offsetof(UInventoryWidget, SlotWidgets) == 0x000270, "Member 'UInventoryWidget::SlotWidgets' has a wrong offset!");
static_assert(offsetof(UInventoryWidget, SlotsPanel) == 0x000288, "Member 'UInventoryWidget::SlotsPanel' has a wrong offset!");
static_assert(offsetof(UInventoryWidget, NumSlotsPerRow) == 0x000290, "Member 'UInventoryWidget::NumSlotsPerRow' has a wrong offset!");

// Class BrickRigs.SoundNodeMotor
// 0x0018 (0x0060 - 0x0048)
class USoundNodeMotor final : public USoundNode
{
public:
	TArray<class USoundWave*>                     MotorSounds;                                       // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FadeInRatio;                                       // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeMotor">();
	}
	static class USoundNodeMotor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeMotor>();
	}
};
static_assert(alignof(USoundNodeMotor) == 0x000008, "Wrong alignment on USoundNodeMotor");
static_assert(sizeof(USoundNodeMotor) == 0x000060, "Wrong size on USoundNodeMotor");
static_assert(offsetof(USoundNodeMotor, MotorSounds) == 0x000048, "Member 'USoundNodeMotor::MotorSounds' has a wrong offset!");
static_assert(offsetof(USoundNodeMotor, FadeInRatio) == 0x000058, "Member 'USoundNodeMotor::FadeInRatio' has a wrong offset!");

// Class BrickRigs.JoinSessionPopupParams
// 0x0118 (0x0180 - 0x0068)
class UJoinSessionPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x118];                                     // 0x0068(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JoinSessionPopupParams">();
	}
	static class UJoinSessionPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJoinSessionPopupParams>();
	}
};
static_assert(alignof(UJoinSessionPopupParams) == 0x000008, "Wrong alignment on UJoinSessionPopupParams");
static_assert(sizeof(UJoinSessionPopupParams) == 0x000180, "Wrong size on UJoinSessionPopupParams");

// Class BrickRigs.SteeringWheelBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class USteeringWheelBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteeringWheelBrickStaticInfo">();
	}
	static class USteeringWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteeringWheelBrickStaticInfo>();
	}
};
static_assert(alignof(USteeringWheelBrickStaticInfo) == 0x000008, "Wrong alignment on USteeringWheelBrickStaticInfo");
static_assert(sizeof(USteeringWheelBrickStaticInfo) == 0x000168, "Wrong size on USteeringWheelBrickStaticInfo");

// Class BrickRigs.TargetMarkerIconWidget
// 0x0008 (0x0290 - 0x0288)
class UTargetMarkerIconWidget : public UHUDIconWidget
{
public:
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateAmmoType(EAmmoType NewType);
	void UpdateFireAction(int32 NewActionIndex);
	void UpdateHasValidTarget(bool bNewHasValidTarget);
	void UpdateTargetDistance(float NewDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetMarkerIconWidget">();
	}
	static class UTargetMarkerIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetMarkerIconWidget>();
	}
};
static_assert(alignof(UTargetMarkerIconWidget) == 0x000008, "Wrong alignment on UTargetMarkerIconWidget");
static_assert(sizeof(UTargetMarkerIconWidget) == 0x000290, "Wrong size on UTargetMarkerIconWidget");

// Class BrickRigs.KickPlayerPopupParams
// 0x00A0 (0x0108 - 0x0068)
class UKickPlayerPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x50];                                      // 0x0068(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x00B8(0x0028)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x00E0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KickReason;                                        // 0x00F0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              KickDuration;                                      // 0x0100(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KickPlayerPopupParams">();
	}
	static class UKickPlayerPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKickPlayerPopupParams>();
	}
};
static_assert(alignof(UKickPlayerPopupParams) == 0x000008, "Wrong alignment on UKickPlayerPopupParams");
static_assert(sizeof(UKickPlayerPopupParams) == 0x000108, "Wrong size on UKickPlayerPopupParams");
static_assert(offsetof(UKickPlayerPopupParams, PlayerId) == 0x0000B8, "Member 'UKickPlayerPopupParams::PlayerId' has a wrong offset!");
static_assert(offsetof(UKickPlayerPopupParams, PlayerName) == 0x0000E0, "Member 'UKickPlayerPopupParams::PlayerName' has a wrong offset!");
static_assert(offsetof(UKickPlayerPopupParams, KickReason) == 0x0000F0, "Member 'UKickPlayerPopupParams::KickReason' has a wrong offset!");
static_assert(offsetof(UKickPlayerPopupParams, KickDuration) == 0x000100, "Member 'UKickPlayerPopupParams::KickDuration' has a wrong offset!");

// Class BrickRigs.TailBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UTailBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TailBrickStaticInfo">();
	}
	static class UTailBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTailBrickStaticInfo>();
	}
};
static_assert(alignof(UTailBrickStaticInfo) == 0x000008, "Wrong alignment on UTailBrickStaticInfo");
static_assert(sizeof(UTailBrickStaticInfo) == 0x000168, "Wrong size on UTailBrickStaticInfo");

// Class BrickRigs.LampProp
// 0x0020 (0x0260 - 0x0240)
class ALampProp : public AStaticMeshProp
{
public:
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         PowerTimeRange;                                    // 0x0244(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightComponent*                        LightComponent;                                    // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ULightComponent>            LightComponentClass;                               // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LampProp">();
	}
	static class ALampProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALampProp>();
	}
};
static_assert(alignof(ALampProp) == 0x000008, "Wrong alignment on ALampProp");
static_assert(sizeof(ALampProp) == 0x000260, "Wrong size on ALampProp");
static_assert(offsetof(ALampProp, PowerTimeRange) == 0x000244, "Member 'ALampProp::PowerTimeRange' has a wrong offset!");
static_assert(offsetof(ALampProp, LightComponent) == 0x000250, "Member 'ALampProp::LightComponent' has a wrong offset!");
static_assert(offsetof(ALampProp, LightComponentClass) == 0x000258, "Member 'ALampProp::LightComponentClass' has a wrong offset!");

// Class BrickRigs.LedgeBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class ULedgeBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LedgeBrickStaticInfo">();
	}
	static class ULedgeBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULedgeBrickStaticInfo>();
	}
};
static_assert(alignof(ULedgeBrickStaticInfo) == 0x000008, "Wrong alignment on ULedgeBrickStaticInfo");
static_assert(sizeof(ULedgeBrickStaticInfo) == 0x000168, "Wrong size on ULedgeBrickStaticInfo");

// Class BrickRigs.SprocketWheelBrickStaticInfo
// 0x0038 (0x01C0 - 0x0188)
class USprocketWheelBrickStaticInfo : public UTrackWheelBrickStaticInfo
{
public:
	class UStaticMesh*                            TrackMesh;                                         // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TrackMeshSize;                                     // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickPhysicalMaterial*                 TrackPhysMaterial;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TrackBreakSound;                                   // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackSpacing;                                      // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackThickness;                                    // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumTrackInstances;                              // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumIdlerWheels;                                 // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrackBreakParticleRatio;                           // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BC[0x4];                                      // 0x01BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprocketWheelBrickStaticInfo">();
	}
	static class USprocketWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprocketWheelBrickStaticInfo>();
	}
};
static_assert(alignof(USprocketWheelBrickStaticInfo) == 0x000008, "Wrong alignment on USprocketWheelBrickStaticInfo");
static_assert(sizeof(USprocketWheelBrickStaticInfo) == 0x0001C0, "Wrong size on USprocketWheelBrickStaticInfo");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackMesh) == 0x000188, "Member 'USprocketWheelBrickStaticInfo::TrackMesh' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackMeshSize) == 0x000190, "Member 'USprocketWheelBrickStaticInfo::TrackMeshSize' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackPhysMaterial) == 0x000198, "Member 'USprocketWheelBrickStaticInfo::TrackPhysMaterial' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackBreakSound) == 0x0001A0, "Member 'USprocketWheelBrickStaticInfo::TrackBreakSound' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackSpacing) == 0x0001A8, "Member 'USprocketWheelBrickStaticInfo::TrackSpacing' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackThickness) == 0x0001AC, "Member 'USprocketWheelBrickStaticInfo::TrackThickness' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, MaxNumTrackInstances) == 0x0001B0, "Member 'USprocketWheelBrickStaticInfo::MaxNumTrackInstances' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, MaxNumIdlerWheels) == 0x0001B4, "Member 'USprocketWheelBrickStaticInfo::MaxNumIdlerWheels' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrickStaticInfo, TrackBreakParticleRatio) == 0x0001B8, "Member 'USprocketWheelBrickStaticInfo::TrackBreakParticleRatio' has a wrong offset!");

// Class BrickRigs.BuildingPart
// 0x0028 (0x0050 - 0x0028)
class UBuildingPart final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fill(uint8 MeshIdx);
	void Floor(int32 Floor_0, uint8 MeshIdx);
	void Grid(int32 Dist, uint8 MeshIdx);
	void Place(EBuildingSide Side, int32 Floor, int32 Position, uint8 MeshIdx);
	void Rect(EBuildingSide Side, int32 StartFloor, int32 EndFloor, int32 StartPosition, int32 EndPosition, uint8 MeshIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingPart">();
	}
	static class UBuildingPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuildingPart>();
	}
};
static_assert(alignof(UBuildingPart) == 0x000008, "Wrong alignment on UBuildingPart");
static_assert(sizeof(UBuildingPart) == 0x000050, "Wrong size on UBuildingPart");

// Class BrickRigs.TargetMarkerIconComponent
// 0x0028 (0x0160 - 0x0138)
class UTargetMarkerIconComponent final : public UHUDIconComponent
{
public:
	uint8                                         Pad_138[0x28];                                     // 0x0138(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetMarkerIconComponent">();
	}
	static class UTargetMarkerIconComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetMarkerIconComponent>();
	}
};
static_assert(alignof(UTargetMarkerIconComponent) == 0x000008, "Wrong alignment on UTargetMarkerIconComponent");
static_assert(sizeof(UTargetMarkerIconComponent) == 0x000160, "Wrong size on UTargetMarkerIconComponent");

// Class BrickRigs.LevelInfo
// 0x0078 (0x00A8 - 0x0030)
class ULevelInfo final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Level;                                             // 0x0038(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0060(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayIcon;                                       // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUsesWorldComposition;                             // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoWeather;                                        // 0x00A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasAITrains;                                      // 0x00A6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A7[0x1];                                       // 0x00A7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelInfo">();
	}
	static class ULevelInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelInfo>();
	}
};
static_assert(alignof(ULevelInfo) == 0x000008, "Wrong alignment on ULevelInfo");
static_assert(sizeof(ULevelInfo) == 0x0000A8, "Wrong size on ULevelInfo");
static_assert(offsetof(ULevelInfo, Level) == 0x000038, "Member 'ULevelInfo::Level' has a wrong offset!");
static_assert(offsetof(ULevelInfo, DisplayName) == 0x000060, "Member 'ULevelInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(ULevelInfo, DisplayIcon) == 0x000078, "Member 'ULevelInfo::DisplayIcon' has a wrong offset!");
static_assert(offsetof(ULevelInfo, SortPriority) == 0x0000A0, "Member 'ULevelInfo::SortPriority' has a wrong offset!");
static_assert(offsetof(ULevelInfo, bUsesWorldComposition) == 0x0000A4, "Member 'ULevelInfo::bUsesWorldComposition' has a wrong offset!");
static_assert(offsetof(ULevelInfo, bNoWeather) == 0x0000A5, "Member 'ULevelInfo::bNoWeather' has a wrong offset!");
static_assert(offsetof(ULevelInfo, bHasAITrains) == 0x0000A6, "Member 'ULevelInfo::bHasAITrains' has a wrong offset!");

// Class BrickRigs.LightBrickStaticInfo
// 0x0008 (0x01A8 - 0x01A0)
class ULightBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	float                                         Intensity;                                         // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        LightDirectionFlags;                               // 0x01A4(0x0002)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A6[0x2];                                      // 0x01A6(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBrickStaticInfo">();
	}
	static class ULightBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBrickStaticInfo>();
	}
};
static_assert(alignof(ULightBrickStaticInfo) == 0x000008, "Wrong alignment on ULightBrickStaticInfo");
static_assert(sizeof(ULightBrickStaticInfo) == 0x0001A8, "Wrong size on ULightBrickStaticInfo");
static_assert(offsetof(ULightBrickStaticInfo, Intensity) == 0x0001A0, "Member 'ULightBrickStaticInfo::Intensity' has a wrong offset!");
static_assert(offsetof(ULightBrickStaticInfo, LightDirectionFlags) == 0x0001A4, "Member 'ULightBrickStaticInfo::LightDirectionFlags' has a wrong offset!");

// Class BrickRigs.ThrusterBrick
// 0x0080 (0x01A0 - 0x0120)
class UThrusterBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x14];                                     // 0x0120(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          RepAccumulatedInput;                               // 0x0134(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_135[0x3B];                                     // 0x0135(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         InputScale;                                        // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAccumulated;                                      // 0x019C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_RepAccumulatedInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrusterBrick">();
	}
	static class UThrusterBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrusterBrick>();
	}
};
static_assert(alignof(UThrusterBrick) == 0x000008, "Wrong alignment on UThrusterBrick");
static_assert(sizeof(UThrusterBrick) == 0x0001A0, "Wrong size on UThrusterBrick");
static_assert(offsetof(UThrusterBrick, RepAccumulatedInput) == 0x000134, "Member 'UThrusterBrick::RepAccumulatedInput' has a wrong offset!");
static_assert(offsetof(UThrusterBrick, InputChannel) == 0x000170, "Member 'UThrusterBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(UThrusterBrick, InputScale) == 0x000198, "Member 'UThrusterBrick::InputScale' has a wrong offset!");
static_assert(offsetof(UThrusterBrick, bAccumulated) == 0x00019C, "Member 'UThrusterBrick::bAccumulated' has a wrong offset!");

// Class BrickRigs.LightBrick
// 0x0060 (0x0180 - 0x0120)
class ULightBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Brightness;                                        // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USirenSequence>             FlashSequence;                                     // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0150(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ELightBrickDirection                          LightDirection;                                    // 0x0178(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x3];                                      // 0x0179(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LightConeAngle;                                    // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightBrick">();
	}
	static class ULightBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightBrick>();
	}
};
static_assert(alignof(ULightBrick) == 0x000008, "Wrong alignment on ULightBrick");
static_assert(sizeof(ULightBrick) == 0x000180, "Wrong size on ULightBrick");
static_assert(offsetof(ULightBrick, Brightness) == 0x000140, "Member 'ULightBrick::Brightness' has a wrong offset!");
static_assert(offsetof(ULightBrick, FlashSequence) == 0x000148, "Member 'ULightBrick::FlashSequence' has a wrong offset!");
static_assert(offsetof(ULightBrick, InputChannel) == 0x000150, "Member 'ULightBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(ULightBrick, LightDirection) == 0x000178, "Member 'ULightBrick::LightDirection' has a wrong offset!");
static_assert(offsetof(ULightBrick, LightConeAngle) == 0x00017C, "Member 'ULightBrick::LightConeAngle' has a wrong offset!");

// Class BrickRigs.TeamBaseIconWidget
// 0x0008 (0x0290 - 0x0288)
class UTeamBaseIconWidget : public UHUDIconWidget
{
public:
	class ATeamBase*                              TeamBase;                                          // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBaseIconWidget">();
	}
	static class UTeamBaseIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamBaseIconWidget>();
	}
};
static_assert(alignof(UTeamBaseIconWidget) == 0x000008, "Wrong alignment on UTeamBaseIconWidget");
static_assert(sizeof(UTeamBaseIconWidget) == 0x000290, "Wrong size on UTeamBaseIconWidget");
static_assert(offsetof(UTeamBaseIconWidget, TeamBase) == 0x000288, "Member 'UTeamBaseIconWidget::TeamBase' has a wrong offset!");

// Class BrickRigs.LoadoutContainer
// 0x0048 (0x0288 - 0x0240)
class ALoadoutContainer : public AStaticMeshProp
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDIconComponent*                      HUDIconComponent;                                  // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimationLength;                                   // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHUDIconProperties                     IconProperties;                                    // 0x0258(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Interact_Inventory(class ABrickPlayerController* PC);
	void UpdateAnimation(float InAnimRatio);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutContainer">();
	}
	static class ALoadoutContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoadoutContainer>();
	}
};
static_assert(alignof(ALoadoutContainer) == 0x000008, "Wrong alignment on ALoadoutContainer");
static_assert(sizeof(ALoadoutContainer) == 0x000288, "Wrong size on ALoadoutContainer");
static_assert(offsetof(ALoadoutContainer, HUDIconComponent) == 0x000248, "Member 'ALoadoutContainer::HUDIconComponent' has a wrong offset!");
static_assert(offsetof(ALoadoutContainer, AnimationLength) == 0x000250, "Member 'ALoadoutContainer::AnimationLength' has a wrong offset!");
static_assert(offsetof(ALoadoutContainer, IconProperties) == 0x000258, "Member 'ALoadoutContainer::IconProperties' has a wrong offset!");

// Class BrickRigs.LoadoutInventoryComponent
// 0x0008 (0x02A0 - 0x0298)
class ULoadoutInventoryComponent final : public UInventoryComponent
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutInventoryComponent">();
	}
	static class ULoadoutInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutInventoryComponent>();
	}
};
static_assert(alignof(ULoadoutInventoryComponent) == 0x000008, "Wrong alignment on ULoadoutInventoryComponent");
static_assert(sizeof(ULoadoutInventoryComponent) == 0x0002A0, "Wrong size on ULoadoutInventoryComponent");

// Class BrickRigs.TankBrick
// 0x0010 (0x0130 - 0x0120)
class UTankBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UExplosiveMaterial>         FuelType;                                          // 0x0128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankBrick">();
	}
	static class UTankBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankBrick>();
	}
};
static_assert(alignof(UTankBrick) == 0x000008, "Wrong alignment on UTankBrick");
static_assert(sizeof(UTankBrick) == 0x000130, "Wrong size on UTankBrick");
static_assert(offsetof(UTankBrick, FuelType) == 0x000128, "Member 'UTankBrick::FuelType' has a wrong offset!");

// Class BrickRigs.MapCrosshairWidget
// 0x0000 (0x0260 - 0x0260)
class UMapCrosshairWidget : public UUserWidget
{
public:
	void SetColorStyle(EBrickUIColorStyle NewStyle);
	void SetStyleState(EBrickUIStyleState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCrosshairWidget">();
	}
	static class UMapCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapCrosshairWidget>();
	}
};
static_assert(alignof(UMapCrosshairWidget) == 0x000008, "Wrong alignment on UMapCrosshairWidget");
static_assert(sizeof(UMapCrosshairWidget) == 0x000260, "Wrong size on UMapCrosshairWidget");

// Class BrickRigs.RadioButtonPanel
// 0x0028 (0x0188 - 0x0160)
class URadioButtonPanel final : public UGridPanel
{
public:
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinSelectedButtons;                                // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSelectedButtons;                                // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class URadioButtonWidget* Button, bool bNewSelected)> OnButtonSelectedDelegate; // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GetSelectedWidgets(TArray<class URadioButtonWidget*>* OutWidgets);
	void SelectButton(class URadioButtonWidget* Button);
	void UnselectAll();
	void UnselectButton(class URadioButtonWidget* Button);

	int32 GetNumSelectedWidgets() const;
	class URadioButtonWidget* GetSelectedWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadioButtonPanel">();
	}
	static class URadioButtonPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadioButtonPanel>();
	}
};
static_assert(alignof(URadioButtonPanel) == 0x000008, "Wrong alignment on URadioButtonPanel");
static_assert(sizeof(URadioButtonPanel) == 0x000188, "Wrong size on URadioButtonPanel");
static_assert(offsetof(URadioButtonPanel, MinSelectedButtons) == 0x000170, "Member 'URadioButtonPanel::MinSelectedButtons' has a wrong offset!");
static_assert(offsetof(URadioButtonPanel, MaxSelectedButtons) == 0x000174, "Member 'URadioButtonPanel::MaxSelectedButtons' has a wrong offset!");
static_assert(offsetof(URadioButtonPanel, OnButtonSelectedDelegate) == 0x000178, "Member 'URadioButtonPanel::OnButtonSelectedDelegate' has a wrong offset!");

// Class BrickRigs.MapWidget
// 0x0170 (0x0480 - 0x0310)
class UMapWidget : public UHUDIconCanvasWidget
{
public:
	uint8                                         Pad_310[0xC8];                                     // 0x0310(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UHUDIconComponent*                      CursorIconComponent;                               // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MapMID;                                            // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMenuButtonPanelWidget*                 ButtonPanel;                                       // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        ScaleTextBlock;                                    // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinViewportSize;                                   // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PanSpeed;                                          // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomSpeed;                                         // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomStep;                                          // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ViewportInterpSpeed;                               // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapResolutionScale;                                // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapRenderInterval;                                 // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapMovedRenderDelay;                               // 0x0434(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridSize;                                          // 0x0438(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         ViewportSizeIconScaleRange;                        // 0x043C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHUDIconProperties                     CursorIconProperties;                              // 0x0448(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMapCrosshairWidget>        CrosshairWidgetClass;                              // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMeasurementSystemChanged(EMeasurementSystem NewSystem);
	void ResetPanAndZoom(bool bInitialize);
	void UpdateViewportPannedOrZoomed(bool bValue);

	class UMaterialInstanceDynamic* CreateMapMID() const;
	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapWidget">();
	}
	static class UMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapWidget>();
	}
};
static_assert(alignof(UMapWidget) == 0x000008, "Wrong alignment on UMapWidget");
static_assert(sizeof(UMapWidget) == 0x000480, "Wrong size on UMapWidget");
static_assert(offsetof(UMapWidget, CursorIconComponent) == 0x0003D8, "Member 'UMapWidget::CursorIconComponent' has a wrong offset!");
static_assert(offsetof(UMapWidget, MapMID) == 0x0003F0, "Member 'UMapWidget::MapMID' has a wrong offset!");
static_assert(offsetof(UMapWidget, ButtonPanel) == 0x000408, "Member 'UMapWidget::ButtonPanel' has a wrong offset!");
static_assert(offsetof(UMapWidget, ScaleTextBlock) == 0x000410, "Member 'UMapWidget::ScaleTextBlock' has a wrong offset!");
static_assert(offsetof(UMapWidget, MinViewportSize) == 0x000418, "Member 'UMapWidget::MinViewportSize' has a wrong offset!");
static_assert(offsetof(UMapWidget, PanSpeed) == 0x00041C, "Member 'UMapWidget::PanSpeed' has a wrong offset!");
static_assert(offsetof(UMapWidget, ZoomSpeed) == 0x000420, "Member 'UMapWidget::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UMapWidget, ZoomStep) == 0x000424, "Member 'UMapWidget::ZoomStep' has a wrong offset!");
static_assert(offsetof(UMapWidget, ViewportInterpSpeed) == 0x000428, "Member 'UMapWidget::ViewportInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMapWidget, MapResolutionScale) == 0x00042C, "Member 'UMapWidget::MapResolutionScale' has a wrong offset!");
static_assert(offsetof(UMapWidget, MapRenderInterval) == 0x000430, "Member 'UMapWidget::MapRenderInterval' has a wrong offset!");
static_assert(offsetof(UMapWidget, MapMovedRenderDelay) == 0x000434, "Member 'UMapWidget::MapMovedRenderDelay' has a wrong offset!");
static_assert(offsetof(UMapWidget, GridSize) == 0x000438, "Member 'UMapWidget::GridSize' has a wrong offset!");
static_assert(offsetof(UMapWidget, ViewportSizeIconScaleRange) == 0x00043C, "Member 'UMapWidget::ViewportSizeIconScaleRange' has a wrong offset!");
static_assert(offsetof(UMapWidget, CursorIconProperties) == 0x000448, "Member 'UMapWidget::CursorIconProperties' has a wrong offset!");
static_assert(offsetof(UMapWidget, CrosshairWidgetClass) == 0x000478, "Member 'UMapWidget::CrosshairWidgetClass' has a wrong offset!");

// Class BrickRigs.TurbineBrick
// 0x0130 (0x0230 - 0x0100)
class UTurbineBrick final : public UFuelConsumerBrick
{
public:
	uint8                                         Pad_100[0x40];                                     // 0x0100(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   PowerInputChannel;                                 // 0x0140(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   PitchInputChannel;                                 // 0x0168(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   RollInputChannel;                                  // 0x0190(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   YawInputChannel;                                   // 0x01B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   ThrottleInputChannel;                              // 0x01E0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   AutoHoverInputChannel;                             // 0x0208(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurbineBrick">();
	}
	static class UTurbineBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurbineBrick>();
	}
};
static_assert(alignof(UTurbineBrick) == 0x000008, "Wrong alignment on UTurbineBrick");
static_assert(sizeof(UTurbineBrick) == 0x000230, "Wrong size on UTurbineBrick");
static_assert(offsetof(UTurbineBrick, PowerInputChannel) == 0x000140, "Member 'UTurbineBrick::PowerInputChannel' has a wrong offset!");
static_assert(offsetof(UTurbineBrick, PitchInputChannel) == 0x000168, "Member 'UTurbineBrick::PitchInputChannel' has a wrong offset!");
static_assert(offsetof(UTurbineBrick, RollInputChannel) == 0x000190, "Member 'UTurbineBrick::RollInputChannel' has a wrong offset!");
static_assert(offsetof(UTurbineBrick, YawInputChannel) == 0x0001B8, "Member 'UTurbineBrick::YawInputChannel' has a wrong offset!");
static_assert(offsetof(UTurbineBrick, ThrottleInputChannel) == 0x0001E0, "Member 'UTurbineBrick::ThrottleInputChannel' has a wrong offset!");
static_assert(offsetof(UTurbineBrick, AutoHoverInputChannel) == 0x000208, "Member 'UTurbineBrick::AutoHoverInputChannel' has a wrong offset!");

// Class BrickRigs.MatchMenuWidget
// 0x0008 (0x0278 - 0x0270)
class UMatchMenuWidget : public UMenuPageWidget
{
public:
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RestartMatch();
	void UpdateIsAdmin(bool bNewIsAdmin);
	void UpdateRestartMatchButton(bool bCanRestart, bool bSameLevelAndMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchMenuWidget">();
	}
	static class UMatchMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchMenuWidget>();
	}
};
static_assert(alignof(UMatchMenuWidget) == 0x000008, "Wrong alignment on UMatchMenuWidget");
static_assert(sizeof(UMatchMenuWidget) == 0x000278, "Wrong size on UMatchMenuWidget");
static_assert(offsetof(UMatchMenuWidget, PropertiesPanel) == 0x000270, "Member 'UMatchMenuWidget::PropertiesPanel' has a wrong offset!");

// Class BrickRigs.RCBrick
// 0x0000 (0x0120 - 0x0120)
class URCBrick final : public UScalableBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBrick">();
	}
	static class URCBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBrick>();
	}
};
static_assert(alignof(URCBrick) == 0x000008, "Wrong alignment on URCBrick");
static_assert(sizeof(URCBrick) == 0x000120, "Wrong size on URCBrick");

// Class BrickRigs.MatchTimerWidget
// 0x0000 (0x0260 - 0x0260)
class UMatchTimerWidget : public UUserWidget
{
public:
	void UpdateTimer(int32 NewTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchTimerWidget">();
	}
	static class UMatchTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchTimerWidget>();
	}
};
static_assert(alignof(UMatchTimerWidget) == 0x000008, "Wrong alignment on UMatchTimerWidget");
static_assert(sizeof(UMatchTimerWidget) == 0x000260, "Wrong size on UMatchTimerWidget");

// Class BrickRigs.MathBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class UMathBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MathBrickStaticInfo">();
	}
	static class UMathBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMathBrickStaticInfo>();
	}
};
static_assert(alignof(UMathBrickStaticInfo) == 0x000008, "Wrong alignment on UMathBrickStaticInfo");
static_assert(sizeof(UMathBrickStaticInfo) == 0x0001A0, "Wrong size on UMathBrickStaticInfo");

// Class BrickRigs.PumpBrick
// 0x0038 (0x0130 - 0x00F8)
class UPumpBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PumpBrick">();
	}
	static class UPumpBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPumpBrick>();
	}
};
static_assert(alignof(UPumpBrick) == 0x000008, "Wrong alignment on UPumpBrick");
static_assert(sizeof(UPumpBrick) == 0x000130, "Wrong size on UPumpBrick");
static_assert(offsetof(UPumpBrick, InputChannel) == 0x000108, "Member 'UPumpBrick::InputChannel' has a wrong offset!");

// Class BrickRigs.MathBrick
// 0x0088 (0x01A8 - 0x0120)
class UMathBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0xC];                                      // 0x0120(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EMathBrickOperation                           Operation;                                         // 0x012C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannelA;                                     // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   InputChannelB;                                     // 0x0158(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FVehicleOutputChannel                  OutputChannel;                                     // 0x0180(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MathBrick">();
	}
	static class UMathBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMathBrick>();
	}
};
static_assert(alignof(UMathBrick) == 0x000008, "Wrong alignment on UMathBrick");
static_assert(sizeof(UMathBrick) == 0x0001A8, "Wrong size on UMathBrick");
static_assert(offsetof(UMathBrick, Operation) == 0x00012C, "Member 'UMathBrick::Operation' has a wrong offset!");
static_assert(offsetof(UMathBrick, InputChannelA) == 0x000130, "Member 'UMathBrick::InputChannelA' has a wrong offset!");
static_assert(offsetof(UMathBrick, InputChannelB) == 0x000158, "Member 'UMathBrick::InputChannelB' has a wrong offset!");
static_assert(offsetof(UMathBrick, OutputChannel) == 0x000180, "Member 'UMathBrick::OutputChannel' has a wrong offset!");

// Class BrickRigs.MeleeAction
// 0x0010 (0x0098 - 0x0088)
class UMeleeAction : public UCharacterAction
{
public:
	float                                         ApplyDamageTime;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSweepDistance;                               // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageSweepRadius;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeDamage;                                       // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeAction">();
	}
	static class UMeleeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeAction>();
	}
};
static_assert(alignof(UMeleeAction) == 0x000008, "Wrong alignment on UMeleeAction");
static_assert(sizeof(UMeleeAction) == 0x000098, "Wrong size on UMeleeAction");
static_assert(offsetof(UMeleeAction, ApplyDamageTime) == 0x000088, "Member 'UMeleeAction::ApplyDamageTime' has a wrong offset!");
static_assert(offsetof(UMeleeAction, DamageSweepDistance) == 0x00008C, "Member 'UMeleeAction::DamageSweepDistance' has a wrong offset!");
static_assert(offsetof(UMeleeAction, DamageSweepRadius) == 0x000090, "Member 'UMeleeAction::DamageSweepRadius' has a wrong offset!");
static_assert(offsetof(UMeleeAction, MeleeDamage) == 0x000094, "Member 'UMeleeAction::MeleeDamage' has a wrong offset!");

// Class BrickRigs.TrussBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UTrussBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrussBrickStaticInfo">();
	}
	static class UTrussBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrussBrickStaticInfo>();
	}
};
static_assert(alignof(UTrussBrickStaticInfo) == 0x000008, "Wrong alignment on UTrussBrickStaticInfo");
static_assert(sizeof(UTrussBrickStaticInfo) == 0x000168, "Wrong size on UTrussBrickStaticInfo");

// Class BrickRigs.MenuButtonPanelWidget
// 0x0030 (0x0290 - 0x0260)
class UMenuButtonPanelWidget : public UUserWidget
{
public:
	TArray<class UMenuButtonWidget*>              Buttons;                                           // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         NumButtonsUsed;                                    // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickGridPanel* ButtonPanel;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuButtonWidget>          ButtonClass;                                       // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumButtonsPerRow;                                  // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearButtons(bool bManualRemove);
	class UMenuButtonWidget* CreateButton(const class FText& DisplayText, int32 IconIndex, const TDelegate<void()>& Delegate);
	void RemoveUnusedButtons();
	void SetNumButtonsPerRow(int32 NewNum);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuButtonPanelWidget">();
	}
	static class UMenuButtonPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuButtonPanelWidget>();
	}
};
static_assert(alignof(UMenuButtonPanelWidget) == 0x000008, "Wrong alignment on UMenuButtonPanelWidget");
static_assert(sizeof(UMenuButtonPanelWidget) == 0x000290, "Wrong size on UMenuButtonPanelWidget");
static_assert(offsetof(UMenuButtonPanelWidget, Buttons) == 0x000260, "Member 'UMenuButtonPanelWidget::Buttons' has a wrong offset!");
static_assert(offsetof(UMenuButtonPanelWidget, ButtonPanel) == 0x000278, "Member 'UMenuButtonPanelWidget::ButtonPanel' has a wrong offset!");
static_assert(offsetof(UMenuButtonPanelWidget, ButtonClass) == 0x000280, "Member 'UMenuButtonPanelWidget::ButtonClass' has a wrong offset!");
static_assert(offsetof(UMenuButtonPanelWidget, NumButtonsPerRow) == 0x000288, "Member 'UMenuButtonPanelWidget::NumButtonsPerRow' has a wrong offset!");

// Class BrickRigs.UGCTagsPropertyWidget
// 0x0018 (0x0298 - 0x0280)
class UUGCTagsPropertyWidget : public UPropertyWidget
{
public:
	class UBrickComboBoxWidget*                   TypeComboBox;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickComboBoxWidget*                   EraComboBox;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickComboBoxWidget*                   DepartmentComboBox;                                // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeDepartmentItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void InitializeEraItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void InitializeTypeItem(int32 Item, struct FBrickComboBoxItemParams* OutParams);
	void OnDepartmentItemSelected(int32 Item, EValueChangedEventType EventType);
	void OnEraItemSelected(int32 Item, EValueChangedEventType EventType);
	void OnTypeItemSelected(int32 Item, EValueChangedEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCTagsPropertyWidget">();
	}
	static class UUGCTagsPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCTagsPropertyWidget>();
	}
};
static_assert(alignof(UUGCTagsPropertyWidget) == 0x000008, "Wrong alignment on UUGCTagsPropertyWidget");
static_assert(sizeof(UUGCTagsPropertyWidget) == 0x000298, "Wrong size on UUGCTagsPropertyWidget");
static_assert(offsetof(UUGCTagsPropertyWidget, TypeComboBox) == 0x000280, "Member 'UUGCTagsPropertyWidget::TypeComboBox' has a wrong offset!");
static_assert(offsetof(UUGCTagsPropertyWidget, EraComboBox) == 0x000288, "Member 'UUGCTagsPropertyWidget::EraComboBox' has a wrong offset!");
static_assert(offsetof(UUGCTagsPropertyWidget, DepartmentComboBox) == 0x000290, "Member 'UUGCTagsPropertyWidget::DepartmentComboBox' has a wrong offset!");

// Class BrickRigs.MenuGameMode
// 0x0070 (0x0330 - 0x02C0)
class AMenuGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 MenuSequenceClass;                                 // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AMenuSequence*                          MenuSequence;                                      // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuGameMode">();
	}
	static class AMenuGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuGameMode>();
	}
};
static_assert(alignof(AMenuGameMode) == 0x000008, "Wrong alignment on AMenuGameMode");
static_assert(sizeof(AMenuGameMode) == 0x000330, "Wrong size on AMenuGameMode");
static_assert(offsetof(AMenuGameMode, MenuSequenceClass) == 0x0002D0, "Member 'AMenuGameMode::MenuSequenceClass' has a wrong offset!");
static_assert(offsetof(AMenuGameMode, MenuSequence) == 0x0002D8, "Member 'AMenuGameMode::MenuSequence' has a wrong offset!");

// Class BrickRigs.MenuMusic
// 0x0028 (0x0058 - 0x0030)
class UMenuMusic final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class USoundWave>              Sound;                                             // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMusic">();
	}
	static class UMenuMusic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuMusic>();
	}
};
static_assert(alignof(UMenuMusic) == 0x000008, "Wrong alignment on UMenuMusic");
static_assert(sizeof(UMenuMusic) == 0x000058, "Wrong size on UMenuMusic");
static_assert(offsetof(UMenuMusic, Sound) == 0x000030, "Member 'UMenuMusic::Sound' has a wrong offset!");

// Class BrickRigs.UGCBrowserWidget
// 0x00B0 (0x0348 - 0x0298)
class UUGCBrowserWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x80];                                     // 0x0298(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	EUGCQueryType                                 LastSelectedUGCQueryType;                          // 0x0318(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUGCSortMethod                                LastSelectedUGCSortMethod;                         // 0x0319(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31A[0x6];                                      // 0x031A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPagedListWidget*                       PagedList;                                         // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUGCQueryType                                 UGCQueryType;                                      // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUGCSortMethod                                UGCSortMethod;                                     // 0x0329(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UGCSearchText;                                     // 0x0330(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowLegacyItems;                                  // 0x0340(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUGCTags                               UGCTags;                                           // 0x0341(0x0003)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EPlayerVehicleSpawnInvincibility              VehicleSpawnInvincibility;                         // 0x0344(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOrRemoveSelectedItem(bool bAdd);
	void ClearItems();
	void CreateAddOrRemoveItemButton(bool bIsArrayProperty, bool bIsSelected);
	void CreateCancelButton();
	void CreateClearItemsButton(bool bIsArrayProperty);
	void CreateDeleteButton();
	void CreateDuplicateButton();
	void CreateEditButton();
	void CreateImportButton();
	void CreateNewItem();
	void CreateNewItemButton();
	void CreateOpenInExplorerButton();
	void CreateRecoverAutoSaveButton();
	void CreateSaveNewButton();
	void CreateSaveOverwriteButton();
	void CreateSpawnButton(bool bCanReplaceCurrent, bool bCanSpawn, const class FText& SpawnFailureText);
	void CreateSpawnInvincibilityButton(const class FText& CurrentInvincibilityText);
	void CreateSubscribeButton(bool bIsSubscribed);
	void CreateUpdateExistingButton();
	void CreateUploadNewButton();
	void CreateViewInBrowserButton();
	void CreateVoteButtons(const EFluUGCItemVote Vote);
	void CycleVehicleSpawnInvincibility();
	void DeleteSelectedItem();
	void DuplicateSelectedItem();
	void EditSelectedItem();
	void FavoriteSelectedItem(bool bFavorite);
	void ImportSelectedItem();
	void OnListEntrySelected(class UPagedListEntryWidget* Widget, bool bDoubleClick);
	void OnLoadListPage(int32 NewPage);
	void OpenSelectedItemInExplorer();
	void RecoverSelectedAutoSave();
	void SaveItem(bool bOverwriteSelected);
	void SetSelectedItemVote(const EFluUGCItemVote Vote);
	void SpawnSelectedItem(bool bReplaceCurrent);
	void SubscribeSelectedItem(bool bSubscribe);
	void UploadItem(bool bUpdateSelected);
	void ViewSelectedItemInBrowser();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCBrowserWidget">();
	}
	static class UUGCBrowserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCBrowserWidget>();
	}
};
static_assert(alignof(UUGCBrowserWidget) == 0x000008, "Wrong alignment on UUGCBrowserWidget");
static_assert(sizeof(UUGCBrowserWidget) == 0x000348, "Wrong size on UUGCBrowserWidget");
static_assert(offsetof(UUGCBrowserWidget, LastSelectedUGCQueryType) == 0x000318, "Member 'UUGCBrowserWidget::LastSelectedUGCQueryType' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, LastSelectedUGCSortMethod) == 0x000319, "Member 'UUGCBrowserWidget::LastSelectedUGCSortMethod' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, PagedList) == 0x000320, "Member 'UUGCBrowserWidget::PagedList' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, UGCQueryType) == 0x000328, "Member 'UUGCBrowserWidget::UGCQueryType' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, UGCSortMethod) == 0x000329, "Member 'UUGCBrowserWidget::UGCSortMethod' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, UGCSearchText) == 0x000330, "Member 'UUGCBrowserWidget::UGCSearchText' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, bShowLegacyItems) == 0x000340, "Member 'UUGCBrowserWidget::bShowLegacyItems' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, UGCTags) == 0x000341, "Member 'UUGCBrowserWidget::UGCTags' has a wrong offset!");
static_assert(offsetof(UUGCBrowserWidget, VehicleSpawnInvincibility) == 0x000344, "Member 'UUGCBrowserWidget::VehicleSpawnInvincibility' has a wrong offset!");

// Class BrickRigs.MenuPlayerController
// 0x0038 (0x0630 - 0x05F8)
class AMenuPlayerController : public ABasePlayerController
{
public:
	class AMenuSequence*                          MenuSequence;                                      // 0x05F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                CameraLocation;                                    // 0x0600(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CameraRotation;                                    // 0x060C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CameraFOV;                                         // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            ViewTargetTransitionParams;                        // 0x061C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPlayerController">();
	}
	static class AMenuPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuPlayerController>();
	}
};
static_assert(alignof(AMenuPlayerController) == 0x000008, "Wrong alignment on AMenuPlayerController");
static_assert(sizeof(AMenuPlayerController) == 0x000630, "Wrong size on AMenuPlayerController");
static_assert(offsetof(AMenuPlayerController, MenuSequence) == 0x0005F8, "Member 'AMenuPlayerController::MenuSequence' has a wrong offset!");
static_assert(offsetof(AMenuPlayerController, CameraLocation) == 0x000600, "Member 'AMenuPlayerController::CameraLocation' has a wrong offset!");
static_assert(offsetof(AMenuPlayerController, CameraRotation) == 0x00060C, "Member 'AMenuPlayerController::CameraRotation' has a wrong offset!");
static_assert(offsetof(AMenuPlayerController, CameraFOV) == 0x000618, "Member 'AMenuPlayerController::CameraFOV' has a wrong offset!");
static_assert(offsetof(AMenuPlayerController, ViewTargetTransitionParams) == 0x00061C, "Member 'AMenuPlayerController::ViewTargetTransitionParams' has a wrong offset!");

// Class BrickRigs.TrainWheelBrickStaticInfo
// 0x0000 (0x0188 - 0x0188)
class UTrainWheelBrickStaticInfo : public UWheelBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainWheelBrickStaticInfo">();
	}
	static class UTrainWheelBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainWheelBrickStaticInfo>();
	}
};
static_assert(alignof(UTrainWheelBrickStaticInfo) == 0x000008, "Wrong alignment on UTrainWheelBrickStaticInfo");
static_assert(sizeof(UTrainWheelBrickStaticInfo) == 0x000188, "Wrong size on UTrainWheelBrickStaticInfo");

// Class BrickRigs.MenuWidget
// 0x0078 (0x02F0 - 0x0278)
class UMenuWidget : public UMainWidgetBase
{
public:
	uint8										  AssetLoader_MenuPage[0x10];
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UMenuPageWidget*                        CurrentMenuPage;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   JoinSessionPopupClass;                             // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   NetworkErrorPopupClass;                            // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddMenuPage(class UMenuPageWidget* Widget);
	void CloseMenu();
	void CreateBackButton();
	void OnClickedBack();
	void OnClickedQuickGame();
	void OnMenuContextChanged(const class FName& NewContext);
	void OpenMenu(class FName InMenu);
	void PlayMenuTransition();
	void RemoveMenuPage(class UMenuPageWidget* Widget);
	void SetTitleText(const class FText& InText);
	void ShowMenuPage(TSoftClassPtr<class UClass> WidgetClass, const class FText& TitleText);
	bool StepBack();

	bool IsMainMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuWidget">();
	}
	static class UMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuWidget>();
	}
};
static_assert(alignof(UMenuWidget) == 0x000008, "Wrong alignment on UMenuWidget");
static_assert(sizeof(UMenuWidget) == 0x0002F0, "Wrong size on UMenuWidget");
static_assert(offsetof(UMenuWidget, CurrentMenuPage) == 0x000298, "Member 'UMenuWidget::CurrentMenuPage' has a wrong offset!");
static_assert(offsetof(UMenuWidget, JoinSessionPopupClass) == 0x0002A0, "Member 'UMenuWidget::JoinSessionPopupClass' has a wrong offset!");
static_assert(offsetof(UMenuWidget, NetworkErrorPopupClass) == 0x0002C8, "Member 'UMenuWidget::NetworkErrorPopupClass' has a wrong offset!");

// Class BrickRigs.ModHook
// 0x0000 (0x0028 - 0x0028)
class UModHook final : public UObject
{
public:
	void BeginPlay();
	void EndPlay();
	void OnCharacterBeginPlay(class ABaseCharacter* Character);
	void OnPlayerControllerBeginPlay(class ABasePlayerController* PC);
	void OnSpectatorBeginPlay(class ABrickSpectatorPawn* Pawn);
	void OnVehicleBeginPlay(class ABrickVehicle* Vehicle);
	TSoftObjectPtr<class UTexture2D> OverrideBillboardTexture(const TSoftObjectPtr<class UTexture2D>& Texture, class ABillboard* Billboard);
	struct FInventoryLoadout OverrideCharacterLoadout(const struct FInventoryLoadout& Loadout, class ABaseCharacter* Character);
	TSubclassOf<class AGameModeBase> OverrideGameModeClass(TSubclassOf<class AGameModeBase> GameModeClass, const class FString& MapName, const class FString& Options, const class FString& Portal);
	TSubclassOf<class AGameStateBase> OverrideGameStateClass(TSubclassOf<class AGameStateBase> GameStateClass);
	TArray<TSubclassOf<class AInventoryItem>> OverrideLoadoutContainerItems(const TArray<TSubclassOf<class AInventoryItem>>& ItemClasses);
	bool OverrideLoadSubLevel(bool bLoadLevel, const class FString& LevelName, class UGameModeInfo* GameMode);
	bool OverrideMenu(class UMenuWidget* Widget, const class FName& Context);
	TSoftClassPtr<class UClass> OverrideMenuSequence(const TSoftClassPtr<class UClass>& SequenceClass);
	struct FWorldSetupParams OverrideMenuWorldSetupParams(const struct FWorldSetupParams& Params_0);
	TSubclassOf<class APawn> OverridePawnClass(TSubclassOf<class APawn> PawnClass, class AController* Controller);
	TSubclassOf<class APlayerCameraManager> OverridePlayerCameraManagerClass(TSubclassOf<class APlayerCameraManager> PlayerCameraManagerClass, class ABasePlayerController* PC);
	TSubclassOf<class APlayerController> OverridePlayerControllerClass(TSubclassOf<class APlayerController> PlayerControllerClass);
	TSubclassOf<class APlayerController> OverrideReplayPlayerControllerClass(TSubclassOf<class APlayerController> PlayerControllerClass);
	TSubclassOf<class ASpectatorPawn> OverrideSpectatorClass(TSubclassOf<class ASpectatorPawn> SpectatorClass);
	TSubclassOf<class ATrain> OverrideTrainClass(TSubclassOf<class ATrain> TrainClass);
	TSubclassOf<class ABrickVehicle> OverrideVehicleClass(TSubclassOf<class ABrickVehicle> VehicleClass, class ABrickPlayerController* PC, const struct FPlayerSpawnRequest& SpawnRequest);
	void PostSpawnPawn(class APawn* Pawn);
	void PostSpawnPlayerController(class APlayerController* PC);
	void PostSpawnSpectatorPawn(class ASpectatorPawn* Pawn);
	void PostSpawnVehicle(class ABrickVehicle* Vehicle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModHook">();
	}
	static class UModHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModHook>();
	}
};
static_assert(alignof(UModHook) == 0x000008, "Wrong alignment on UModHook");
static_assert(sizeof(UModHook) == 0x000028, "Wrong size on UModHook");

// Class BrickRigs.UGCMetaDataPopupWidget
// 0x0008 (0x02A0 - 0x0298)
class UUGCMetaDataPopupWidget : public UPopupWidget
{
public:
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCMetaDataPopupWidget">();
	}
	static class UUGCMetaDataPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCMetaDataPopupWidget>();
	}
};
static_assert(alignof(UUGCMetaDataPopupWidget) == 0x000008, "Wrong alignment on UUGCMetaDataPopupWidget");
static_assert(sizeof(UUGCMetaDataPopupWidget) == 0x0002A0, "Wrong size on UUGCMetaDataPopupWidget");
static_assert(offsetof(UUGCMetaDataPopupWidget, PropertiesPanel) == 0x000298, "Member 'UUGCMetaDataPopupWidget::PropertiesPanel' has a wrong offset!");

// Class BrickRigs.ModHookSubsystem
// 0x0010 (0x0040 - 0x0030)
class UModHookSubsystem final : public UWorldSubsystem
{
public:
	TArray<class UModHook*>                       ModHooks;                                          // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UModHook* GetModHookByClass(const class UObject* WorldContextObject, const TSubclassOf<class UModHook> ModHookClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModHookSubsystem">();
	}
	static class UModHookSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModHookSubsystem>();
	}
};
static_assert(alignof(UModHookSubsystem) == 0x000008, "Wrong alignment on UModHookSubsystem");
static_assert(sizeof(UModHookSubsystem) == 0x000040, "Wrong size on UModHookSubsystem");
static_assert(offsetof(UModHookSubsystem, ModHooks) == 0x000030, "Member 'UModHookSubsystem::ModHooks' has a wrong offset!");

// Class BrickRigs.MotorBrickStaticInfo
// 0x0068 (0x01E8 - 0x0180)
class UMotorBrickStaticInfo : public UFuelConsumerBrickStaticInfo
{
public:
	class USoundCue*                              MotorSoundCue;                                     // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             StartupSound;                                      // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ShiftSound;                                        // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BrakeReleaseSound;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BackFireSound;                                     // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartupTime;                                       // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         RPMRange;                                          // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ClutchRPMRange;                                    // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ShiftUpRPMRange;                                   // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ShiftDownRPMRange;                                 // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackfireRPM;                                       // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftDelay;                                        // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAutoShiftDelay;                                 // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumForwardGears;                                   // 0x01DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumReverseGears;                                   // 0x01DD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE[0x2];                                      // 0x01DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastGearSpeed;                                     // 0x01E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotorBrickStaticInfo">();
	}
	static class UMotorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotorBrickStaticInfo>();
	}
};
static_assert(alignof(UMotorBrickStaticInfo) == 0x000008, "Wrong alignment on UMotorBrickStaticInfo");
static_assert(sizeof(UMotorBrickStaticInfo) == 0x0001E8, "Wrong size on UMotorBrickStaticInfo");
static_assert(offsetof(UMotorBrickStaticInfo, MotorSoundCue) == 0x000180, "Member 'UMotorBrickStaticInfo::MotorSoundCue' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, StartupSound) == 0x000188, "Member 'UMotorBrickStaticInfo::StartupSound' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, ShiftSound) == 0x000190, "Member 'UMotorBrickStaticInfo::ShiftSound' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, BrakeReleaseSound) == 0x000198, "Member 'UMotorBrickStaticInfo::BrakeReleaseSound' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, BackFireSound) == 0x0001A0, "Member 'UMotorBrickStaticInfo::BackFireSound' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, StartupTime) == 0x0001A8, "Member 'UMotorBrickStaticInfo::StartupTime' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, Acceleration) == 0x0001AC, "Member 'UMotorBrickStaticInfo::Acceleration' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, RPMRange) == 0x0001B0, "Member 'UMotorBrickStaticInfo::RPMRange' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, ClutchRPMRange) == 0x0001B8, "Member 'UMotorBrickStaticInfo::ClutchRPMRange' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, ShiftUpRPMRange) == 0x0001C0, "Member 'UMotorBrickStaticInfo::ShiftUpRPMRange' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, ShiftDownRPMRange) == 0x0001C8, "Member 'UMotorBrickStaticInfo::ShiftDownRPMRange' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, BackfireRPM) == 0x0001D0, "Member 'UMotorBrickStaticInfo::BackfireRPM' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, ShiftDelay) == 0x0001D4, "Member 'UMotorBrickStaticInfo::ShiftDelay' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, MinAutoShiftDelay) == 0x0001D8, "Member 'UMotorBrickStaticInfo::MinAutoShiftDelay' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, NumForwardGears) == 0x0001DC, "Member 'UMotorBrickStaticInfo::NumForwardGears' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, NumReverseGears) == 0x0001DD, "Member 'UMotorBrickStaticInfo::NumReverseGears' has a wrong offset!");
static_assert(offsetof(UMotorBrickStaticInfo, LastGearSpeed) == 0x0001E0, "Member 'UMotorBrickStaticInfo::LastGearSpeed' has a wrong offset!");

// Class BrickRigs.VehicleEditor
// 0x0058 (0x0530 - 0x04D8)
class AVehicleEditor : public ABrickEditor
{
public:
	uint8                                         Pad_4D8[0x50];                                     // 0x04D8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          InputChannelISMComp;                               // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleEditor">();
	}
	static class AVehicleEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleEditor>();
	}
};
static_assert(alignof(AVehicleEditor) == 0x000008, "Wrong alignment on AVehicleEditor");
static_assert(sizeof(AVehicleEditor) == 0x000530, "Wrong size on AVehicleEditor");
static_assert(offsetof(AVehicleEditor, InputChannelISMComp) == 0x000528, "Member 'AVehicleEditor::InputChannelISMComp' has a wrong offset!");

// Class BrickRigs.MotorBrick
// 0x00C0 (0x01C0 - 0x0100)
class UMotorBrick final : public UFuelConsumerBrick
{
public:
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAxleBrick*>                     ConnectedAxles;                                    // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x30];                                     // 0x0130(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   ThrottleInputChannel;                              // 0x0160(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GearRatioScale;                                    // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTankDrive;                                        // 0x018C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x33];                                     // 0x018D(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotorBrick">();
	}
	static class UMotorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotorBrick>();
	}
};
static_assert(alignof(UMotorBrick) == 0x000008, "Wrong alignment on UMotorBrick");
static_assert(sizeof(UMotorBrick) == 0x0001C0, "Wrong size on UMotorBrick");
static_assert(offsetof(UMotorBrick, ConnectedAxles) == 0x000120, "Member 'UMotorBrick::ConnectedAxles' has a wrong offset!");
static_assert(offsetof(UMotorBrick, ThrottleInputChannel) == 0x000160, "Member 'UMotorBrick::ThrottleInputChannel' has a wrong offset!");
static_assert(offsetof(UMotorBrick, GearRatioScale) == 0x000188, "Member 'UMotorBrick::GearRatioScale' has a wrong offset!");
static_assert(offsetof(UMotorBrick, bTankDrive) == 0x00018C, "Member 'UMotorBrick::bTankDrive' has a wrong offset!");

// Class BrickRigs.MudguardBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UMudguardBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MudguardBrickStaticInfo">();
	}
	static class UMudguardBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMudguardBrickStaticInfo>();
	}
};
static_assert(alignof(UMudguardBrickStaticInfo) == 0x000008, "Wrong alignment on UMudguardBrickStaticInfo");
static_assert(sizeof(UMudguardBrickStaticInfo) == 0x000168, "Wrong size on UMudguardBrickStaticInfo");

// Class BrickRigs.UGCItemWidget
// 0x0108 (0x0390 - 0x0288)
class UUGCItemWidget : public UPagedListEntryWidget
{
public:
	struct FUGCFileInfo                           Entry;                                             // 0x0288(0x00E8)(Transient, NativeAccessSpecifierPrivate)
	class UBrickImage*                            Image;                                             // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThumbnailRoundedEdgeRadius;                        // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ThumbnailShadowOffset;                             // 0x0384(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateItemWidget(bool bInIsSelected, bool bInIsLegacyFile, bool bInHasAutoSave, bool bInIsDedicatedAutoSave);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCItemWidget">();
	}
	static class UUGCItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCItemWidget>();
	}
};
static_assert(alignof(UUGCItemWidget) == 0x000008, "Wrong alignment on UUGCItemWidget");
static_assert(sizeof(UUGCItemWidget) == 0x000390, "Wrong size on UUGCItemWidget");
static_assert(offsetof(UUGCItemWidget, Entry) == 0x000288, "Member 'UUGCItemWidget::Entry' has a wrong offset!");
static_assert(offsetof(UUGCItemWidget, Image) == 0x000370, "Member 'UUGCItemWidget::Image' has a wrong offset!");
static_assert(offsetof(UUGCItemWidget, NameTextBlock) == 0x000378, "Member 'UUGCItemWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UUGCItemWidget, ThumbnailRoundedEdgeRadius) == 0x000380, "Member 'UUGCItemWidget::ThumbnailRoundedEdgeRadius' has a wrong offset!");
static_assert(offsetof(UUGCItemWidget, ThumbnailShadowOffset) == 0x000384, "Member 'UUGCItemWidget::ThumbnailShadowOffset' has a wrong offset!");

// Class BrickRigs.NetworkErrorPopupParams
// 0x0000 (0x0068 - 0x0068)
class UNetworkErrorPopupParams final : public UPopupParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkErrorPopupParams">();
	}
	static class UNetworkErrorPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkErrorPopupParams>();
	}
};
static_assert(alignof(UNetworkErrorPopupParams) == 0x000008, "Wrong alignment on UNetworkErrorPopupParams");
static_assert(sizeof(UNetworkErrorPopupParams) == 0x000068, "Wrong size on UNetworkErrorPopupParams");

// Class BrickRigs.NetworkErrorPopupWidget
// 0x0008 (0x02A0 - 0x0298)
class UNetworkErrorPopupWidget : public UPopupWidget
{
public:
	class UBrickTextBlock*                        MessageTextBlock;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkErrorPopupWidget">();
	}
	static class UNetworkErrorPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkErrorPopupWidget>();
	}
};
static_assert(alignof(UNetworkErrorPopupWidget) == 0x000008, "Wrong alignment on UNetworkErrorPopupWidget");
static_assert(sizeof(UNetworkErrorPopupWidget) == 0x0002A0, "Wrong size on UNetworkErrorPopupWidget");
static_assert(offsetof(UNetworkErrorPopupWidget, MessageTextBlock) == 0x000298, "Member 'UNetworkErrorPopupWidget::MessageTextBlock' has a wrong offset!");

// Class BrickRigs.UnsavedChangesPopupWidget
// 0x0000 (0x0298 - 0x0298)
class UUnsavedChangesPopupWidget : public UPopupWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnsavedChangesPopupWidget">();
	}
	static class UUnsavedChangesPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnsavedChangesPopupWidget>();
	}
};
static_assert(alignof(UUnsavedChangesPopupWidget) == 0x000008, "Wrong alignment on UUnsavedChangesPopupWidget");
static_assert(sizeof(UUnsavedChangesPopupWidget) == 0x000298, "Wrong size on UUnsavedChangesPopupWidget");

// Class BrickRigs.NewItemCountWidget
// 0x0008 (0x0268 - 0x0260)
class UNewItemCountWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNumNewItems(int32 NewNum);
	void UpdateNumItems(int32 NewNum);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewItemCountWidget">();
	}
	static class UNewItemCountWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewItemCountWidget>();
	}
};
static_assert(alignof(UNewItemCountWidget) == 0x000008, "Wrong alignment on UNewItemCountWidget");
static_assert(sizeof(UNewItemCountWidget) == 0x000268, "Wrong size on UNewItemCountWidget");

// Class BrickRigs.WheelHubBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UWheelHubBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WheelHubBrickStaticInfo">();
	}
	static class UWheelHubBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWheelHubBrickStaticInfo>();
	}
};
static_assert(alignof(UWheelHubBrickStaticInfo) == 0x000008, "Wrong alignment on UWheelHubBrickStaticInfo");
static_assert(sizeof(UWheelHubBrickStaticInfo) == 0x000168, "Wrong size on UWheelHubBrickStaticInfo");

// Class BrickRigs.ObjectPropertyItemInterface
// 0x0000 (0x0000 - 0x0000)
class IObjectPropertyItemInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPropertyItemInterface">();
	}
	static class IObjectPropertyItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IObjectPropertyItemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IObjectPropertyItemInterface) == 0x000001, "Wrong alignment on IObjectPropertyItemInterface");
static_assert(sizeof(IObjectPropertyItemInterface) == 0x000001, "Wrong size on IObjectPropertyItemInterface");

// Class BrickRigs.PagedListHeaderWidget
// 0x0060 (0x02C0 - 0x0260)
class UPagedListHeaderWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x60];                                     // 0x0260(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMeasurementSystemChanged(EMeasurementSystem NewSystem);
	void UpdateDimensions(const struct FVector& InDimensions, const struct FVector& InMaxDimensions);
	void UpdateEntry(const class FText& InTitleText, bool bInHasEntry, bool bInHasUnsavedChanges);
	void UpdateMass(float InMass, float InMaxMass);
	void UpdateNumObjects(int32 InNumObjects, int32 InMaxNumObjects, int32 InNumHiddenObjects, int32 InNumObjectsWithAerodynamics);
	void UpdatePrice(float InPrice, float InMoney);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PagedListHeaderWidget">();
	}
	static class UPagedListHeaderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPagedListHeaderWidget>();
	}
};
static_assert(alignof(UPagedListHeaderWidget) == 0x000008, "Wrong alignment on UPagedListHeaderWidget");
static_assert(sizeof(UPagedListHeaderWidget) == 0x0002C0, "Wrong size on UPagedListHeaderWidget");

// Class BrickRigs.VehicleResourceSubsystem
// 0x0080 (0x00B0 - 0x0030)
class UVehicleResourceSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UVehicleResourceSubsystem* Get(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleResourceSubsystem">();
	}
	static class UVehicleResourceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleResourceSubsystem>();
	}
};
static_assert(alignof(UVehicleResourceSubsystem) == 0x000008, "Wrong alignment on UVehicleResourceSubsystem");
static_assert(sizeof(UVehicleResourceSubsystem) == 0x0000B0, "Wrong size on UVehicleResourceSubsystem");

// Class BrickRigs.PagedListWidget
// 0x00A0 (0x0300 - 0x0260)
class UPagedListWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPagedListEntryWidget*>          EntryWidgets;                                      // 0x0268(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_278[0x18];                                     // 0x0278(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBox;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPageSelectorWidget*                    PageSelector;                                      // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickGridPanel*                        EntriesPanel;                                      // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPropertiesPanelWidget*                 PropertiesPanel;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPagedListHeaderWidget*                 SelectedEntryHeaderWidget;                         // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPagedListEntryWidget>      EntryWidgetClass;                                  // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumEntriesPerRow;                                  // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumEntriesPerPage;                                 // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbsoluteEntryIndices;                          // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x17];                                     // 0x02C9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 NewPage)> OnLoadPageDelegate;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UPagedListEntryWidget* Widget, bool bDoubleClick)> OnEntrySelectedDelegate; // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool ClearSelectedEntryWidget();
	void InitializePropertiesPanel(class UObject* Container);
	void OnEntriesLoaded(int32 InTotalNumEntries, int32 InMaxPages);
	void OnPageChanged(int32 NewPage);
	void RefreshEntries();
	void SetCurrentPage(int32 InPage);
	void UpdateIsEntrySelected(bool bIsEntrySelected);
	void UpdateIsLoading(bool bNewLoading);

	int32 GetCurrentPage() const;
	class UPagedListEntryWidget* GetSelectedEntryWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PagedListWidget">();
	}
	static class UPagedListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPagedListWidget>();
	}
};
static_assert(alignof(UPagedListWidget) == 0x000008, "Wrong alignment on UPagedListWidget");
static_assert(sizeof(UPagedListWidget) == 0x000300, "Wrong size on UPagedListWidget");
static_assert(offsetof(UPagedListWidget, EntryWidgets) == 0x000268, "Member 'UPagedListWidget::EntryWidgets' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, ScrollBox) == 0x000290, "Member 'UPagedListWidget::ScrollBox' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, PageSelector) == 0x000298, "Member 'UPagedListWidget::PageSelector' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, EntriesPanel) == 0x0002A0, "Member 'UPagedListWidget::EntriesPanel' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, PropertiesPanel) == 0x0002A8, "Member 'UPagedListWidget::PropertiesPanel' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, SelectedEntryHeaderWidget) == 0x0002B0, "Member 'UPagedListWidget::SelectedEntryHeaderWidget' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, EntryWidgetClass) == 0x0002B8, "Member 'UPagedListWidget::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, NumEntriesPerRow) == 0x0002C0, "Member 'UPagedListWidget::NumEntriesPerRow' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, NumEntriesPerPage) == 0x0002C4, "Member 'UPagedListWidget::NumEntriesPerPage' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, bUseAbsoluteEntryIndices) == 0x0002C8, "Member 'UPagedListWidget::bUseAbsoluteEntryIndices' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, OnLoadPageDelegate) == 0x0002E0, "Member 'UPagedListWidget::OnLoadPageDelegate' has a wrong offset!");
static_assert(offsetof(UPagedListWidget, OnEntrySelectedDelegate) == 0x0002F0, "Member 'UPagedListWidget::OnEntrySelectedDelegate' has a wrong offset!");

// Class BrickRigs.PageSelectorWidget
// 0x0020 (0x0280 - 0x0260)
class UPageSelectorWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x4];                                      // 0x0260(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumPages;                                          // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickSliderWidget*                     Slider;                                            // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 Page)>    OnPageChangedDelegate;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void GotoNextPage(bool bForward, bool bSkipToEnd);
	void InitializePages(int32 InNumPages, int32 InCurrentPage, int32 InNumResults);
	void OnSliderValueChanged(float NewValue, EValueChangedEventType EventType);
	void SetCurrentPage(int32 NewPage);
	void UpdateButtons(bool bCanGoBack, bool bCanGoForward);

	int32 GetCurrentPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PageSelectorWidget">();
	}
	static class UPageSelectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPageSelectorWidget>();
	}
};
static_assert(alignof(UPageSelectorWidget) == 0x000008, "Wrong alignment on UPageSelectorWidget");
static_assert(sizeof(UPageSelectorWidget) == 0x000280, "Wrong size on UPageSelectorWidget");
static_assert(offsetof(UPageSelectorWidget, NumPages) == 0x000264, "Member 'UPageSelectorWidget::NumPages' has a wrong offset!");
static_assert(offsetof(UPageSelectorWidget, Slider) == 0x000268, "Member 'UPageSelectorWidget::Slider' has a wrong offset!");
static_assert(offsetof(UPageSelectorWidget, OnPageChangedDelegate) == 0x000270, "Member 'UPageSelectorWidget::OnPageChangedDelegate' has a wrong offset!");

// Class BrickRigs.UnequipAction
// 0x0000 (0x0098 - 0x0098)
class UUnequipAction final : public UItemAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnequipAction">();
	}
	static class UUnequipAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnequipAction>();
	}
};
static_assert(alignof(UUnequipAction) == 0x000008, "Wrong alignment on UUnequipAction");
static_assert(sizeof(UUnequipAction) == 0x000098, "Wrong size on UUnequipAction");

// Class BrickRigs.PaintAttachmentStaticInfo
// 0x0000 (0x0390 - 0x0390)
class UPaintAttachmentStaticInfo : public UAttachmentStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PaintAttachmentStaticInfo">();
	}
	static class UPaintAttachmentStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPaintAttachmentStaticInfo>();
	}
};
static_assert(alignof(UPaintAttachmentStaticInfo) == 0x000010, "Wrong alignment on UPaintAttachmentStaticInfo");
static_assert(sizeof(UPaintAttachmentStaticInfo) == 0x000390, "Wrong size on UPaintAttachmentStaticInfo");

// Class BrickRigs.PassengerInputComponent
// 0x0000 (0x02A0 - 0x02A0)
class UPassengerInputComponent final : public UVehicleInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassengerInputComponent">();
	}
	static class UPassengerInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassengerInputComponent>();
	}
};
static_assert(alignof(UPassengerInputComponent) == 0x000008, "Wrong alignment on UPassengerInputComponent");
static_assert(sizeof(UPassengerInputComponent) == 0x0002A0, "Wrong size on UPassengerInputComponent");

// Class BrickRigs.PendingLevelPlayerController
// 0x0000 (0x05F8 - 0x05F8)
class APendingLevelPlayerController final : public ABasePlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PendingLevelPlayerController">();
	}
	static class APendingLevelPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APendingLevelPlayerController>();
	}
};
static_assert(alignof(APendingLevelPlayerController) == 0x000008, "Wrong alignment on APendingLevelPlayerController");
static_assert(sizeof(APendingLevelPlayerController) == 0x0005F8, "Wrong size on APendingLevelPlayerController");

// Class BrickRigs.PlacableObjectInputComponent
// 0x0018 (0x0198 - 0x0180)
class UPlacableObjectInputComponent final : public UBaseEditorInputComponent
{
public:
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressedSelectByPlacableType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlacableObjectInputComponent">();
	}
	static class UPlacableObjectInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlacableObjectInputComponent>();
	}
};
static_assert(alignof(UPlacableObjectInputComponent) == 0x000008, "Wrong alignment on UPlacableObjectInputComponent");
static_assert(sizeof(UPlacableObjectInputComponent) == 0x000198, "Wrong size on UPlacableObjectInputComponent");

// Class BrickRigs.PlayerControllerStaticInfo
// 0x02C0 (0x02E8 - 0x0028)
class UPlayerControllerStaticInfo : public UObject
{
public:
	struct FCameraFadeParams                      LevelTransitionFade;                               // 0x0028(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraFadeParams                      StateTransitionFade;                               // 0x0044(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FCameraFadeParams                      MatchEndFade;                                      // 0x0060(0x001C)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MaxNumChatMessages;                                // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   JoinSessionPopupClass;                             // 0x0080(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MapPopupClass;                                     // 0x00A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ScoreboardPopupClass;                              // 0x00D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   InventoryPopupClass;                               // 0x00F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   VehicleBrowserPopupClass;                          // 0x0120(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UnsavedChangesPopupClass;                          // 0x0148(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CheatMenuPopupClass;                               // 0x0170(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   KickPlayerPopupClass;                              // 0x0198(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayerHUDWidgetClass;                              // 0x01C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SpawnHUDWidgetClass;                               // 0x01E8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DeathHUDWidgetClass;                               // 0x0210(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SpectatorHUDWidgetClass;                           // 0x0238(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EditorHUDWidgetClass;                              // 0x0260(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MatchEndHUDWidgetClass;                            // 0x0288(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInteractionAngle;                               // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCharacterInteractionDistance;                   // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehicleHUDIconDrawDistanceScale;                   // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpectatorHUDIconDrawDistanceScale;                 // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              DeathSoundMix;                                     // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              NoAtmosphereSoundMix;                              // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             HurtSound;                                         // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AVehicleEditor>             VehicleEditorClass;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EditorEntryGarageInflation;                        // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientVehicleDamageGracePeriod;                    // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerStaticInfo">();
	}
	static class UPlayerControllerStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerControllerStaticInfo>();
	}
};
static_assert(alignof(UPlayerControllerStaticInfo) == 0x000008, "Wrong alignment on UPlayerControllerStaticInfo");
static_assert(sizeof(UPlayerControllerStaticInfo) == 0x0002E8, "Wrong size on UPlayerControllerStaticInfo");
static_assert(offsetof(UPlayerControllerStaticInfo, LevelTransitionFade) == 0x000028, "Member 'UPlayerControllerStaticInfo::LevelTransitionFade' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, StateTransitionFade) == 0x000044, "Member 'UPlayerControllerStaticInfo::StateTransitionFade' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MatchEndFade) == 0x000060, "Member 'UPlayerControllerStaticInfo::MatchEndFade' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MaxNumChatMessages) == 0x00007C, "Member 'UPlayerControllerStaticInfo::MaxNumChatMessages' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, JoinSessionPopupClass) == 0x000080, "Member 'UPlayerControllerStaticInfo::JoinSessionPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MapPopupClass) == 0x0000A8, "Member 'UPlayerControllerStaticInfo::MapPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, ScoreboardPopupClass) == 0x0000D0, "Member 'UPlayerControllerStaticInfo::ScoreboardPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, InventoryPopupClass) == 0x0000F8, "Member 'UPlayerControllerStaticInfo::InventoryPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, VehicleBrowserPopupClass) == 0x000120, "Member 'UPlayerControllerStaticInfo::VehicleBrowserPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, UnsavedChangesPopupClass) == 0x000148, "Member 'UPlayerControllerStaticInfo::UnsavedChangesPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, CheatMenuPopupClass) == 0x000170, "Member 'UPlayerControllerStaticInfo::CheatMenuPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, KickPlayerPopupClass) == 0x000198, "Member 'UPlayerControllerStaticInfo::KickPlayerPopupClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, PlayerHUDWidgetClass) == 0x0001C0, "Member 'UPlayerControllerStaticInfo::PlayerHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, SpawnHUDWidgetClass) == 0x0001E8, "Member 'UPlayerControllerStaticInfo::SpawnHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, DeathHUDWidgetClass) == 0x000210, "Member 'UPlayerControllerStaticInfo::DeathHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, SpectatorHUDWidgetClass) == 0x000238, "Member 'UPlayerControllerStaticInfo::SpectatorHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, EditorHUDWidgetClass) == 0x000260, "Member 'UPlayerControllerStaticInfo::EditorHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MatchEndHUDWidgetClass) == 0x000288, "Member 'UPlayerControllerStaticInfo::MatchEndHUDWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MaxInteractionAngle) == 0x0002B0, "Member 'UPlayerControllerStaticInfo::MaxInteractionAngle' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, MaxCharacterInteractionDistance) == 0x0002B4, "Member 'UPlayerControllerStaticInfo::MaxCharacterInteractionDistance' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, VehicleHUDIconDrawDistanceScale) == 0x0002B8, "Member 'UPlayerControllerStaticInfo::VehicleHUDIconDrawDistanceScale' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, SpectatorHUDIconDrawDistanceScale) == 0x0002BC, "Member 'UPlayerControllerStaticInfo::SpectatorHUDIconDrawDistanceScale' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, DeathSoundMix) == 0x0002C0, "Member 'UPlayerControllerStaticInfo::DeathSoundMix' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, NoAtmosphereSoundMix) == 0x0002C8, "Member 'UPlayerControllerStaticInfo::NoAtmosphereSoundMix' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, HurtSound) == 0x0002D0, "Member 'UPlayerControllerStaticInfo::HurtSound' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, VehicleEditorClass) == 0x0002D8, "Member 'UPlayerControllerStaticInfo::VehicleEditorClass' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, EditorEntryGarageInflation) == 0x0002E0, "Member 'UPlayerControllerStaticInfo::EditorEntryGarageInflation' has a wrong offset!");
static_assert(offsetof(UPlayerControllerStaticInfo, ClientVehicleDamageGracePeriod) == 0x0002E4, "Member 'UPlayerControllerStaticInfo::ClientVehicleDamageGracePeriod' has a wrong offset!");

// Class BrickRigs.PlayerInputComponent
// 0x0098 (0x0208 - 0x0170)
class UPlayerInputComponent final : public UBaseInputComponent
{
public:
	uint8                                         Pad_170[0x90];                                     // 0x0170(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionComponent*                  FocusedBrickInteractionComponent;                  // 0x0200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InteractAxis(float Val);
	void OnPressedChat();
	void OnPressedCycleMeasurementSystem();
	void OnPressedInteractPri();
	void OnPressedInteractSec();
	void OnPressedInteractTer();
	void OnPressedMoveCamera();
	void OnPressedScoreboard();
	void OnReleasedInteractPri();
	void OnReleasedInteractSec();
	void OnReleasedInteractTer();
	void OnReleasedMoveCamera();

	class FText GetCycleMeasurementSystemValueText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInputComponent">();
	}
	static class UPlayerInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInputComponent>();
	}
};
static_assert(alignof(UPlayerInputComponent) == 0x000008, "Wrong alignment on UPlayerInputComponent");
static_assert(sizeof(UPlayerInputComponent) == 0x000208, "Wrong size on UPlayerInputComponent");
static_assert(offsetof(UPlayerInputComponent, FocusedBrickInteractionComponent) == 0x000200, "Member 'UPlayerInputComponent::FocusedBrickInteractionComponent' has a wrong offset!");

// Class BrickRigs.PlayerWidget
// 0x0210 (0x0520 - 0x0310)
class alignas(0x10) UPlayerWidget : public UHUDIconCanvasWidget
{
public:
	uint8                                         Pad_310[0x38];                                     // 0x0310(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseCharacter*                         Character;                                         // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABrickVehicle*                          Vehicle;                                           // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x18];                                     // 0x0358(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurrentItemWidget*                     CurrentItemWidget;                                 // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHealthBarWidget*                       HealthBarWidget;                                   // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCrosshairWidget*                       CrosshairWidget;                                   // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UHurtMarkerWidget*>              HurtMarkers;                                       // 0x0388(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class URestrictedAreaWidget*                  RestrictedAreaWidget;                              // 0x0398(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDashboardWidget*                       DashboardWidget;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraBrickWidget*                     CameraBrickWidget;                                 // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x104];                                    // 0x03B0(0x0104)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         IconScaleDistanceRange;                            // 0x04B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCurrentItemWidget>         CurrentItemWidgetClass;                            // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentItemFadeOutDelay;                           // 0x04C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHealthBarWidget>           HealthBarWidgetClass;                              // 0x04D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCrosshairWidget>           CrosshairWidgetClass;                              // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHurtMarkerWidget>          HurtMarkerClass;                                   // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumHurtMarkers;                                 // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class URestrictedAreaWidget>      RestrictedAreaWidgetClass;                         // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   DashboardWidgetClass;                              // 0x04F8(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddCameraBrickWidget(class UCameraBrickWidget* InWidget);
	void AddCrosshairWidget(class UCrosshairWidget* InWidget);
	void AddCurrentItemWidget(class UCurrentItemWidget* InWidget);
	void AddDashboardWidget(class UDashboardWidget* InWidget);
	void AddHealthBarWidget(class UHealthBarWidget* InWidget);
	void AddRestrictedAreaWidget(class URestrictedAreaWidget* InWidget);
	void OnHUDVisibilityChanged(EHUDVisibility NewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerWidget">();
	}
	static class UPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerWidget>();
	}
};
static_assert(alignof(UPlayerWidget) == 0x000010, "Wrong alignment on UPlayerWidget");
static_assert(sizeof(UPlayerWidget) == 0x000520, "Wrong size on UPlayerWidget");
static_assert(offsetof(UPlayerWidget, Character) == 0x000348, "Member 'UPlayerWidget::Character' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, Vehicle) == 0x000350, "Member 'UPlayerWidget::Vehicle' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CurrentItemWidget) == 0x000370, "Member 'UPlayerWidget::CurrentItemWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, HealthBarWidget) == 0x000378, "Member 'UPlayerWidget::HealthBarWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CrosshairWidget) == 0x000380, "Member 'UPlayerWidget::CrosshairWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, HurtMarkers) == 0x000388, "Member 'UPlayerWidget::HurtMarkers' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, RestrictedAreaWidget) == 0x000398, "Member 'UPlayerWidget::RestrictedAreaWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, DashboardWidget) == 0x0003A0, "Member 'UPlayerWidget::DashboardWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CameraBrickWidget) == 0x0003A8, "Member 'UPlayerWidget::CameraBrickWidget' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, IconScaleDistanceRange) == 0x0004B4, "Member 'UPlayerWidget::IconScaleDistanceRange' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CurrentItemWidgetClass) == 0x0004C0, "Member 'UPlayerWidget::CurrentItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CurrentItemFadeOutDelay) == 0x0004C8, "Member 'UPlayerWidget::CurrentItemFadeOutDelay' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, HealthBarWidgetClass) == 0x0004D0, "Member 'UPlayerWidget::HealthBarWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, CrosshairWidgetClass) == 0x0004D8, "Member 'UPlayerWidget::CrosshairWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, HurtMarkerClass) == 0x0004E0, "Member 'UPlayerWidget::HurtMarkerClass' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, MaxNumHurtMarkers) == 0x0004E8, "Member 'UPlayerWidget::MaxNumHurtMarkers' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, RestrictedAreaWidgetClass) == 0x0004F0, "Member 'UPlayerWidget::RestrictedAreaWidgetClass' has a wrong offset!");
static_assert(offsetof(UPlayerWidget, DashboardWidgetClass) == 0x0004F8, "Member 'UPlayerWidget::DashboardWidgetClass' has a wrong offset!");

// Class BrickRigs.MessagePopupParams
// 0x0020 (0x0088 - 0x0068)
class UMessagePopupParams final : public UPopupParams
{
public:
	class FText                                   TitleText;                                         // 0x0068(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCanCancel;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MessagePopupParams">();
	}
	static class UMessagePopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMessagePopupParams>();
	}
};
static_assert(alignof(UMessagePopupParams) == 0x000008, "Wrong alignment on UMessagePopupParams");
static_assert(sizeof(UMessagePopupParams) == 0x000088, "Wrong size on UMessagePopupParams");
static_assert(offsetof(UMessagePopupParams, TitleText) == 0x000068, "Member 'UMessagePopupParams::TitleText' has a wrong offset!");
static_assert(offsetof(UMessagePopupParams, bCanCancel) == 0x000080, "Member 'UMessagePopupParams::bCanCancel' has a wrong offset!");

// Class BrickRigs.ProjectileManagerComponent
// 0x0150 (0x0200 - 0x00B0)
class UProjectileManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x150];                                     // 0x00B0(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleComponentFinished(class UParticleSystemComponent* PSC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileManagerComponent">();
	}
	static class UProjectileManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileManagerComponent>();
	}
};
static_assert(alignof(UProjectileManagerComponent) == 0x000008, "Wrong alignment on UProjectileManagerComponent");
static_assert(sizeof(UProjectileManagerComponent) == 0x000200, "Wrong size on UProjectileManagerComponent");

// Class BrickRigs.PropellerBrick
// 0x0000 (0x00F8 - 0x00F8)
class UPropellerBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropellerBrick">();
	}
	static class UPropellerBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropellerBrick>();
	}
};
static_assert(alignof(UPropellerBrick) == 0x000008, "Wrong alignment on UPropellerBrick");
static_assert(sizeof(UPropellerBrick) == 0x0000F8, "Wrong size on UPropellerBrick");

// Class BrickRigs.PropertyCategoryWidget
// 0x0018 (0x0278 - 0x0260)
class UPropertyCategoryWidget : public UUserWidget
{
public:
	int											  CategoryIndex;
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateCategory(const class FText& DisplayName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyCategoryWidget">();
	}
	static class UPropertyCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyCategoryWidget>();
	}
};
static_assert(alignof(UPropertyCategoryWidget) == 0x000008, "Wrong alignment on UPropertyCategoryWidget");
static_assert(sizeof(UPropertyCategoryWidget) == 0x000278, "Wrong size on UPropertyCategoryWidget");

// Class BrickRigs.PropertyContainerWidget
// 0x0058 (0x02C8 - 0x0270)
class UPropertyContainerWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x30];                                     // 0x0270(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UPropertyWidget*                        PropertyWidget;                                    // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x10];                                     // 0x02A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuButtonPanelWidget*                 ButtonPanelWidget;                                 // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPropertyWidget(class UPropertyWidget* Widget, EOrientation InOrientation);
	bool OpenContextMenu();
	void PostAddPropertyButtons();
	void PreAddPropertyButtons();
	void UpdateColorStyle(EBrickUIColorStyle InColorStyle);
	void UpdateIsReadOnly(bool bInReadOnly);
	void UpdateOrientation(EOrientation InOrientation);

	class UMenuButtonPanelWidget* GetMenuButtonPanelWidget() const;
	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropertyContainerWidget">();
	}
	static class UPropertyContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertyContainerWidget>();
	}
};
static_assert(alignof(UPropertyContainerWidget) == 0x000008, "Wrong alignment on UPropertyContainerWidget");
static_assert(sizeof(UPropertyContainerWidget) == 0x0002C8, "Wrong size on UPropertyContainerWidget");
static_assert(offsetof(UPropertyContainerWidget, PropertyWidget) == 0x0002A0, "Member 'UPropertyContainerWidget::PropertyWidget' has a wrong offset!");
static_assert(offsetof(UPropertyContainerWidget, NameTextBlock) == 0x0002B8, "Member 'UPropertyContainerWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UPropertyContainerWidget, ButtonPanelWidget) == 0x0002C0, "Member 'UPropertyContainerWidget::ButtonPanelWidget' has a wrong offset!");

// Class BrickRigs.PumpBrickStaticInfo
// 0x0068 (0x01D0 - 0x0168)
class UPumpBrickStaticInfo : public UBrickStaticInfo
{
public:
	struct FFireExtinguisherProperties            ExtinguisherProperties;                            // 0x0168(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PumpBrickStaticInfo">();
	}
	static class UPumpBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPumpBrickStaticInfo>();
	}
};
static_assert(alignof(UPumpBrickStaticInfo) == 0x000008, "Wrong alignment on UPumpBrickStaticInfo");
static_assert(sizeof(UPumpBrickStaticInfo) == 0x0001D0, "Wrong size on UPumpBrickStaticInfo");
static_assert(offsetof(UPumpBrickStaticInfo, ExtinguisherProperties) == 0x000168, "Member 'UPumpBrickStaticInfo::ExtinguisherProperties' has a wrong offset!");

// Class BrickRigs.RaceTimer
// 0x0010 (0x0230 - 0x0220)
class ARaceTimer : public AActor
{
public:
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextRenderComponent*                   TextRenderComponent;                               // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RaceTimer">();
	}
	static class ARaceTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARaceTimer>();
	}
};
static_assert(alignof(ARaceTimer) == 0x000008, "Wrong alignment on ARaceTimer");
static_assert(sizeof(ARaceTimer) == 0x000230, "Wrong size on ARaceTimer");
static_assert(offsetof(ARaceTimer, MeshComponent) == 0x000220, "Member 'ARaceTimer::MeshComponent' has a wrong offset!");
static_assert(offsetof(ARaceTimer, TextRenderComponent) == 0x000228, "Member 'ARaceTimer::TextRenderComponent' has a wrong offset!");

// Class BrickRigs.RadioButtonWidget
// 0x0008 (0x0278 - 0x0270)
class URadioButtonWidget final : public UBrickUserWidget
{
public:
	class UBrickButtonWidget*                     Button;                                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRadioButtonClicked();
	void SetIsSelected(bool bNewSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RadioButtonWidget">();
	}
	static class URadioButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URadioButtonWidget>();
	}
};
static_assert(alignof(URadioButtonWidget) == 0x000008, "Wrong alignment on URadioButtonWidget");
static_assert(sizeof(URadioButtonWidget) == 0x000278, "Wrong size on URadioButtonWidget");
static_assert(offsetof(URadioButtonWidget, Button) == 0x000270, "Member 'URadioButtonWidget::Button' has a wrong offset!");

// Class BrickRigs.RCBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class URCBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RCBrickStaticInfo">();
	}
	static class URCBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URCBrickStaticInfo>();
	}
};
static_assert(alignof(URCBrickStaticInfo) == 0x000008, "Wrong alignment on URCBrickStaticInfo");
static_assert(sizeof(URCBrickStaticInfo) == 0x0001A0, "Wrong size on URCBrickStaticInfo");

// Class BrickRigs.RedirectorBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class URedirectorBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedirectorBrickStaticInfo">();
	}
	static class URedirectorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedirectorBrickStaticInfo>();
	}
};
static_assert(alignof(URedirectorBrickStaticInfo) == 0x000008, "Wrong alignment on URedirectorBrickStaticInfo");
static_assert(sizeof(URedirectorBrickStaticInfo) == 0x000168, "Wrong size on URedirectorBrickStaticInfo");

// Class BrickRigs.RestrictedAreaVolume
// 0x0008 (0x0260 - 0x0258)
class ARestrictedAreaVolume final : public AVolume
{
public:
	bool                                          bInvertVolume;                                     // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillDelay;                                         // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedAreaVolume">();
	}
	static class ARestrictedAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARestrictedAreaVolume>();
	}
};
static_assert(alignof(ARestrictedAreaVolume) == 0x000008, "Wrong alignment on ARestrictedAreaVolume");
static_assert(sizeof(ARestrictedAreaVolume) == 0x000260, "Wrong size on ARestrictedAreaVolume");
static_assert(offsetof(ARestrictedAreaVolume, bInvertVolume) == 0x000258, "Member 'ARestrictedAreaVolume::bInvertVolume' has a wrong offset!");
static_assert(offsetof(ARestrictedAreaVolume, KillDelay) == 0x00025C, "Member 'ARestrictedAreaVolume::KillDelay' has a wrong offset!");

// Class BrickRigs.ReuploadPopupParams
// 0x00E8 (0x0150 - 0x0068)
class UReuploadPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0xE8];                                      // 0x0068(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReuploadPopupParams">();
	}
	static class UReuploadPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReuploadPopupParams>();
	}
};
static_assert(alignof(UReuploadPopupParams) == 0x000008, "Wrong alignment on UReuploadPopupParams");
static_assert(sizeof(UReuploadPopupParams) == 0x000150, "Wrong size on UReuploadPopupParams");

// Class BrickRigs.RotorBladeBrick
// 0x0000 (0x00F8 - 0x00F8)
class URotorBladeBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotorBladeBrick">();
	}
	static class URotorBladeBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<URotorBladeBrick>();
	}
};
static_assert(alignof(URotorBladeBrick) == 0x000008, "Wrong alignment on URotorBladeBrick");
static_assert(sizeof(URotorBladeBrick) == 0x0000F8, "Wrong size on URotorBladeBrick");

// Class BrickRigs.RotorBrick
// 0x0008 (0x0100 - 0x00F8)
class URotorBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotorBrick">();
	}
	static class URotorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<URotorBrick>();
	}
};
static_assert(alignof(URotorBrick) == 0x000008, "Wrong alignment on URotorBrick");
static_assert(sizeof(URotorBrick) == 0x000100, "Wrong size on URotorBrick");

// Class BrickRigs.SandboxGameState
// 0x0000 (0x05D8 - 0x05D8)
class ASandboxGameState final : public ABrickGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SandboxGameState">();
	}
	static class ASandboxGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASandboxGameState>();
	}
};
static_assert(alignof(ASandboxGameState) == 0x000008, "Wrong alignment on ASandboxGameState");
static_assert(sizeof(ASandboxGameState) == 0x0005D8, "Wrong size on ASandboxGameState");

// Class BrickRigs.ScoreboardPopupWidget
// 0x0000 (0x0298 - 0x0298)
class UScoreboardPopupWidget : public UPopupWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreboardPopupWidget">();
	}
	static class UScoreboardPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoreboardPopupWidget>();
	}
};
static_assert(alignof(UScoreboardPopupWidget) == 0x000008, "Wrong alignment on UScoreboardPopupWidget");
static_assert(sizeof(UScoreboardPopupWidget) == 0x000298, "Wrong size on UScoreboardPopupWidget");

// Class BrickRigs.ScoreboardWidget
// 0x0088 (0x02E8 - 0x0260)
class UScoreboardWidget : public UUserWidget
{
public:
	TArray<class UScoreboardTeamWidget*>          TeamWidgets;                                       // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickGridPanel*                        TeamsPanel;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UScoreboardTeamWidget>      TeamWidgetClass;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UScoreboardPlayerWidget>    PlayerWidgetClass;                                 // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumTeamsPerRow;                                    // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   KickPopupClass;                                    // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanJoinTeams;                                     // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x1F];                                     // 0x02C9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScoreboardWidget">();
	}
	static class UScoreboardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScoreboardWidget>();
	}
};
static_assert(alignof(UScoreboardWidget) == 0x000008, "Wrong alignment on UScoreboardWidget");
static_assert(sizeof(UScoreboardWidget) == 0x0002E8, "Wrong size on UScoreboardWidget");
static_assert(offsetof(UScoreboardWidget, TeamWidgets) == 0x000260, "Member 'UScoreboardWidget::TeamWidgets' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, TeamsPanel) == 0x000280, "Member 'UScoreboardWidget::TeamsPanel' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, TeamWidgetClass) == 0x000288, "Member 'UScoreboardWidget::TeamWidgetClass' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, PlayerWidgetClass) == 0x000290, "Member 'UScoreboardWidget::PlayerWidgetClass' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, NumTeamsPerRow) == 0x000298, "Member 'UScoreboardWidget::NumTeamsPerRow' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, KickPopupClass) == 0x0002A0, "Member 'UScoreboardWidget::KickPopupClass' has a wrong offset!");
static_assert(offsetof(UScoreboardWidget, bCanJoinTeams) == 0x0002C8, "Member 'UScoreboardWidget::bCanJoinTeams' has a wrong offset!");

// Class BrickRigs.SeatBrick
// 0x0158 (0x0250 - 0x00F8)
class USeatBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickCharacter*                        Character;                                         // 0x0108(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInput                          RepVehicleInput;                                   // 0x0130(0x0020)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x68];                                     // 0x0150(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SeatName;                                          // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExitLocation;                                      // 0x01C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x7C];                                     // 0x01D4(0x007C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_EnterSeat(class ABrickPlayerController* PC);
	void OnRep_Character(class ABrickCharacter* OldCharacter);
	void OnRep_VehicleInput();

	int32 GetCurrentGear() const;
	bool GetFlipMotorThrottle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeatBrick">();
	}
	static class USeatBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeatBrick>();
	}
};
static_assert(alignof(USeatBrick) == 0x000008, "Wrong alignment on USeatBrick");
static_assert(sizeof(USeatBrick) == 0x000250, "Wrong size on USeatBrick");
static_assert(offsetof(USeatBrick, Character) == 0x000108, "Member 'USeatBrick::Character' has a wrong offset!");
static_assert(offsetof(USeatBrick, RepVehicleInput) == 0x000130, "Member 'USeatBrick::RepVehicleInput' has a wrong offset!");
static_assert(offsetof(USeatBrick, SeatName) == 0x0001B8, "Member 'USeatBrick::SeatName' has a wrong offset!");
static_assert(offsetof(USeatBrick, ExitLocation) == 0x0001C8, "Member 'USeatBrick::ExitLocation' has a wrong offset!");

// Class BrickRigs.SensorBrickStaticInfo
// 0x0000 (0x01A0 - 0x01A0)
class USensorBrickStaticInfo : public USensorBrickBaseStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SensorBrickStaticInfo">();
	}
	static class USensorBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USensorBrickStaticInfo>();
	}
};
static_assert(alignof(USensorBrickStaticInfo) == 0x000008, "Wrong alignment on USensorBrickStaticInfo");
static_assert(sizeof(USensorBrickStaticInfo) == 0x0001A0, "Wrong size on USensorBrickStaticInfo");

// Class BrickRigs.SensorBrick
// 0x0068 (0x01C0 - 0x0158)
class alignas(0x10) USensorBrick final : public USensorBrickBase
{
public:
	uint8                                         Pad_158[0x38];                                     // 0x0158(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   EnabledInputChannel;                               // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESensorType                                   SensorType;                                        // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EProximitySensorMask                          TraceMask;                                         // 0x01B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnToZero;                                     // 0x01BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BB[0x5];                                      // 0x01BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SensorBrick">();
	}
	static class USensorBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USensorBrick>();
	}
};
static_assert(alignof(USensorBrick) == 0x000010, "Wrong alignment on USensorBrick");
static_assert(sizeof(USensorBrick) == 0x0001C0, "Wrong size on USensorBrick");
static_assert(offsetof(USensorBrick, EnabledInputChannel) == 0x000190, "Member 'USensorBrick::EnabledInputChannel' has a wrong offset!");
static_assert(offsetof(USensorBrick, SensorType) == 0x0001B8, "Member 'USensorBrick::SensorType' has a wrong offset!");
static_assert(offsetof(USensorBrick, TraceMask) == 0x0001B9, "Member 'USensorBrick::TraceMask' has a wrong offset!");
static_assert(offsetof(USensorBrick, bReturnToZero) == 0x0001BA, "Member 'USensorBrick::bReturnToZero' has a wrong offset!");

// Class BrickRigs.ServerWidget
// 0x0198 (0x0420 - 0x0288)
class UServerWidget : public UPagedListEntryWidget
{
public:
	struct FBrickOnlineSessionInfo                Entry;                                             // 0x0288(0x0168)(Transient, NativeAccessSpecifierPrivate)
	class UBrickTextBlock*                        NameTextBlock;                                     // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        MapTextBlock;                                      // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        GameModeTextBlock;                                 // 0x0400(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickTextBlock*                        PlayerCountTextBlock;                              // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingIndicatorWidget*                   PingIndicator;                                     // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPingIndicatorWidget*                   FrameRateIndicator;                                // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateServer(const struct FBrickOnlineSessionInfo& SessionInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerWidget">();
	}
	static class UServerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerWidget>();
	}
};
static_assert(alignof(UServerWidget) == 0x000008, "Wrong alignment on UServerWidget");
static_assert(sizeof(UServerWidget) == 0x000420, "Wrong size on UServerWidget");
static_assert(offsetof(UServerWidget, Entry) == 0x000288, "Member 'UServerWidget::Entry' has a wrong offset!");
static_assert(offsetof(UServerWidget, NameTextBlock) == 0x0003F0, "Member 'UServerWidget::NameTextBlock' has a wrong offset!");
static_assert(offsetof(UServerWidget, MapTextBlock) == 0x0003F8, "Member 'UServerWidget::MapTextBlock' has a wrong offset!");
static_assert(offsetof(UServerWidget, GameModeTextBlock) == 0x000400, "Member 'UServerWidget::GameModeTextBlock' has a wrong offset!");
static_assert(offsetof(UServerWidget, PlayerCountTextBlock) == 0x000408, "Member 'UServerWidget::PlayerCountTextBlock' has a wrong offset!");
static_assert(offsetof(UServerWidget, PingIndicator) == 0x000410, "Member 'UServerWidget::PingIndicator' has a wrong offset!");
static_assert(offsetof(UServerWidget, FrameRateIndicator) == 0x000418, "Member 'UServerWidget::FrameRateIndicator' has a wrong offset!");

// Class BrickRigs.SightStaticInfo
// 0x0070 (0x0400 - 0x0390)
class USightStaticInfo : public UAttachmentStaticInfo
{
public:
	TSoftObjectPtr<class UMaterialInterface>      ReticleMaterial;                                   // 0x0390(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LenseRadius;                                       // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      OcclusionMaterial;                                 // 0x03C0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RailFlangeLength;                                  // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RearOverhang;                                      // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontOverhang;                                     // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0xC];                                      // 0x03F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SightStaticInfo">();
	}
	static class USightStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<USightStaticInfo>();
	}
};
static_assert(alignof(USightStaticInfo) == 0x000010, "Wrong alignment on USightStaticInfo");
static_assert(sizeof(USightStaticInfo) == 0x000400, "Wrong size on USightStaticInfo");
static_assert(offsetof(USightStaticInfo, ReticleMaterial) == 0x000390, "Member 'USightStaticInfo::ReticleMaterial' has a wrong offset!");
static_assert(offsetof(USightStaticInfo, LenseRadius) == 0x0003B8, "Member 'USightStaticInfo::LenseRadius' has a wrong offset!");
static_assert(offsetof(USightStaticInfo, OcclusionMaterial) == 0x0003C0, "Member 'USightStaticInfo::OcclusionMaterial' has a wrong offset!");
static_assert(offsetof(USightStaticInfo, RailFlangeLength) == 0x0003E8, "Member 'USightStaticInfo::RailFlangeLength' has a wrong offset!");
static_assert(offsetof(USightStaticInfo, RearOverhang) == 0x0003EC, "Member 'USightStaticInfo::RearOverhang' has a wrong offset!");
static_assert(offsetof(USightStaticInfo, FrontOverhang) == 0x0003F0, "Member 'USightStaticInfo::FrontOverhang' has a wrong offset!");

// Class BrickRigs.SirenBrick
// 0x0060 (0x0158 - 0x00F8)
class USirenBrick final : public UBrick
{
public:
	uint8                                         Pad_F8[0x28];                                      // 0x00F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USirenType>                 SirenType;                                         // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HornPitch;                                         // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SirenBrick">();
	}
	static class USirenBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USirenBrick>();
	}
};
static_assert(alignof(USirenBrick) == 0x000008, "Wrong alignment on USirenBrick");
static_assert(sizeof(USirenBrick) == 0x000158, "Wrong size on USirenBrick");
static_assert(offsetof(USirenBrick, SirenType) == 0x000120, "Member 'USirenBrick::SirenType' has a wrong offset!");
static_assert(offsetof(USirenBrick, HornPitch) == 0x000128, "Member 'USirenBrick::HornPitch' has a wrong offset!");
static_assert(offsetof(USirenBrick, InputChannel) == 0x000130, "Member 'USirenBrick::InputChannel' has a wrong offset!");

// Class BrickRigs.SirenSequence
// 0x0058 (0x0080 - 0x0028)
class USirenSequence : public UObject
{
public:
	class FText                                   DisplayName;                                       // 0x0028(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayNameAppendix;                               // 0x0040(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayCategory;                                   // 0x0058(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSirenSequenceChannel>          Channels;                                          // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SirenSequence">();
	}
	static class USirenSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<USirenSequence>();
	}
};
static_assert(alignof(USirenSequence) == 0x000008, "Wrong alignment on USirenSequence");
static_assert(sizeof(USirenSequence) == 0x000080, "Wrong size on USirenSequence");
static_assert(offsetof(USirenSequence, DisplayName) == 0x000028, "Member 'USirenSequence::DisplayName' has a wrong offset!");
static_assert(offsetof(USirenSequence, DisplayNameAppendix) == 0x000040, "Member 'USirenSequence::DisplayNameAppendix' has a wrong offset!");
static_assert(offsetof(USirenSequence, DisplayCategory) == 0x000058, "Member 'USirenSequence::DisplayCategory' has a wrong offset!");
static_assert(offsetof(USirenSequence, Channels) == 0x000070, "Member 'USirenSequence::Channels' has a wrong offset!");

// Class BrickRigs.SirenType
// 0x0038 (0x0060 - 0x0028)
class USirenType : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USoundBase*                             HornSound;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SirenSounds;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SirenType">();
	}
	static class USirenType* GetDefaultObj()
	{
		return GetDefaultObjImpl<USirenType>();
	}
};
static_assert(alignof(USirenType) == 0x000008, "Wrong alignment on USirenType");
static_assert(sizeof(USirenType) == 0x000060, "Wrong size on USirenType");
static_assert(offsetof(USirenType, DisplayName) == 0x000030, "Member 'USirenType::DisplayName' has a wrong offset!");
static_assert(offsetof(USirenType, HornSound) == 0x000048, "Member 'USirenType::HornSound' has a wrong offset!");
static_assert(offsetof(USirenType, SirenSounds) == 0x000050, "Member 'USirenType::SirenSounds' has a wrong offset!");

// Class BrickRigs.SoundNodeFirearm
// 0x0020 (0x0068 - 0x0048)
class USoundNodeFirearm final : public USoundNode
{
public:
	class USoundWave*                             FireSound;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         PitchModulation;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         VolumeModulation;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ModulationPeriod;                                  // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoundNodeFirearm">();
	}
	static class USoundNodeFirearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoundNodeFirearm>();
	}
};
static_assert(alignof(USoundNodeFirearm) == 0x000008, "Wrong alignment on USoundNodeFirearm");
static_assert(sizeof(USoundNodeFirearm) == 0x000068, "Wrong size on USoundNodeFirearm");
static_assert(offsetof(USoundNodeFirearm, FireSound) == 0x000048, "Member 'USoundNodeFirearm::FireSound' has a wrong offset!");
static_assert(offsetof(USoundNodeFirearm, PitchModulation) == 0x000050, "Member 'USoundNodeFirearm::PitchModulation' has a wrong offset!");
static_assert(offsetof(USoundNodeFirearm, VolumeModulation) == 0x000058, "Member 'USoundNodeFirearm::VolumeModulation' has a wrong offset!");
static_assert(offsetof(USoundNodeFirearm, ModulationPeriod) == 0x000060, "Member 'USoundNodeFirearm::ModulationPeriod' has a wrong offset!");

// Class BrickRigs.SpawnPointInterface
// 0x0000 (0x0000 - 0x0000)
class ISpawnPointInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnPointInterface">();
	}
	static class ISpawnPointInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnPointInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpawnPointInterface) == 0x000001, "Wrong alignment on ISpawnPointInterface");
static_assert(sizeof(ISpawnPointInterface) == 0x000001, "Wrong size on ISpawnPointInterface");

// Class BrickRigs.SpawnScreenWidget
// 0x0018 (0x0278 - 0x0260)
class USpawnScreenWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapWidget*                             MapWidget;                                         // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpawnPointPanelWidget*                 SpawnPointPanel;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnScreenWidget">();
	}
	static class USpawnScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnScreenWidget>();
	}
};
static_assert(alignof(USpawnScreenWidget) == 0x000008, "Wrong alignment on USpawnScreenWidget");
static_assert(sizeof(USpawnScreenWidget) == 0x000278, "Wrong size on USpawnScreenWidget");
static_assert(offsetof(USpawnScreenWidget, MapWidget) == 0x000268, "Member 'USpawnScreenWidget::MapWidget' has a wrong offset!");
static_assert(offsetof(USpawnScreenWidget, SpawnPointPanel) == 0x000270, "Member 'USpawnScreenWidget::SpawnPointPanel' has a wrong offset!");

// Class BrickRigs.SpectatorWidget
// 0x0008 (0x0268 - 0x0260)
class USpectatorWidget final : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpectateNextCharacter(bool bNext);
	void UpdateSpectatedPlayer(const class FText& PlayerName, bool bIsValidPlayer);

	class UWidget* GetWidgetToFocus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorWidget">();
	}
	static class USpectatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpectatorWidget>();
	}
};
static_assert(alignof(USpectatorWidget) == 0x000008, "Wrong alignment on USpectatorWidget");
static_assert(sizeof(USpectatorWidget) == 0x000268, "Wrong size on USpectatorWidget");

// Class BrickRigs.SpinnerBrick
// 0x0028 (0x0138 - 0x0110)
class USpinnerBrick final : public UScalableBrickBase
{
public:
	class UStaticMesh*                            SpinnerStaticMesh;                                 // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBodySetup*                             SpinnerBodySetup;                                  // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x2];                                      // 0x0120(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESpinnerBrickShape                            SpinnerShape;                                      // 0x0122(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SpinnerSize;                                       // 0x0124(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SpinnerRadius;                                     // 0x012C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpinnerAngle;                                      // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinnerBrick">();
	}
	static class USpinnerBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinnerBrick>();
	}
};
static_assert(alignof(USpinnerBrick) == 0x000008, "Wrong alignment on USpinnerBrick");
static_assert(sizeof(USpinnerBrick) == 0x000138, "Wrong size on USpinnerBrick");
static_assert(offsetof(USpinnerBrick, SpinnerStaticMesh) == 0x000110, "Member 'USpinnerBrick::SpinnerStaticMesh' has a wrong offset!");
static_assert(offsetof(USpinnerBrick, SpinnerBodySetup) == 0x000118, "Member 'USpinnerBrick::SpinnerBodySetup' has a wrong offset!");
static_assert(offsetof(USpinnerBrick, SpinnerShape) == 0x000122, "Member 'USpinnerBrick::SpinnerShape' has a wrong offset!");
static_assert(offsetof(USpinnerBrick, SpinnerSize) == 0x000124, "Member 'USpinnerBrick::SpinnerSize' has a wrong offset!");
static_assert(offsetof(USpinnerBrick, SpinnerRadius) == 0x00012C, "Member 'USpinnerBrick::SpinnerRadius' has a wrong offset!");
static_assert(offsetof(USpinnerBrick, SpinnerAngle) == 0x000134, "Member 'USpinnerBrick::SpinnerAngle' has a wrong offset!");

// Class BrickRigs.SprocketWheelBrick
// 0x0060 (0x0178 - 0x0118)
class USprocketWheelBrick final : public UTrackWheelBrick
{
public:
	uint8                                         Pad_118[0x48];                                     // 0x0118(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrickEditorObjectPtr>          IdlerWheels;                                       // 0x0160(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FColor                                 TrackColor;                                        // 0x0170(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprocketWheelBrick">();
	}
	static class USprocketWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprocketWheelBrick>();
	}
};
static_assert(alignof(USprocketWheelBrick) == 0x000008, "Wrong alignment on USprocketWheelBrick");
static_assert(sizeof(USprocketWheelBrick) == 0x000178, "Wrong size on USprocketWheelBrick");
static_assert(offsetof(USprocketWheelBrick, IdlerWheels) == 0x000160, "Member 'USprocketWheelBrick::IdlerWheels' has a wrong offset!");
static_assert(offsetof(USprocketWheelBrick, TrackColor) == 0x000170, "Member 'USprocketWheelBrick::TrackColor' has a wrong offset!");

// Class BrickRigs.StructPropertyWidget
// 0x0010 (0x0290 - 0x0280)
class UStructPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StructPropertyWidget">();
	}
	static class UStructPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStructPropertyWidget>();
	}
};
static_assert(alignof(UStructPropertyWidget) == 0x000008, "Wrong alignment on UStructPropertyWidget");
static_assert(sizeof(UStructPropertyWidget) == 0x000290, "Wrong size on UStructPropertyWidget");

// Class BrickRigs.SwitchBrick
// 0x0058 (0x01B0 - 0x0158)
class USwitchBrick final : public USensorBrickBase
{
public:
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          InteractionValue;                                  // 0x0160(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161[0xF];                                      // 0x0161(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SwitchName;                                        // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVehicleInputChannel                   InputChannel;                                      // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bReturnToZero;                                     // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact_Deactivate(class ABrickPlayerController* OtherPC);
	void Interact_Switch(class ABrickPlayerController* OtherPC, float Val);
	void OnRep_InteractionValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchBrick">();
	}
	static class USwitchBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchBrick>();
	}
};
static_assert(alignof(USwitchBrick) == 0x000008, "Wrong alignment on USwitchBrick");
static_assert(sizeof(USwitchBrick) == 0x0001B0, "Wrong size on USwitchBrick");
static_assert(offsetof(USwitchBrick, InteractionValue) == 0x000160, "Member 'USwitchBrick::InteractionValue' has a wrong offset!");
static_assert(offsetof(USwitchBrick, SwitchName) == 0x000170, "Member 'USwitchBrick::SwitchName' has a wrong offset!");
static_assert(offsetof(USwitchBrick, InputChannel) == 0x000180, "Member 'USwitchBrick::InputChannel' has a wrong offset!");
static_assert(offsetof(USwitchBrick, bReturnToZero) == 0x0001A8, "Member 'USwitchBrick::bReturnToZero' has a wrong offset!");

// Class BrickRigs.TankBrickStaticInfo
// 0x0010 (0x01B0 - 0x01A0)
class UTankBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	struct FFuelTankParams                        FuelTankParams;                                    // 0x01A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TankBrickStaticInfo">();
	}
	static class UTankBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTankBrickStaticInfo>();
	}
};
static_assert(alignof(UTankBrickStaticInfo) == 0x000008, "Wrong alignment on UTankBrickStaticInfo");
static_assert(sizeof(UTankBrickStaticInfo) == 0x0001B0, "Wrong size on UTankBrickStaticInfo");
static_assert(offsetof(UTankBrickStaticInfo, FuelTankParams) == 0x0001A0, "Member 'UTankBrickStaticInfo::FuelTankParams' has a wrong offset!");

// Class BrickRigs.TargetMarkerBrickStaticInfo
// 0x0040 (0x0780 - 0x0740)
class UTargetMarkerBrickStaticInfo : public UCameraBrickStaticInfo
{
public:
	struct FHUDIconProperties                     ImpactPointIconProperties;                         // 0x0738(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NumTrajectoryIterationsPerGun;                     // 0x0768(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrajectoryDistributionExponent;                    // 0x076C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxGunIterationsPerFrame;                          // 0x0770(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_774[0xC];                                      // 0x0774(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetMarkerBrickStaticInfo">();
	}
	static class UTargetMarkerBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetMarkerBrickStaticInfo>();
	}
};
static_assert(alignof(UTargetMarkerBrickStaticInfo) == 0x000010, "Wrong alignment on UTargetMarkerBrickStaticInfo");
static_assert(sizeof(UTargetMarkerBrickStaticInfo) == 0x000780, "Wrong size on UTargetMarkerBrickStaticInfo");
static_assert(offsetof(UTargetMarkerBrickStaticInfo, ImpactPointIconProperties) == 0x000738, "Member 'UTargetMarkerBrickStaticInfo::ImpactPointIconProperties' has a wrong offset!");
static_assert(offsetof(UTargetMarkerBrickStaticInfo, NumTrajectoryIterationsPerGun) == 0x000768, "Member 'UTargetMarkerBrickStaticInfo::NumTrajectoryIterationsPerGun' has a wrong offset!");
static_assert(offsetof(UTargetMarkerBrickStaticInfo, TrajectoryDistributionExponent) == 0x00076C, "Member 'UTargetMarkerBrickStaticInfo::TrajectoryDistributionExponent' has a wrong offset!");
static_assert(offsetof(UTargetMarkerBrickStaticInfo, MaxGunIterationsPerFrame) == 0x000770, "Member 'UTargetMarkerBrickStaticInfo::MaxGunIterationsPerFrame' has a wrong offset!");

// Class BrickRigs.TargetMarkerBrick
// 0x0018 (0x0190 - 0x0178)
class UTargetMarkerBrick final : public UCameraBrick
{
public:
	uint8                                         Pad_178[0x18];                                     // 0x0178(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetMarkerBrick">();
	}
	static class UTargetMarkerBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetMarkerBrick>();
	}
};
static_assert(alignof(UTargetMarkerBrick) == 0x000008, "Wrong alignment on UTargetMarkerBrick");
static_assert(sizeof(UTargetMarkerBrick) == 0x000190, "Wrong size on UTargetMarkerBrick");

// Class BrickRigs.TeamBase
// 0x0008 (0x0268 - 0x0260)
class ATeamBase : public ASpawnArea
{
public:
	struct FGenericTeamId                         TeamID;                                            // 0x0260(0x0001)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamBase">();
	}
	static class ATeamBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamBase>();
	}
};
static_assert(alignof(ATeamBase) == 0x000008, "Wrong alignment on ATeamBase");
static_assert(sizeof(ATeamBase) == 0x000268, "Wrong size on ATeamBase");
static_assert(offsetof(ATeamBase, TeamID) == 0x000260, "Member 'ATeamBase::TeamID' has a wrong offset!");

// Class BrickRigs.TeamScoreWidget
// 0x0018 (0x0278 - 0x0260)
class UTeamScoreWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateScore(int32 NewScore, int32 NewMaxScore);
	void UpdateTeamAttitude(ETeamAttitude NewTeamAttitude);
	void UpdateTeamIcon(class UTexture2D* NewIcon);
	void UpdateTeamName(const class FText& NewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamScoreWidget">();
	}
	static class UTeamScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamScoreWidget>();
	}
};
static_assert(alignof(UTeamScoreWidget) == 0x000008, "Wrong alignment on UTeamScoreWidget");
static_assert(sizeof(UTeamScoreWidget) == 0x000278, "Wrong size on UTeamScoreWidget");

// Class BrickRigs.TextBrickStaticInfo
// 0x0008 (0x01A8 - 0x01A0)
class UTextBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	class UBrickFont*                             DefaultFont;                                       // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextBrickStaticInfo">();
	}
	static class UTextBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextBrickStaticInfo>();
	}
};
static_assert(alignof(UTextBrickStaticInfo) == 0x000008, "Wrong alignment on UTextBrickStaticInfo");
static_assert(sizeof(UTextBrickStaticInfo) == 0x0001A8, "Wrong size on UTextBrickStaticInfo");
static_assert(offsetof(UTextBrickStaticInfo, DefaultFont) == 0x0001A0, "Member 'UTextBrickStaticInfo::DefaultFont' has a wrong offset!");

// Class BrickRigs.TextBrick
// 0x0038 (0x0158 - 0x0120)
class UTextBrick final : public UScalableBrick
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0130(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBrickFont*                             Font;                                              // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FontSize;                                          // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 TextColor;                                         // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OutlineThickness;                                  // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextBrick">();
	}
	static class UTextBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextBrick>();
	}
};
static_assert(alignof(UTextBrick) == 0x000008, "Wrong alignment on UTextBrick");
static_assert(sizeof(UTextBrick) == 0x000158, "Wrong size on UTextBrick");
static_assert(offsetof(UTextBrick, Text) == 0x000130, "Member 'UTextBrick::Text' has a wrong offset!");
static_assert(offsetof(UTextBrick, Font) == 0x000140, "Member 'UTextBrick::Font' has a wrong offset!");
static_assert(offsetof(UTextBrick, FontSize) == 0x000148, "Member 'UTextBrick::FontSize' has a wrong offset!");
static_assert(offsetof(UTextBrick, TextColor) == 0x00014C, "Member 'UTextBrick::TextColor' has a wrong offset!");
static_assert(offsetof(UTextBrick, OutlineThickness) == 0x000150, "Member 'UTextBrick::OutlineThickness' has a wrong offset!");

// Class BrickRigs.ThrowExplosiveAction
// 0x0008 (0x00A0 - 0x0098)
class UThrowExplosiveAction final : public UItemAction
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowExplosiveAction">();
	}
	static class UThrowExplosiveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowExplosiveAction>();
	}
};
static_assert(alignof(UThrowExplosiveAction) == 0x000008, "Wrong alignment on UThrowExplosiveAction");
static_assert(sizeof(UThrowExplosiveAction) == 0x0000A0, "Wrong size on UThrowExplosiveAction");

// Class BrickRigs.ThrusterBrickStaticInfo
// 0x0068 (0x0208 - 0x01A0)
class UThrusterBrickStaticInfo : public UScalableBrickStaticInfo
{
public:
	struct FFuelTankParams                        FuelTankParams;                                    // 0x01A0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FuelConsumption;                                   // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thrust;                                            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxInputScale;                                     // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInputRate;                                 // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlowInterpSpeed;                                   // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterglowInterpSpeedUp;                            // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterglowInterpSpeedDown;                          // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GlowColor;                                         // 0x01CC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AfterglowColor;                                    // 0x01DC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            NozzleMesh;                                        // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ThrusterParticleSystem;                            // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ThrusterSound;                                     // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrusterBrickStaticInfo">();
	}
	static class UThrusterBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrusterBrickStaticInfo>();
	}
};
static_assert(alignof(UThrusterBrickStaticInfo) == 0x000008, "Wrong alignment on UThrusterBrickStaticInfo");
static_assert(sizeof(UThrusterBrickStaticInfo) == 0x000208, "Wrong size on UThrusterBrickStaticInfo");
static_assert(offsetof(UThrusterBrickStaticInfo, FuelTankParams) == 0x0001A0, "Member 'UThrusterBrickStaticInfo::FuelTankParams' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, FuelConsumption) == 0x0001B0, "Member 'UThrusterBrickStaticInfo::FuelConsumption' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, Thrust) == 0x0001B4, "Member 'UThrusterBrickStaticInfo::Thrust' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, MaxInputScale) == 0x0001B8, "Member 'UThrusterBrickStaticInfo::MaxInputScale' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, ThrottleInputRate) == 0x0001BC, "Member 'UThrusterBrickStaticInfo::ThrottleInputRate' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, GlowInterpSpeed) == 0x0001C0, "Member 'UThrusterBrickStaticInfo::GlowInterpSpeed' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, AfterglowInterpSpeedUp) == 0x0001C4, "Member 'UThrusterBrickStaticInfo::AfterglowInterpSpeedUp' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, AfterglowInterpSpeedDown) == 0x0001C8, "Member 'UThrusterBrickStaticInfo::AfterglowInterpSpeedDown' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, GlowColor) == 0x0001CC, "Member 'UThrusterBrickStaticInfo::GlowColor' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, AfterglowColor) == 0x0001DC, "Member 'UThrusterBrickStaticInfo::AfterglowColor' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, NozzleMesh) == 0x0001F0, "Member 'UThrusterBrickStaticInfo::NozzleMesh' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, ThrusterParticleSystem) == 0x0001F8, "Member 'UThrusterBrickStaticInfo::ThrusterParticleSystem' has a wrong offset!");
static_assert(offsetof(UThrusterBrickStaticInfo, ThrusterSound) == 0x000200, "Member 'UThrusterBrickStaticInfo::ThrusterSound' has a wrong offset!");

// Class BrickRigs.TimespanPropertyWidget
// 0x0000 (0x0280 - 0x0280)
class UTimespanPropertyWidget : public UPropertyWidget
{
public:
	void SetTimespanPropertyValue(EValueChangedEventType EventType, const struct FTimespan& NewValue);
	void UpdateTimespanProperty(const struct FTimespan& Timespan, const struct FTimespan& MinValue, const struct FTimespan& MaxValue, bool bAllowInfinite);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimespanPropertyWidget">();
	}
	static class UTimespanPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimespanPropertyWidget>();
	}
};
static_assert(alignof(UTimespanPropertyWidget) == 0x000008, "Wrong alignment on UTimespanPropertyWidget");
static_assert(sizeof(UTimespanPropertyWidget) == 0x000280, "Wrong size on UTimespanPropertyWidget");

// Class BrickRigs.TooltipWidget
// 0x0040 (0x02B0 - 0x0270)
class UTooltipWidget : public UBrickUserWidget
{
public:
	uint8                                         Pad_270[0x40];                                     // 0x0270(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeIn();
	void UpdateTooltipContent(const struct FTooltipContent& InContent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipWidget">();
	}
	static class UTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipWidget>();
	}
};
static_assert(alignof(UTooltipWidget) == 0x000008, "Wrong alignment on UTooltipWidget");
static_assert(sizeof(UTooltipWidget) == 0x0002B0, "Wrong size on UTooltipWidget");

// Class BrickRigs.Train
// 0x00C0 (0x02E0 - 0x0220)
class ATrain : public AActor
{
public:
	uint8                                         Pad_220[0x28];                                     // 0x0220(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStaticMeshComponent*>           WagonMeshComponents;                               // 0x0250(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AudioComponent;                                    // 0x0260(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        HornAudioComponent;                                // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTrainSegment                          LocoSegment;                                       // 0x0270(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FTrainSegment>                  WagonSegments;                                     // 0x0288(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             TrainSound;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              HornSound;                                         // 0x02A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HornSoundAttenuationRadius;                        // 0x02D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HornSweepInterval;                                 // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HornSweepDist;                                     // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHornDelay;                                      // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetTrainTrack(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Train">();
	}
	static class ATrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrain>();
	}
};
static_assert(alignof(ATrain) == 0x000008, "Wrong alignment on ATrain");
static_assert(sizeof(ATrain) == 0x0002E0, "Wrong size on ATrain");
static_assert(offsetof(ATrain, MeshComponent) == 0x000248, "Member 'ATrain::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATrain, WagonMeshComponents) == 0x000250, "Member 'ATrain::WagonMeshComponents' has a wrong offset!");
static_assert(offsetof(ATrain, AudioComponent) == 0x000260, "Member 'ATrain::AudioComponent' has a wrong offset!");
static_assert(offsetof(ATrain, HornAudioComponent) == 0x000268, "Member 'ATrain::HornAudioComponent' has a wrong offset!");
static_assert(offsetof(ATrain, LocoSegment) == 0x000270, "Member 'ATrain::LocoSegment' has a wrong offset!");
static_assert(offsetof(ATrain, WagonSegments) == 0x000288, "Member 'ATrain::WagonSegments' has a wrong offset!");
static_assert(offsetof(ATrain, Speed) == 0x000298, "Member 'ATrain::Speed' has a wrong offset!");
static_assert(offsetof(ATrain, TrainSound) == 0x0002A0, "Member 'ATrain::TrainSound' has a wrong offset!");
static_assert(offsetof(ATrain, HornSound) == 0x0002A8, "Member 'ATrain::HornSound' has a wrong offset!");
static_assert(offsetof(ATrain, HornSoundAttenuationRadius) == 0x0002D0, "Member 'ATrain::HornSoundAttenuationRadius' has a wrong offset!");
static_assert(offsetof(ATrain, HornSweepInterval) == 0x0002D4, "Member 'ATrain::HornSweepInterval' has a wrong offset!");
static_assert(offsetof(ATrain, HornSweepDist) == 0x0002D8, "Member 'ATrain::HornSweepDist' has a wrong offset!");
static_assert(offsetof(ATrain, MinHornDelay) == 0x0002DC, "Member 'ATrain::MinHornDelay' has a wrong offset!");

// Class BrickRigs.TrainWheelBrick
// 0x0000 (0x0118 - 0x0118)
class UTrainWheelBrick final : public UWheelBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainWheelBrick">();
	}
	static class UTrainWheelBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTrainWheelBrick>();
	}
};
static_assert(alignof(UTrainWheelBrick) == 0x000008, "Wrong alignment on UTrainWheelBrick");
static_assert(sizeof(UTrainWheelBrick) == 0x000118, "Wrong size on UTrainWheelBrick");

// Class BrickRigs.TurbineBrickStaticInfo
// 0x0048 (0x01C8 - 0x0180)
class UTurbineBrickStaticInfo : public UFuelConsumerBrickStaticInfo
{
public:
	float                                         MaxRPM;                                            // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Acceleration;                                      // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVerticalSpeed;                                  // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalAcceleration;                              // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxAngularVelocity;                                // 0x0190(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AngularAcceleration;                               // 0x019C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrottleInputInterpRate;                           // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationInputInterpRate;                           // 0x01AC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USoundCue*                              TurbineSoundCue;                                   // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBankAngle;                                      // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoHoverMaxBankAngleSpeed;                        // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurbineBrickStaticInfo">();
	}
	static class UTurbineBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurbineBrickStaticInfo>();
	}
};
static_assert(alignof(UTurbineBrickStaticInfo) == 0x000008, "Wrong alignment on UTurbineBrickStaticInfo");
static_assert(sizeof(UTurbineBrickStaticInfo) == 0x0001C8, "Wrong size on UTurbineBrickStaticInfo");
static_assert(offsetof(UTurbineBrickStaticInfo, MaxRPM) == 0x000180, "Member 'UTurbineBrickStaticInfo::MaxRPM' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, Acceleration) == 0x000184, "Member 'UTurbineBrickStaticInfo::Acceleration' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, MaxVerticalSpeed) == 0x000188, "Member 'UTurbineBrickStaticInfo::MaxVerticalSpeed' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, VerticalAcceleration) == 0x00018C, "Member 'UTurbineBrickStaticInfo::VerticalAcceleration' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, MaxAngularVelocity) == 0x000190, "Member 'UTurbineBrickStaticInfo::MaxAngularVelocity' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, AngularAcceleration) == 0x00019C, "Member 'UTurbineBrickStaticInfo::AngularAcceleration' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, ThrottleInputInterpRate) == 0x0001A8, "Member 'UTurbineBrickStaticInfo::ThrottleInputInterpRate' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, RotationInputInterpRate) == 0x0001AC, "Member 'UTurbineBrickStaticInfo::RotationInputInterpRate' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, TurbineSoundCue) == 0x0001B8, "Member 'UTurbineBrickStaticInfo::TurbineSoundCue' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, MaxBankAngle) == 0x0001C0, "Member 'UTurbineBrickStaticInfo::MaxBankAngle' has a wrong offset!");
static_assert(offsetof(UTurbineBrickStaticInfo, AutoHoverMaxBankAngleSpeed) == 0x0001C4, "Member 'UTurbineBrickStaticInfo::AutoHoverMaxBankAngleSpeed' has a wrong offset!");

// Class BrickRigs.UGCBrowserPopupParams
// 0x0040 (0x00A8 - 0x0068)
class UUGCBrowserPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x40];                                      // 0x0068(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCBrowserPopupParams">();
	}
	static class UUGCBrowserPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCBrowserPopupParams>();
	}
};
static_assert(alignof(UUGCBrowserPopupParams) == 0x000008, "Wrong alignment on UUGCBrowserPopupParams");
static_assert(sizeof(UUGCBrowserPopupParams) == 0x0000A8, "Wrong size on UUGCBrowserPopupParams");

// Class BrickRigs.UGCFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUGCFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FFluUGCItemIdWrapper MakeOnlineUGCItemId(const class FString& ItemId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCFunctionLibrary">();
	}
	static class UUGCFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCFunctionLibrary>();
	}
};
static_assert(alignof(UUGCFunctionLibrary) == 0x000008, "Wrong alignment on UUGCFunctionLibrary");
static_assert(sizeof(UUGCFunctionLibrary) == 0x000028, "Wrong size on UUGCFunctionLibrary");

// Class BrickRigs.UGCMetaDataPopupParams
// 0x0108 (0x0170 - 0x0068)
class UUGCMetaDataPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUpdateTitle;                                      // 0x0070(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateDescription;                                // 0x0071(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpdateThumbnail;                                  // 0x0072(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUGCFileInfo                           FileInfo;                                          // 0x0078(0x00E8)(Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCMetaDataPopupParams">();
	}
	static class UUGCMetaDataPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCMetaDataPopupParams>();
	}
};
static_assert(alignof(UUGCMetaDataPopupParams) == 0x000008, "Wrong alignment on UUGCMetaDataPopupParams");
static_assert(sizeof(UUGCMetaDataPopupParams) == 0x000170, "Wrong size on UUGCMetaDataPopupParams");
static_assert(offsetof(UUGCMetaDataPopupParams, bUpdateTitle) == 0x000070, "Member 'UUGCMetaDataPopupParams::bUpdateTitle' has a wrong offset!");
static_assert(offsetof(UUGCMetaDataPopupParams, bUpdateDescription) == 0x000071, "Member 'UUGCMetaDataPopupParams::bUpdateDescription' has a wrong offset!");
static_assert(offsetof(UUGCMetaDataPopupParams, bUpdateThumbnail) == 0x000072, "Member 'UUGCMetaDataPopupParams::bUpdateThumbnail' has a wrong offset!");
static_assert(offsetof(UUGCMetaDataPopupParams, FileInfo) == 0x000078, "Member 'UUGCMetaDataPopupParams::FileInfo' has a wrong offset!");

// Class BrickRigs.UGCPropertyWidget
// 0x0030 (0x02B0 - 0x0280)
class UUGCPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   UGCBrowserPopupClass;                              // 0x0288(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickedButton();
	void UpdateItemsText(int32 NumSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCPropertyWidget">();
	}
	static class UUGCPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCPropertyWidget>();
	}
};
static_assert(alignof(UUGCPropertyWidget) == 0x000008, "Wrong alignment on UUGCPropertyWidget");
static_assert(sizeof(UUGCPropertyWidget) == 0x0002B0, "Wrong size on UUGCPropertyWidget");
static_assert(offsetof(UUGCPropertyWidget, UGCBrowserPopupClass) == 0x000288, "Member 'UUGCPropertyWidget::UGCBrowserPopupClass' has a wrong offset!");

// Class BrickRigs.UGCTaskPopupParams
// 0x0008 (0x0070 - 0x0068)
class UUGCTaskPopupParams final : public UPopupParams
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCTaskPopupParams">();
	}
	static class UUGCTaskPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCTaskPopupParams>();
	}
};
static_assert(alignof(UUGCTaskPopupParams) == 0x000008, "Wrong alignment on UUGCTaskPopupParams");
static_assert(sizeof(UUGCTaskPopupParams) == 0x000070, "Wrong size on UUGCTaskPopupParams");

// Class BrickRigs.UGCTaskPopupWidget
// 0x0030 (0x02C8 - 0x0298)
class UUGCTaskPopupWidget : public UPopupWidget
{
public:
	uint8                                         Pad_298[0x28];                                     // 0x0298(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressInterpSpeed;                               // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateIsFinished(bool bNewFinished, bool bNewSuccess);
	void UpdateProgress(float NewProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UGCTaskPopupWidget">();
	}
	static class UUGCTaskPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUGCTaskPopupWidget>();
	}
};
static_assert(alignof(UUGCTaskPopupWidget) == 0x000008, "Wrong alignment on UUGCTaskPopupWidget");
static_assert(sizeof(UUGCTaskPopupWidget) == 0x0002C8, "Wrong size on UUGCTaskPopupWidget");
static_assert(offsetof(UUGCTaskPopupWidget, ProgressInterpSpeed) == 0x0002C0, "Member 'UUGCTaskPopupWidget::ProgressInterpSpeed' has a wrong offset!");

// Class BrickRigs.UIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UUIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FText BoolAsText(bool bValue);
	static class FText BrickSizeToText(const struct FVector& Size, const bool bZeroAsUndetermined);
	static class FText BrickUnitsToText(const float UnrealUnits, const bool bZeroAsUndetermined);
	static float ConvertToRealUnits(float Value, ENumericValueType ValueType);
	static float ConvertToUnrealUnits(float Value, ENumericValueType ValueType);
	static bool FilterTextForProfanity(const class FText& InText, class FText* OutText);
	static bool FilterTextForURLs(const class FText& InText, class FText* OutText);
	static class UWidget* FindFirstWidgetInWidgetPath(const TArray<class UWidget*>& Widgets, const struct FWidgetPathWrapper& WidgetPath);
	static class FText GetAmmoTypeDisplayText(EAmmoType InAmmoType, bool bLongName);
	static class FText GetCameraModeDisplayText(ECameraMode InCameraMode);
	static class FText GetFireModeDisplayText(EFireMode InFireMode);
	static class FText GetHUDVisibilityDisplayText(EHUDVisibility InHUDVisibility);
	static class FText GetMultidimensionalNumberDelimiter(const ENumericValueType ValueType);
	static class FText GetUnitFormat(ENumericValueType ValueType);
	static bool IsWidgetInWidgetPath(const class UWidget* Widget, const struct FWidgetPathWrapper& WidgetPath);
	static class FText NumberToText(float Value, ENumericValueType ValueType, int32 MaxFractionalDigits, bool bIncludeUnits, bool bAlwaysSign);
	static void OpenURLInExternalBrowser(const class FString& URL);
	static class FText TimespanAsText(const struct FTimespan& Timespan);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIFunctionLibrary">();
	}
	static class UUIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIFunctionLibrary>();
	}
};
static_assert(alignof(UUIFunctionLibrary) == 0x000008, "Wrong alignment on UUIFunctionLibrary");
static_assert(sizeof(UUIFunctionLibrary) == 0x000028, "Wrong size on UUIFunctionLibrary");

// Class BrickRigs.UnsavedChangesPopupParams
// 0x0000 (0x0068 - 0x0068)
class UUnsavedChangesPopupParams final : public UPopupParams
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnsavedChangesPopupParams">();
	}
	static class UUnsavedChangesPopupParams* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnsavedChangesPopupParams>();
	}
};
static_assert(alignof(UUnsavedChangesPopupParams) == 0x000008, "Wrong alignment on UUnsavedChangesPopupParams");
static_assert(sizeof(UUnsavedChangesPopupParams) == 0x000068, "Wrong size on UUnsavedChangesPopupParams");

// Class BrickRigs.UserIdPropertyWidget
// 0x0070 (0x02F0 - 0x0280)
class UUserIdPropertyWidget : public UPropertyWidget
{
public:
	uint8                                         Pad_280[0x68];                                     // 0x0280(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTextBoxWidget*                    UserIdTextBox;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUserIdTextChanged(const class FText& Text, EValueChangedEventType EventType);
	void UpdateUserId(const class FText& InUserId, const bool bIsValid);
	void UpdateUsername(const class FText& InUsername);
	void ViewProfileInBrowser();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserIdPropertyWidget">();
	}
	static class UUserIdPropertyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserIdPropertyWidget>();
	}
};
static_assert(alignof(UUserIdPropertyWidget) == 0x000008, "Wrong alignment on UUserIdPropertyWidget");
static_assert(sizeof(UUserIdPropertyWidget) == 0x0002F0, "Wrong size on UUserIdPropertyWidget");
static_assert(offsetof(UUserIdPropertyWidget, UserIdTextBox) == 0x0002E8, "Member 'UUserIdPropertyWidget::UserIdTextBox' has a wrong offset!");

// Class BrickRigs.VehicleIconWidget
// 0x0010 (0x02A8 - 0x0298)
class UVehicleIconWidget : public UPawnIconWidget
{
public:
	class ABrickVehicle*                          Vehicle;                                           // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateVehicleIcon(bool bNewIsLocalPlayer, bool bNewCanBeDamaged, EVehiclePinMode NewPinMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleIconWidget">();
	}
	static class UVehicleIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleIconWidget>();
	}
};
static_assert(alignof(UVehicleIconWidget) == 0x000008, "Wrong alignment on UVehicleIconWidget");
static_assert(sizeof(UVehicleIconWidget) == 0x0002A8, "Wrong size on UVehicleIconWidget");
static_assert(offsetof(UVehicleIconWidget, Vehicle) == 0x000298, "Member 'UVehicleIconWidget::Vehicle' has a wrong offset!");

// Class BrickRigs.VideoSettingsPageWidget
// 0x0030 (0x02C8 - 0x0298)
class UVideoSettingsPageWidget : public UMenuSettingsPageWidget
{
public:
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ConfirmResolutionPopupClass;                       // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyVideoSettings();
	void RevertVideoSettings();
	void UpdateApplyButton(bool bCanApply);

	bool AreVideoSettingsDirty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VideoSettingsPageWidget">();
	}
	static class UVideoSettingsPageWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVideoSettingsPageWidget>();
	}
};
static_assert(alignof(UVideoSettingsPageWidget) == 0x000008, "Wrong alignment on UVideoSettingsPageWidget");
static_assert(sizeof(UVideoSettingsPageWidget) == 0x0002C8, "Wrong size on UVideoSettingsPageWidget");
static_assert(offsetof(UVideoSettingsPageWidget, ConfirmResolutionPopupClass) == 0x0002A0, "Member 'UVideoSettingsPageWidget::ConfirmResolutionPopupClass' has a wrong offset!");

// Class BrickRigs.Wearable
// 0x0038 (0x02A8 - 0x0270)
class AWearable : public AInventoryItem
{
public:
	class FText                                   ColorDisplayName;                                  // 0x0270(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           Color;                                             // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Texture;                                           // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TextureTiling;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Wearable">();
	}
	static class AWearable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWearable>();
	}
};
static_assert(alignof(AWearable) == 0x000008, "Wrong alignment on AWearable");
static_assert(sizeof(AWearable) == 0x0002A8, "Wrong size on AWearable");
static_assert(offsetof(AWearable, ColorDisplayName) == 0x000270, "Member 'AWearable::ColorDisplayName' has a wrong offset!");
static_assert(offsetof(AWearable, Color) == 0x000288, "Member 'AWearable::Color' has a wrong offset!");
static_assert(offsetof(AWearable, Texture) == 0x000298, "Member 'AWearable::Texture' has a wrong offset!");
static_assert(offsetof(AWearable, TextureTiling) == 0x0002A0, "Member 'AWearable::TextureTiling' has a wrong offset!");

// Class BrickRigs.WeatherCondition
// 0x0090 (0x00C0 - 0x0030)
class UWeatherCondition final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDisplayInfo                           DisplayInfo;                                       // 0x0038(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FWeatherConditionParams                Weather;                                           // 0x0060(0x0060)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeatherCondition">();
	}
	static class UWeatherCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeatherCondition>();
	}
};
static_assert(alignof(UWeatherCondition) == 0x000008, "Wrong alignment on UWeatherCondition");
static_assert(sizeof(UWeatherCondition) == 0x0000C0, "Wrong size on UWeatherCondition");
static_assert(offsetof(UWeatherCondition, DisplayInfo) == 0x000038, "Member 'UWeatherCondition::DisplayInfo' has a wrong offset!");
static_assert(offsetof(UWeatherCondition, Weather) == 0x000060, "Member 'UWeatherCondition::Weather' has a wrong offset!");

// Class BrickRigs.WinchBrickStaticInfo
// 0x0058 (0x01C0 - 0x0168)
class UWinchBrickStaticInfo : public UBrickStaticInfo
{
public:
	class UStaticMesh*                            HookMesh;                                          // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RopeMesh;                                          // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRopeLength;                                     // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRopeLength;                                     // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WinchSpeed;                                        // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             HookSocketTransform;                               // 0x0190(0x0030)(Edit, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinchBrickStaticInfo">();
	}
	static class UWinchBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWinchBrickStaticInfo>();
	}
};
static_assert(alignof(UWinchBrickStaticInfo) == 0x000010, "Wrong alignment on UWinchBrickStaticInfo");
static_assert(sizeof(UWinchBrickStaticInfo) == 0x0001C0, "Wrong size on UWinchBrickStaticInfo");
static_assert(offsetof(UWinchBrickStaticInfo, HookMesh) == 0x000168, "Member 'UWinchBrickStaticInfo::HookMesh' has a wrong offset!");
static_assert(offsetof(UWinchBrickStaticInfo, RopeMesh) == 0x000170, "Member 'UWinchBrickStaticInfo::RopeMesh' has a wrong offset!");
static_assert(offsetof(UWinchBrickStaticInfo, MinRopeLength) == 0x000178, "Member 'UWinchBrickStaticInfo::MinRopeLength' has a wrong offset!");
static_assert(offsetof(UWinchBrickStaticInfo, MaxRopeLength) == 0x00017C, "Member 'UWinchBrickStaticInfo::MaxRopeLength' has a wrong offset!");
static_assert(offsetof(UWinchBrickStaticInfo, WinchSpeed) == 0x000180, "Member 'UWinchBrickStaticInfo::WinchSpeed' has a wrong offset!");
static_assert(offsetof(UWinchBrickStaticInfo, HookSocketTransform) == 0x000190, "Member 'UWinchBrickStaticInfo::HookSocketTransform' has a wrong offset!");

// Class BrickRigs.WinchBrickInterface
// 0x0000 (0x0000 - 0x0000)
class IWinchBrickInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WinchBrickInterface">();
	}
	static class IWinchBrickInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWinchBrickInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWinchBrickInterface) == 0x000001, "Wrong alignment on IWinchBrickInterface");
static_assert(sizeof(IWinchBrickInterface) == 0x000001, "Wrong size on IWinchBrickInterface");

// Class BrickRigs.Windmill
// 0x0028 (0x0268 - 0x0240)
class AWindmill : public AStaticMeshProp
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         WindmillRandSeed;                                  // 0x0248(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   RotorMeshComponent;                                // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            RotorMesh;                                         // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         RotationSpeedRange;                                // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Windmill">();
	}
	static class AWindmill* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindmill>();
	}
};
static_assert(alignof(AWindmill) == 0x000008, "Wrong alignment on AWindmill");
static_assert(sizeof(AWindmill) == 0x000268, "Wrong size on AWindmill");
static_assert(offsetof(AWindmill, WindmillRandSeed) == 0x000248, "Member 'AWindmill::WindmillRandSeed' has a wrong offset!");
static_assert(offsetof(AWindmill, RotorMeshComponent) == 0x000250, "Member 'AWindmill::RotorMeshComponent' has a wrong offset!");
static_assert(offsetof(AWindmill, RotorMesh) == 0x000258, "Member 'AWindmill::RotorMesh' has a wrong offset!");
static_assert(offsetof(AWindmill, RotationSpeedRange) == 0x000260, "Member 'AWindmill::RotationSpeedRange' has a wrong offset!");

// Class BrickRigs.WindowBrick
// 0x0000 (0x00F8 - 0x00F8)
class UWindowBrick final : public UBrick
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowBrick">();
	}
	static class UWindowBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWindowBrick>();
	}
};
static_assert(alignof(UWindowBrick) == 0x000008, "Wrong alignment on UWindowBrick");
static_assert(sizeof(UWindowBrick) == 0x0000F8, "Wrong size on UWindowBrick");

// Class BrickRigs.WingBrickStaticInfo
// 0x0000 (0x0168 - 0x0168)
class UWingBrickStaticInfo : public UBrickStaticInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WingBrickStaticInfo">();
	}
	static class UWingBrickStaticInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWingBrickStaticInfo>();
	}
};
static_assert(alignof(UWingBrickStaticInfo) == 0x000008, "Wrong alignment on UWingBrickStaticInfo");
static_assert(sizeof(UWingBrickStaticInfo) == 0x000168, "Wrong size on UWingBrickStaticInfo");

// Class BrickRigs.WorldBounds
// 0x0048 (0x0268 - 0x0220)
class AWorldBounds : public AActor
{
public:
	class UInstancedStaticMeshComponent*          BoundsMeshComponent;                               // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   WaterMeshComponent;                                // 0x0228(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            StaticMesh;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            WaterMesh;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WaterMaterialOverride;                             // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoundsSize;                                        // 0x0250(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LandscapeSize;                                     // 0x025C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterDepth;                                        // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBounds">();
	}
	static class AWorldBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldBounds>();
	}
};
static_assert(alignof(AWorldBounds) == 0x000008, "Wrong alignment on AWorldBounds");
static_assert(sizeof(AWorldBounds) == 0x000268, "Wrong size on AWorldBounds");
static_assert(offsetof(AWorldBounds, BoundsMeshComponent) == 0x000220, "Member 'AWorldBounds::BoundsMeshComponent' has a wrong offset!");
static_assert(offsetof(AWorldBounds, WaterMeshComponent) == 0x000228, "Member 'AWorldBounds::WaterMeshComponent' has a wrong offset!");
static_assert(offsetof(AWorldBounds, StaticMesh) == 0x000230, "Member 'AWorldBounds::StaticMesh' has a wrong offset!");
static_assert(offsetof(AWorldBounds, WaterMesh) == 0x000238, "Member 'AWorldBounds::WaterMesh' has a wrong offset!");
static_assert(offsetof(AWorldBounds, MaterialOverride) == 0x000240, "Member 'AWorldBounds::MaterialOverride' has a wrong offset!");
static_assert(offsetof(AWorldBounds, WaterMaterialOverride) == 0x000248, "Member 'AWorldBounds::WaterMaterialOverride' has a wrong offset!");
static_assert(offsetof(AWorldBounds, BoundsSize) == 0x000250, "Member 'AWorldBounds::BoundsSize' has a wrong offset!");
static_assert(offsetof(AWorldBounds, LandscapeSize) == 0x00025C, "Member 'AWorldBounds::LandscapeSize' has a wrong offset!");
static_assert(offsetof(AWorldBounds, WaterDepth) == 0x000264, "Member 'AWorldBounds::WaterDepth' has a wrong offset!");

// Class BrickRigs.Zombie
// 0x0000 (0x07C0 - 0x07C0)
class AZombie : public ABaseCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Zombie">();
	}
	static class AZombie* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombie>();
	}
};
static_assert(alignof(AZombie) == 0x000010, "Wrong alignment on AZombie");
static_assert(sizeof(AZombie) == 0x0007C0, "Wrong size on AZombie");

// Class BrickRigs.ZombieGameMode
// 0x0040 (0x0438 - 0x03F8)
class AZombieGameMode : public ABrickGameMode
{
public:
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AZombie*>                        Zombies;                                           // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         NumStartZombies;                                   // 0x0418(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AddZombiesPerWave;                                 // 0x041C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatInterval                         ZombieLifeSpanRange;                               // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APawn>                      ZombieClass;                                       // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APawn>                      BossZombieClass;                                   // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieGameMode">();
	}
	static class AZombieGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieGameMode>();
	}
};
static_assert(alignof(AZombieGameMode) == 0x000008, "Wrong alignment on AZombieGameMode");
static_assert(sizeof(AZombieGameMode) == 0x000438, "Wrong size on AZombieGameMode");
static_assert(offsetof(AZombieGameMode, Zombies) == 0x000408, "Member 'AZombieGameMode::Zombies' has a wrong offset!");
static_assert(offsetof(AZombieGameMode, NumStartZombies) == 0x000418, "Member 'AZombieGameMode::NumStartZombies' has a wrong offset!");
static_assert(offsetof(AZombieGameMode, AddZombiesPerWave) == 0x00041C, "Member 'AZombieGameMode::AddZombiesPerWave' has a wrong offset!");
static_assert(offsetof(AZombieGameMode, ZombieLifeSpanRange) == 0x000420, "Member 'AZombieGameMode::ZombieLifeSpanRange' has a wrong offset!");
static_assert(offsetof(AZombieGameMode, ZombieClass) == 0x000428, "Member 'AZombieGameMode::ZombieClass' has a wrong offset!");
static_assert(offsetof(AZombieGameMode, BossZombieClass) == 0x000430, "Member 'AZombieGameMode::BossZombieClass' has a wrong offset!");

// Class BrickRigs.ZombieGameState
// 0x0000 (0x05D8 - 0x05D8)
class AZombieGameState final : public ABrickGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieGameState">();
	}
	static class AZombieGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieGameState>();
	}
};
static_assert(alignof(AZombieGameState) == 0x000008, "Wrong alignment on AZombieGameState");
static_assert(sizeof(AZombieGameState) == 0x0005D8, "Wrong size on AZombieGameState");

}

