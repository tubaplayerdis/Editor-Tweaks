#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BrickRigs

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#include "AIModule_structs.hpp"
#include "FluUGC_structs.hpp"


namespace SDK
{

// Enum BrickRigs.EBrickUITextStyle
// NumValues: 0x000B
enum class EBrickUITextStyle : uint8
{
	Default                                  = 0,
	Bold                                     = 1,
	Small                                    = 2,
	Large                                    = 3,
	Positive                                 = 4,
	Negative                                 = 5,
	Neutral                                  = 6,
	HUD                                      = 7,
	HighContrast                             = 8,
	Custom                                   = 9,
	Max                                      = 10,
};

// Enum BrickRigs.EBrickUIStyleState
// NumValues: 0x0010
enum class EBrickUIStyleState : uint8
{
	Default                                  = 0,
	Border                                   = 1,
	Button                                   = 2,
	Pressed                                  = 3,
	Focused                                  = 4,
	Selected                                 = 5,
	FocusedSelected                          = 6,
	Marquee                                  = 7,
	Foreground                               = 8,
	ForegroundPressed                        = 9,
	ForegroundFocused                        = 10,
	ForegroundSelected                       = 11,
	ForegroundFocusedSelected                = 12,
	Background                               = 13,
	Custom                                   = 14,
	Max                                      = 15,
};

// Enum BrickRigs.EBrickUIBrushStyle
// NumValues: 0x000A
enum class EBrickUIBrushStyle : uint8
{
	Default                                  = 0,
	Button                                   = 1,
	FolderButton                             = 2,
	MapButton                                = 3,
	BorderlessButton                         = 4,
	KeyBorder                                = 5,
	Slider                                   = 6,
	Spacer                                   = 7,
	Custom                                   = 8,
	Max                                      = 9,
};

// Enum BrickRigs.EBrickUIColorStyle
// NumValues: 0x000A
enum class EBrickUIColorStyle : uint8
{
	Default                                  = 0,
	Highlight                                = 1,
	Positive                                 = 2,
	Negative                                 = 3,
	Neutral                                  = 4,
	EditorOutline                            = 5,
	GameLogo                                 = 6,
	DeveloperLogo                            = 7,
	Custom                                   = 8,
	Max                                      = 9,
};

// Enum BrickRigs.EBrickUIPaddingStyle
// NumValues: 0x0009
enum class EBrickUIPaddingStyle : uint8
{
	Border                                   = 0,
	Button                                   = 1,
	FolderButton                             = 2,
	MapButton                                = 3,
	BorderlessButton                         = 4,
	KeyBorder                                = 5,
	Slider                                   = 6,
	Custom                                   = 7,
	Max                                      = 8,
};

// Enum BrickRigs.EBrickUISpacingStyle
// NumValues: 0x0005
enum class EBrickUISpacingStyle : uint8
{
	Small                                    = 0,
	Medium                                   = 1,
	Large                                    = 2,
	Custom                                   = 3,
	Max                                      = 4,
};

// Enum BrickRigs.EBrickUIIconAtlas
// NumValues: 0x0013
enum class EBrickUIIconAtlas : uint8
{
	Default                                  = 0,
	MenuButtons                              = 1,
	MouseKeys                                = 2,
	GamepadKeys                              = 3,
	HUDIcons                                 = 4,
	FireModes                                = 5,
	AmmoTypes                                = 6,
	HealthIcons                              = 7,
	ScoreboardIcons                          = 8,
	ConnectionIcons                          = 9,
	ServerIcons                              = 10,
	HUDNotifications                         = 11,
	DashboardIcons                           = 12,
	SocialMediaIcons                         = 13,
	WeatherIcons                             = 14,
	ConnectorSpacingIcons                    = 15,
	SpinnerBrickShapeIcons                   = 16,
	Custom                                   = 17,
	Max                                      = 18,
};

// Enum BrickRigs.EPopupResult
// NumValues: 0x0005
enum class EPopupResult : uint8
{
	Confirm                                  = 0,
	Cancel                                   = 1,
	Ignore                                   = 2,
	ForceClose                               = 3,
	EPopupResult_MAX                         = 4,
};

// Enum BrickRigs.EInputActionListMode
// NumValues: 0x0005
enum class EInputActionListMode : uint8
{
	InputHelpClosed                          = 0,
	InputHelpOpen                            = 1,
	ContextMenu                              = 2,
	EditorTopBar                             = 3,
	EInputActionListMode_MAX                 = 4,
};

// Enum BrickRigs.EInputActionTriggerType
// NumValues: 0x0007
enum class EInputActionTriggerType : uint8
{
	Press                                    = 0,
	Tab                                      = 1,
	Hold                                     = 2,
	Axis                                     = 3,
	AxisPositive                             = 4,
	AxisNegative                             = 5,
	EInputActionTriggerType_MAX              = 6,
};

// Enum BrickRigs.EInteractionOptionSlot
// NumValues: 0x0005
enum class EInteractionOptionSlot : uint8
{
	Pri                                      = 0,
	Sec                                      = 1,
	Ter                                      = 2,
	Inventory                                = 3,
	EInteractionOptionSlot_MAX               = 4,
};

// Enum BrickRigs.EHUDIconDomain
// NumValues: 0x0005
enum class EHUDIconDomain : uint8
{
	Map                                      = 0,
	Spawn                                    = 1,
	SpawnPoints                              = 2,
	HUD                                      = 3,
	EHUDIconDomain_MAX                       = 4,
};

// Enum BrickRigs.EHUDVisibility
// NumValues: 0x0004
enum class EHUDVisibility : uint8
{
	Full                                     = 0,
	Minimal                                  = 1,
	Off                                      = 2,
	Max                                      = 3,
};

// Enum BrickRigs.EInputMethod
// NumValues: 0x0003
enum class EInputMethod : uint8
{
	Keyboard                                 = 0,
	Gamepad                                  = 1,
	EInputMethod_MAX                         = 2,
};

// Enum BrickRigs.EBrickUnitsDisplayMode
// NumValues: 0x0003
enum class EBrickUnitsDisplayMode : uint8
{
	BrickUnits                               = 0,
	DistanceUnits                            = 1,
	EBrickUnitsDisplayMode_MAX               = 2,
};

// Enum BrickRigs.EColorDisplayMode
// NumValues: 0x0003
enum class EColorDisplayMode : uint8
{
	HSV                                      = 0,
	RGB                                      = 1,
	EColorDisplayMode_MAX                    = 2,
};

// Enum BrickRigs.EMeasurementSystem
// NumValues: 0x0003
enum class EMeasurementSystem : uint8
{
	Metric                                   = 0,
	Imperial                                 = 1,
	Max                                      = 2,
};

// Enum BrickRigs.EBrickEditorViewMode
// NumValues: 0x0005
enum class EBrickEditorViewMode : uint8
{
	Default                                  = 0,
	Wireframe                                = 1,
	Physics                                  = 2,
	InputChannels                            = 3,
	EBrickEditorViewMode_MAX                 = 4,
};

// Enum BrickRigs.ETransmissionMode
// NumValues: 0x0003
enum class ETransmissionMode : uint8
{
	Manual                                   = 0,
	Automatic                                = 1,
	ETransmissionMode_MAX                    = 2,
};

// Enum BrickRigs.ECameraMode
// NumValues: 0x0005
enum class ECameraMode : uint8
{
	Local                                    = 0,
	Global                                   = 1,
	Orbital                                  = 2,
	Velocity                                 = 3,
	ECameraMode_MAX                          = 4,
};

// Enum BrickRigs.EChatContext
// NumValues: 0x0005
enum class EChatContext : uint8
{
	None                                     = 0,
	Global                                   = 1,
	Team                                     = 2,
	Admin                                    = 3,
	Max                                      = 4,
};

// Enum BrickRigs.EUGCDepartmentTag
// NumValues: 0x0006
enum class EUGCDepartmentTag : uint8
{
	None                                     = 0,
	Civil                                    = 1,
	Military                                 = 2,
	Police                                   = 3,
	FireDepartment                           = 4,
	Max                                      = 5,
};

// Enum BrickRigs.EUGCEraTag
// NumValues: 0x0009
enum class EUGCEraTag : uint8
{
	None                                     = 0,
	_1800s                                   = 1,
	_1900s                                   = 2,
	_2000s                                   = 3,
	Futuristic                               = 4,
	Ancient                                  = 5,
	WW2                                      = 6,
	WW1                                      = 7,
	Max                                      = 8,
};

// Enum BrickRigs.EUGCTypeTag
// NumValues: 0x0011
enum class EUGCTypeTag : uint8
{
	None                                     = 0,
	Car                                      = 1,
	RaceCar                                  = 2,
	Truck                                    = 3,
	HeavyMachinery                           = 4,
	Plane                                    = 5,
	Helicopter                               = 6,
	Tank                                     = 7,
	Train                                    = 8,
	Trailer                                  = 9,
	Prop                                     = 10,
	Building                                 = 11,
	Ship                                     = 12,
	SpaceCraft                               = 13,
	Bus                                      = 14,
	Motorcycle                               = 15,
	Max                                      = 16,
};

// Enum BrickRigs.EUGCContentVersion
// NumValues: 0x0004
enum class EUGCContentVersion : uint8
{
	Default                                  = 0,
	AutoSave                                 = 1,
	Backup                                   = 2,
	Max                                      = 3,
};

// Enum BrickRigs.EUGCType
// NumValues: 0x0005
enum class EUGCType : uint8
{
	None                                     = 0,
	Vehicle                                  = 1,
	Scenario                                 = 2,
	Mod                                      = 3,
	Max                                      = 4,
};

// Enum BrickRigs.EUGCFileType
// NumValues: 0x0008
enum class EUGCFileType : uint8
{
	None                                     = 0,
	Saved                                    = 1,
	SavedDevelopment                         = 2,
	SavedLegacy                              = 3,
	Content                                  = 4,
	Online                                   = 5,
	Inline                                   = 6,
	Max                                      = 7,
};

// Enum BrickRigs.EMatchVehicleFilter
// NumValues: 0x0004
enum class EMatchVehicleFilter : uint8
{
	None                                     = 0,
	PublicOnline                             = 1,
	Whitelist                                = 2,
	EMatchVehicleFilter_MAX                  = 3,
};

// Enum BrickRigs.EHostServerType
// NumValues: 0x0004
enum class EHostServerType : uint8
{
	None                                     = 0,
	Private                                  = 1,
	Public                                   = 2,
	EHostServerType_MAX                      = 3,
};

// Enum BrickRigs.EValueChangedEventType
// NumValues: 0x0004
enum class EValueChangedEventType : uint8
{
	Commit                                   = 0,
	Cancel                                   = 1,
	Pending                                  = 2,
	EValueChangedEventType_MAX               = 3,
};

// Enum BrickRigs.EBrickSliderGridSnapMode
// NumValues: 0x0005
enum class EBrickSliderGridSnapMode : uint8
{
	None                                     = 0,
	MinRelative                              = 1,
	MaxRelative                              = 2,
	Absolute                                 = 3,
	EBrickSliderGridSnapMode_MAX             = 4,
};

// Enum BrickRigs.ENumericValueType
// NumValues: 0x0023
enum class ENumericValueType : uint8
{
	Float                                    = 0,
	Integer                                  = 1,
	Percent                                  = 2,
	Angle                                    = 3,
	RPM                                      = 4,
	Time                                     = 5,
	Seconds                                  = 6,
	Minutes                                  = 7,
	Hours                                    = 8,
	Days                                     = 9,
	Money                                    = 10,
	Gear                                     = 11,
	SpeedAuto                                = 12,
	SpeedMetric                              = 13,
	SpeedImperial                            = 14,
	DistanceAuto                             = 15,
	DistanceMetric                           = 16,
	DistanceImperial                         = 17,
	DistanceAutoOrBrickUnits                 = 18,
	DistanceBrickUnits                       = 19,
	DistanceZeroAsUnlimited                  = 20,
	VolumeAuto                               = 21,
	VolumeMetric                             = 22,
	VolumeImperial                           = 23,
	IntZeroAsUnlimited                       = 24,
	Bricks                                   = 25,
	BricksZeroAsUnlimited                    = 26,
	MassAuto                                 = 27,
	MassMetric                               = 28,
	MassImperial                             = 29,
	MassZeroAsUnlimited                      = 30,
	ForceAuto                                = 31,
	ForceMetric                              = 32,
	ForceImperial                            = 33,
	ENumericValueType_MAX                    = 34,
};

// Enum BrickRigs.EActuatorMode
// NumValues: 0x0007
enum class EActuatorMode : uint8
{
	Accumulated                              = 0,
	Seeking                                  = 1,
	Cycle                                    = 2,
	PhysicsDriven                            = 3,
	Static                                   = 4,
	Spring                                   = 5,
	EActuatorMode_MAX                        = 6,
};

// Enum BrickRigs.EAmmoType
// NumValues: 0x0007
enum class EAmmoType : uint8
{
	Default                                  = 0,
	Incendiary                               = 1,
	HighExplosive                            = 2,
	TargetSeeking                            = 3,
	Guided                                   = 4,
	Flare                                    = 5,
	Max                                      = 6,
};

// Enum BrickRigs.EAttachmentTag
// NumValues: 0x0004
enum class EAttachmentTag : uint8
{
	Sight                                    = 0,
	Barrel                                   = 1,
	Paint                                    = 2,
	EAttachmentTag_MAX                       = 3,
};

// Enum BrickRigs.EChatMessageType
// NumValues: 0x000D
enum class EChatMessageType : uint8
{
	None                                     = 0,
	Message                                  = 1,
	Join                                     = 2,
	Leave                                    = 3,
	Kick                                     = 4,
	JoinBanned                               = 5,
	Unban                                    = 6,
	Death                                    = 7,
	MatchSettings                            = 8,
	VehicleSpawnAttempt                      = 9,
	VehicleSpawnSuccess                      = 10,
	VehicleSpawnFailure                      = 11,
	EChatMessageType_MAX                     = 12,
};

// Enum BrickRigs.EConnectorShape
// NumValues: 0x000C
enum class EConnectorShape : uint8
{
	Rectangle                                = 0,
	Triangle                                 = 1,
	FlippedTriangle                          = 2,
	IsoscelesTriangle                        = 3,
	Circle                                   = 4,
	HalfCircle                               = 5,
	QuarterCircle                            = 6,
	FlippedQuarterCircle                     = 7,
	InvertedQuarterCircle                    = 8,
	FlippedInvertedQuarterCircle             = 9,
	Diamond                                  = 10,
	EConnectorShape_MAX                      = 11,
};

// Enum BrickRigs.EConnectorSpacing
// NumValues: 0x0008
enum class EConnectorSpacing : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Half                                     = 2,
	Third                                    = 3,
	Double                                   = 4,
	Triple                                   = 5,
	Quadruple                                = 6,
	Max                                      = 7,
};

// Enum BrickRigs.EConnectorGender
// NumValues: 0x0004
enum class EConnectorGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	Neutral                                  = 2,
	EConnectorGender_MAX                     = 3,
};

// Enum BrickRigs.EConnectorType
// NumValues: 0x001E
enum class EConnectorType : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Wheel                                    = 2,
	SphereCoupling                           = 3,
	Hinge                                    = 4,
	Rotor                                    = 5,
	Muzzle                                   = 6,
	LauncherMuzzle                           = 7,
	FlatRadialHinge                          = 8,
	BigHinge                                 = 9,
	Piston                                   = 10,
	LinearCoupling                           = 11,
	Turntable                                = 12,
	FlatLinearActuator                       = 13,
	SmallHinge                               = 14,
	SmallMuzzle                              = 15,
	VerticalHinge                            = 16,
	Hinge3x2                                 = 17,
	SmallTurntable                           = 18,
	LargeTurntable                           = 19,
	LargePiston                              = 20,
	SmallFlatLinearActuator                  = 21,
	MediumHinge                              = 22,
	TinyTurntable                            = 23,
	TinyHinge                                = 24,
	TinyLinearActuator                       = 25,
	TinySphereCoupling                       = 26,
	TinyPiston                               = 27,
	FlareMuzzle                              = 28,
	EConnectorType_MAX                       = 29,
};

// Enum BrickRigs.EBrickDecalShape
// NumValues: 0x0004
enum class EBrickDecalShape : uint8
{
	Square                                   = 0,
	Triangle                                 = 1,
	Circle                                   = 2,
	EBrickDecalShape_MAX                     = 3,
};

// Enum BrickRigs.EBrickEditorArrowType
// NumValues: 0x0003
enum class EBrickEditorArrowType : uint8
{
	Linear                                   = 0,
	Circular                                 = 1,
	EBrickEditorArrowType_MAX                = 2,
};

// Enum BrickRigs.EMirrorMode
// NumValues: 0x0006
enum class EMirrorMode : uint8
{
	None                                     = 0,
	YForward                                 = 1,
	ZForward                                 = 2,
	XYSymmetry                               = 3,
	XYNegSymmetry                            = 4,
	EMirrorMode_MAX                          = 5,
};

// Enum BrickRigs.EJoinSessionState
// NumValues: 0x0005
enum class EJoinSessionState : uint8
{
	None                                     = 0,
	JoinSession                              = 1,
	ClientTravel                             = 2,
	Cancelled                                = 3,
	EJoinSessionState_MAX                    = 4,
};

// Enum BrickRigs.EFreeCamMode
// NumValues: 0x0006
enum class EFreeCamMode : uint8
{
	None                                     = 0,
	Default                                  = 1,
	FollowLocation                           = 2,
	FollowLocationAndRotation                = 3,
	LookAt                                   = 4,
	EFreeCamMode_MAX                         = 5,
};

// Enum BrickRigs.ESearchSessionType
// NumValues: 0x0003
enum class ESearchSessionType : uint8
{
	Server                                   = 0,
	Lobby                                    = 1,
	ESearchSessionType_MAX                   = 2,
};

// Enum BrickRigs.EServerSortMethod
// NumValues: 0x0007
enum class EServerSortMethod : uint8
{
	Name                                     = 0,
	Map                                      = 1,
	GameMode                                 = 2,
	Players                                  = 3,
	PlayersAsc                               = 4,
	Ping                                     = 5,
	EServerSortMethod_MAX                    = 6,
};

// Enum BrickRigs.EVehiclePinMode
// NumValues: 0x0004
enum class EVehiclePinMode : uint8
{
	None                                     = 0,
	RootBrick                                = 1,
	AllBricks                                = 2,
	EVehiclePinMode_MAX                      = 3,
};

// Enum BrickRigs.ECapturePointShape
// NumValues: 0x0004
enum class ECapturePointShape : uint8
{
	Box                                      = 0,
	Sphere                                   = 1,
	Capsule                                  = 2,
	ECapturePointShape_MAX                   = 3,
};

// Enum BrickRigs.ECharacterActionAuth
// NumValues: 0x0004
enum class ECharacterActionAuth : uint8
{
	Local                                    = 0,
	ClientAuth                               = 1,
	ServerAuth                               = 2,
	ECharacterActionAuth_MAX                 = 3,
};

// Enum BrickRigs.ECharacterActionLayer
// NumValues: 0x0004
enum class ECharacterActionLayer : uint8
{
	UpperBody                                = 0,
	LowerBody                                = 1,
	FullBody                                 = 2,
	ECharacterActionLayer_MAX                = 3,
};

// Enum BrickRigs.ECharacterHealingState
// NumValues: 0x0004
enum class ECharacterHealingState : uint8
{
	NotHealing                               = 0,
	Healing                                  = 1,
	HealingFirstAidKit                       = 2,
	ECharacterHealingState_MAX               = 3,
};

// Enum BrickRigs.ECharacterStateOfHealth
// NumValues: 0x0004
enum class ECharacterStateOfHealth : uint8
{
	Conscious                                = 0,
	Unconscious                              = 1,
	Dead                                     = 2,
	ECharacterStateOfHealth_MAX              = 3,
};

// Enum BrickRigs.EControlHintDisplayInfoMode
// NumValues: 0x0004
enum class EControlHintDisplayInfoMode : uint8
{
	Auto                                     = 0,
	Custom                                   = 1,
	Hidden                                   = 2,
	EControlHintDisplayInfoMode_MAX          = 3,
};

// Enum BrickRigs.ECouplingMode
// NumValues: 0x0003
enum class ECouplingMode : uint8
{
	Default                                  = 0,
	Static                                   = 1,
	ECouplingMode_MAX                        = 2,
};

// Enum BrickRigs.EJointFrame
// NumValues: 0x0003
enum class EJointFrame : uint8
{
	Frame0                                   = 0,
	Frame1                                   = 1,
	EJointFrame_MAX                          = 2,
};

// Enum BrickRigs.EDragRaceState
// NumValues: 0x0005
enum class EDragRaceState : uint8
{
	None                                     = 0,
	Countdown                                = 1,
	InProgress                               = 2,
	Cancelled                                = 3,
	EDragRaceState_MAX                       = 4,
};

// Enum BrickRigs.EElevatorDirection
// NumValues: 0x0004
enum class EElevatorDirection : uint8
{
	Stop                                     = 0,
	Up                                       = 1,
	Down                                     = 2,
	EElevatorDirection_MAX                   = 3,
};

// Enum BrickRigs.EExplosiveItemState
// NumValues: 0x0004
enum class EExplosiveItemState : uint8
{
	Safe                                     = 0,
	Primed                                   = 1,
	Exploded                                 = 2,
	EExplosiveItemState_MAX                  = 3,
};

// Enum BrickRigs.EChamberState
// NumValues: 0x0004
enum class EChamberState : uint8
{
	Empty                                    = 0,
	EmptyShell                               = 1,
	Cocked                                   = 2,
	EChamberState_MAX                        = 3,
};

// Enum BrickRigs.EFireMode
// NumValues: 0x0005
enum class EFireMode : uint8
{
	Single                                   = 0,
	Semi                                     = 1,
	Burst                                    = 2,
	Auto                                     = 3,
	EFireMode_MAX                            = 4,
};

// Enum BrickRigs.EFluAxisLock
// NumValues: 0x0006
enum class EFluAxisLock : uint8
{
	None                                     = 0,
	XY                                       = 1,
	XZ                                       = 2,
	YZ                                       = 3,
	All                                      = 4,
	EFluAxisLock_MAX                         = 5,
};

// Enum BrickRigs.EFluAxisSigned
// NumValues: 0x0008
enum class EFluAxisSigned : uint8
{
	None                                     = 0,
	XPos                                     = 1,
	YPos                                     = 2,
	ZPos                                     = 3,
	XNeg                                     = 4,
	YNeg                                     = 5,
	ZNeg                                     = 6,
	EFluAxisSigned_MAX                       = 7,
};

// Enum BrickRigs.EInputRowType
// NumValues: 0x0007
enum class EInputRowType : uint8
{
	PressAction                              = 0,
	ReleaseAction                            = 1,
	PressReleaseAction                       = 2,
	HoldAction                               = 3,
	Axis                                     = 4,
	HalfAxis                                 = 5,
	EInputRowType_MAX                        = 6,
};

// Enum BrickRigs.EItemTag
// NumValues: 0x000C
enum class EItemTag : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	Firearm                                  = 2,
	Attachment                               = 3,
	AmmoBox                                  = 4,
	Explosive                                = 5,
	Grenade                                  = 6,
	FirstAidKit                              = 7,
	FireExtinguisher                         = 8,
	Paint                                    = 9,
	Wearable                                 = 10,
	EItemTag_MAX                             = 11,
};

// Enum BrickRigs.EKickedPlayerSortMethod
// NumValues: 0x0007
enum class EKickedPlayerSortMethod : uint8
{
	PlayerName                               = 0,
	PlayerNameAsc                            = 1,
	KickDate                                 = 2,
	KickDateAsc                              = 3,
	TimeRemaining                            = 4,
	TimeRemainingAsc                         = 5,
	EKickedPlayerSortMethod_MAX              = 6,
};

// Enum BrickRigs.EBuildingSide
// NumValues: 0x0005
enum class EBuildingSide : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	Front                                    = 2,
	Back                                     = 3,
	EBuildingSide_MAX                        = 4,
};

// Enum BrickRigs.ELightBrickDirection
// NumValues: 0x0009
enum class ELightBrickDirection : uint8
{
	None                                     = 0,
	Omnidirectional                          = 1,
	X                                        = 2,
	XNeg                                     = 3,
	Y                                        = 4,
	YNeg                                     = 5,
	Z                                        = 6,
	ZNeg                                     = 7,
	ELightBrickDirection_MAX                 = 8,
};

// Enum BrickRigs.EMathBrickOperation
// NumValues: 0x001E
enum class EMathBrickOperation : uint8
{
	Add                                      = 0,
	Subtract                                 = 1,
	Multiply                                 = 2,
	Divide                                   = 3,
	Fmod                                     = 4,
	Power                                    = 5,
	Greater                                  = 6,
	Less                                     = 7,
	Min                                      = 8,
	Max                                      = 9,
	MAX_Binary                               = 9,
	Abs                                      = 10,
	Sign                                     = 11,
	Round                                    = 12,
	Ceil                                     = 13,
	Floor                                    = 14,
	Sqrt                                     = 15,
	Sin                                      = 16,
	SinDeg                                   = 17,
	Asin                                     = 18,
	AsinDeg                                  = 19,
	Cos                                      = 20,
	CosDeg                                   = 21,
	Acos                                     = 22,
	AcosDeg                                  = 23,
	Tan                                      = 24,
	TanDeg                                   = 25,
	Atan                                     = 26,
	AtanDeg                                  = 27,
	MAX_Unary                                = 26,
};

// Enum BrickRigs.EMenuPageSize
// NumValues: 0x0003
enum class EMenuPageSize : uint8
{
	Default                                  = 0,
	Large                                    = 1,
	EMenuPageSize_MAX                        = 2,
};

// Enum BrickRigs.EDLSSMode
// NumValues: 0x0009
enum class EDLSSMode : uint8
{
	Off                                      = 0,
	Auto                                     = 1,
	DLAA                                     = 2,
	UltraQuality                             = 3,
	Quality                                  = 4,
	Balanced                                 = 5,
	Performance                              = 6,
	UltraPerformance                         = 7,
	EDLSSMode_MAX                            = 8,
};

// Enum BrickRigs.EPlayerSpawnResult
// NumValues: 0x0012
enum class EPlayerSpawnResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	UnsavedChanges                           = 2,
	SentToServer                             = 3,
	BrickLimitExceeded                       = 4,
	MassExceeded                             = 5,
	SizeExceeded                             = 6,
	VehicleLimitExceeded                     = 7,
	VehicleNotPublicOnline                   = 8,
	VehicleNotWhitelisted                    = 9,
	OnlyAdminsCanSpawn                       = 10,
	InsufficientFunds                        = 11,
	NoObjects                                = 12,
	Cooldown                                 = 13,
	CorruptFile                              = 14,
	ValidationFailure                        = 15,
	IncompatibleVersion                      = 16,
	EPlayerSpawnResult_MAX                   = 17,
};

// Enum BrickRigs.EPlayerVehicleSpawnInvincibility
// NumValues: 0x0004
enum class EPlayerVehicleSpawnInvincibility : uint8
{
	None                                     = 0,
	Invincible                               = 1,
	Pinned                                   = 2,
	EPlayerVehicleSpawnInvincibility_MAX     = 3,
};

// Enum BrickRigs.EPlayerVehicleSpawnType
// NumValues: 0x0006
enum class EPlayerVehicleSpawnType : uint8
{
	Exit                                     = 0,
	Teleport                                 = 1,
	Scrap                                    = 2,
	SpawnNew                                 = 3,
	ReplaceCurrent                           = 4,
	EPlayerVehicleSpawnType_MAX              = 5,
};

// Enum BrickRigs.EPlayerSpawnType
// NumValues: 0x0005
enum class EPlayerSpawnType : uint8
{
	None                                     = 0,
	OnSpot                                   = 1,
	AtTransform                              = 2,
	AtSpawnPoint                             = 3,
	EPlayerSpawnType_MAX                     = 4,
};

// Enum BrickRigs.EPopupSizeRule
// NumValues: 0x0005
enum class EPopupSizeRule : uint8
{
	Auto                                     = 0,
	Fill                                     = 1,
	FillH                                    = 2,
	FillV                                    = 3,
	EPopupSizeRule_MAX                       = 4,
};

// Enum BrickRigs.EScalableBrickShape
// NumValues: 0x001C
enum class EScalableBrickShape : uint8
{
	Box                                      = 0,
	Ramp                                     = 1,
	Cylinder                                 = 2,
	HalfCylinder                             = 3,
	Cone                                     = 4,
	QuarterCone                              = 5,
	HalfCone                                 = 6,
	ConeFlat                                 = 7,
	Hemisphere                               = 8,
	QuarterSphere                            = 9,
	RampRounded                              = 10,
	RampRoundedN                             = 11,
	Corner                                   = 12,
	CornerN                                  = 13,
	CornerRounded                            = 14,
	CornerRoundedN                           = 15,
	Pyramid                                  = 16,
	PyramidCorner                            = 17,
	PyramidCornerRounded                     = 18,
	Wedge                                    = 19,
	WedgeCorner                              = 20,
	Cylinder90R0                             = 21,
	Cylinder90R1                             = 22,
	Flag                                     = 23,
	TankCylinder                             = 24,
	Button                                   = 25,
	Flap                                     = 26,
	EScalableBrickShape_MAX                  = 27,
};

// Enum BrickRigs.EProximitySensorMask
// NumValues: 0x0007
enum class EProximitySensorMask : uint8
{
	All                                      = 0,
	Vehicles                                 = 1,
	OtherVehicles                            = 2,
	Pawn                                     = 3,
	Static                                   = 4,
	Water                                    = 5,
	EProximitySensorMask_MAX                 = 6,
};

// Enum BrickRigs.ESensorType
// NumValues: 0x0017
enum class ESensorType : uint8
{
	Speed                                    = 0,
	Acceleration                             = 1,
	Distance                                 = 2,
	Time                                     = 3,
	Proximity                                = 4,
	DistanceToGround                         = 5,
	Altitude                                 = 6,
	AbsAltitude                              = 7,
	Pitch                                    = 8,
	Yaw                                      = 9,
	Roll                                     = 10,
	AngularSpeed                             = 11,
	NormalSpeed                              = 12,
	NormalAcceleration                       = 13,
	NormalAngularSpeed                       = 14,
	NumSeekingProjectiles                    = 15,
	SeekingProjectileDistance                = 16,
	DeltaTime                                = 17,
	Framerate                                = 18,
	TimeOfDay                                = 19,
	WindSpeed                                = 20,
	WindDirection                            = 21,
	ESensorType_MAX                          = 22,
};

// Enum BrickRigs.ESpinnerBrickShape
// NumValues: 0x000E
enum class ESpinnerBrickShape : uint8
{
	Rectangle                                = 0,
	TriangleIn                               = 1,
	TriangleOut                              = 2,
	IsoscelesTriangleIn                      = 3,
	IsoscelesTriangleOut                     = 4,
	IsoscelesTriangleUp                      = 5,
	Circle                                   = 6,
	HalfCircleIn                             = 7,
	HalfCircleOut                            = 8,
	HalfCircleUp                             = 9,
	QuarterCircleIn                          = 10,
	QuarterCircleOut                         = 11,
	Diamond                                  = 12,
	Max                                      = 13,
};

// Enum BrickRigs.EUGCBrowserMode
// NumValues: 0x0009
enum class EUGCBrowserMode : uint8
{
	None                                     = 0,
	Spawn                                    = 1,
	Open                                     = 2,
	Import                                   = 3,
	Save                                     = 4,
	Upload                                   = 5,
	Property                                 = 6,
	ArrayProperty                            = 7,
	EUGCBrowserMode_MAX                      = 8,
};

// Enum BrickRigs.EUGCTaskPopupType
// NumValues: 0x0004
enum class EUGCTaskPopupType : uint8
{
	None                                     = 0,
	Download                                 = 1,
	Upload                                   = 2,
	EUGCTaskPopupType_MAX                    = 3,
};

// Enum BrickRigs.EUGCSortMethod
// NumValues: 0x000B
enum class EUGCSortMethod : uint8
{
	TitleAsc                                 = 0,
	CreationOrderAsc                         = 1,
	CreationOrderDesc                        = 2,
	LastUpdatedDesc                          = 3,
	SubscriptionDateDesc                     = 4,
	Trending                                 = 5,
	PlaytimeTrending                         = 6,
	TotalPlaytime                            = 7,
	TotalUniqueSubscriptions                 = 8,
	SearchRelevancy                          = 9,
	Max                                      = 10,
};

// Enum BrickRigs.EUGCQueryType
// NumValues: 0x0008
enum class EUGCQueryType : uint8
{
	Local                                    = 0,
	Online                                   = 1,
	Published                                = 2,
	Subscribed                               = 3,
	Favorited                                = 4,
	RecentlyUsed                             = 5,
	Selection                                = 6,
	Max                                      = 7,
};

// Enum BrickRigs.EVehicleDashboardType
// NumValues: 0x0006
enum class EVehicleDashboardType : uint8
{
	None                                     = 0,
	Car                                      = 1,
	RaceCar                                  = 2,
	Aircraft                                 = 3,
	Advanced                                 = 4,
	Max                                      = 5,
};

// Enum BrickRigs.EVehicleInputAxis
// NumValues: 0x002F
enum class EVehicleInputAxis : uint8
{
	None                                     = 0,
	Steering                                 = 1,
	FirstAxis                                = 1,
	FirstPlayerAxis                          = 1,
	Throttle                                 = 2,
	Brake                                    = 3,
	Pitch                                    = 4,
	ViewPitch                                = 5,
	ViewYaw                                  = 6,
	LastAxis                                 = 6,
	LastPlayerAxis                           = 6,
	SteeringAlt                              = 7,
	FirstAltAxis                             = 7,
	ThrottleAlt                              = 8,
	BrakeAlt                                 = 9,
	PitchAlt                                 = 10,
	ViewPitchAlt                             = 11,
	ViewYawAlt                               = 12,
	LastAltAxis                              = 12,
	Horn                                     = 13,
	FirstAction                              = 13,
	FirstPlayerAction                        = 13,
	Action1                                  = 14,
	FirstFireAction                          = 14,
	Action2                                  = 15,
	Action3                                  = 16,
	Action4                                  = 17,
	Action5                                  = 18,
	Action6                                  = 19,
	Action7                                  = 20,
	Action8                                  = 21,
	LastFireAction                           = 21,
	DisableSteering                          = 22,
	InvertSteering                           = 23,
	HandBrake                                = 24,
	OperationMode                            = 25,
	Headlight                                = 26,
	Beacon                                   = 27,
	WarningLight                             = 28,
	LastPlayerAction                         = 28,
	Taillight                                = 29,
	BrakeLight                               = 30,
	ReversingLight                           = 31,
	LastAction                               = 31,
	AlwaysOn                                 = 32,
	Custom                                   = 33,
	Max                                      = 34,
};

// Enum BrickRigs.EWearableTag
// NumValues: 0x0003
enum class EWearableTag : uint8
{
	Pants                                    = 0,
	Shirt                                    = 1,
	EWearableTag_MAX                         = 2,
};

// Enum BrickRigs.EPrecipitationType
// NumValues: 0x0004
enum class EPrecipitationType : uint8
{
	None                                     = 0,
	Rain                                     = 1,
	Snow                                     = 2,
	Max                                      = 3,
};

// Enum BrickRigs.EMainWidgetType
// NumValues: 0x0005
enum class EMainWidgetType : uint8
{
	None                                     = 0,
	IntroSequence                            = 1,
	Menu                                     = 2,
	HUD                                      = 3,
	Max                                      = 4,
};

// ScriptStruct BrickRigs.ConnectorField
// 0x0030 (0x0030 - 0x0000)
struct FConnectorField final
{
public:
	EConnectorType                                Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectorGender                              Gender;                                            // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFluAxisSigned                                Direction;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumX;                                              // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumY;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectorSpacing                             Spacing;                                           // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectorShape                               Shape;                                             // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ShapeRelativeSize;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConnectorField) == 0x000004, "Wrong alignment on FConnectorField");
static_assert(sizeof(FConnectorField) == 0x000030, "Wrong size on FConnectorField");
static_assert(offsetof(FConnectorField, Type) == 0x000000, "Member 'FConnectorField::Type' has a wrong offset!");
static_assert(offsetof(FConnectorField, Gender) == 0x000001, "Member 'FConnectorField::Gender' has a wrong offset!");
static_assert(offsetof(FConnectorField, Direction) == 0x000002, "Member 'FConnectorField::Direction' has a wrong offset!");
static_assert(offsetof(FConnectorField, Origin) == 0x000004, "Member 'FConnectorField::Origin' has a wrong offset!");
static_assert(offsetof(FConnectorField, Rotation) == 0x000010, "Member 'FConnectorField::Rotation' has a wrong offset!");
static_assert(offsetof(FConnectorField, NumX) == 0x00001C, "Member 'FConnectorField::NumX' has a wrong offset!");
static_assert(offsetof(FConnectorField, NumY) == 0x000020, "Member 'FConnectorField::NumY' has a wrong offset!");
static_assert(offsetof(FConnectorField, Spacing) == 0x000024, "Member 'FConnectorField::Spacing' has a wrong offset!");
static_assert(offsetof(FConnectorField, Shape) == 0x000025, "Member 'FConnectorField::Shape' has a wrong offset!");
static_assert(offsetof(FConnectorField, ShapeRelativeSize) == 0x000028, "Member 'FConnectorField::ShapeRelativeSize' has a wrong offset!");

// ScriptStruct BrickRigs.BrickUIBrushStyle
// 0x0770 (0x0770 - 0x0000)
struct FBrickUIBrushStyle final
{
public:
	struct FSlateBrush                            Brushes[0xE];                                      // 0x0000(0x0088)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickUIBrushStyle) == 0x000008, "Wrong alignment on FBrickUIBrushStyle");
static_assert(sizeof(FBrickUIBrushStyle) == 0x000770, "Wrong size on FBrickUIBrushStyle");
static_assert(offsetof(FBrickUIBrushStyle, Brushes) == 0x000000, "Member 'FBrickUIBrushStyle::Brushes' has a wrong offset!");

// ScriptStruct BrickRigs.BrickUIIconAtlas
// 0x0010 (0x0010 - 0x0000)
struct FBrickUIIconAtlas final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumX;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumY;                                              // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartIndex;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickUIIconAtlas) == 0x000008, "Wrong alignment on FBrickUIIconAtlas");
static_assert(sizeof(FBrickUIIconAtlas) == 0x000010, "Wrong size on FBrickUIIconAtlas");
static_assert(offsetof(FBrickUIIconAtlas, Texture) == 0x000000, "Member 'FBrickUIIconAtlas::Texture' has a wrong offset!");
static_assert(offsetof(FBrickUIIconAtlas, NumX) == 0x000008, "Member 'FBrickUIIconAtlas::NumX' has a wrong offset!");
static_assert(offsetof(FBrickUIIconAtlas, NumY) == 0x000009, "Member 'FBrickUIIconAtlas::NumY' has a wrong offset!");
static_assert(offsetof(FBrickUIIconAtlas, StartIndex) == 0x00000C, "Member 'FBrickUIIconAtlas::StartIndex' has a wrong offset!");

// ScriptStruct BrickRigs.BrickStructPropertyInterface
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FBrickStructPropertyInterface
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickStructPropertyInterface) == 0x000008, "Wrong alignment on FBrickStructPropertyInterface");
static_assert(sizeof(FBrickStructPropertyInterface) == 0x000008, "Wrong size on FBrickStructPropertyInterface");

// ScriptStruct BrickRigs.PagedListEntry
// 0x0000 (0x0008 - 0x0008)
struct FPagedListEntry : public FBrickStructPropertyInterface
{
};
static_assert(alignof(FPagedListEntry) == 0x000008, "Wrong alignment on FPagedListEntry");
static_assert(sizeof(FPagedListEntry) == 0x000008, "Wrong size on FPagedListEntry");

// ScriptStruct BrickRigs.BrickOnlineSessionInfo
// 0x0160 (0x0168 - 0x0008)
struct FBrickOnlineSessionInfo final : public FPagedListEntry
{
public:
	class FString                                 SessionName;                                       // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionDescription;                                // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelInfo*                             Level;                                             // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameModeInfo*                          GameMode;                                          // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPlayers;                                    // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ping;                                              // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AverageFrameRate;                                  // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDedicated;                                      // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPasswordProtected;                              // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCompatibleBuild;                                // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMods;                                          // 0x004B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSameMods;                                      // 0x004C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowDifferentMods;                               // 0x004D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x11A];                                     // 0x004E(0x011A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickOnlineSessionInfo) == 0x000008, "Wrong alignment on FBrickOnlineSessionInfo");
static_assert(sizeof(FBrickOnlineSessionInfo) == 0x000168, "Wrong size on FBrickOnlineSessionInfo");
static_assert(offsetof(FBrickOnlineSessionInfo, SessionName) == 0x000008, "Member 'FBrickOnlineSessionInfo::SessionName' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, SessionDescription) == 0x000018, "Member 'FBrickOnlineSessionInfo::SessionDescription' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, Level) == 0x000028, "Member 'FBrickOnlineSessionInfo::Level' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, GameMode) == 0x000030, "Member 'FBrickOnlineSessionInfo::GameMode' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, CurrentPlayers) == 0x000038, "Member 'FBrickOnlineSessionInfo::CurrentPlayers' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, MaxPlayers) == 0x00003C, "Member 'FBrickOnlineSessionInfo::MaxPlayers' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, Ping) == 0x000040, "Member 'FBrickOnlineSessionInfo::Ping' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, AverageFrameRate) == 0x000044, "Member 'FBrickOnlineSessionInfo::AverageFrameRate' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bIsDedicated) == 0x000048, "Member 'FBrickOnlineSessionInfo::bIsDedicated' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bIsPasswordProtected) == 0x000049, "Member 'FBrickOnlineSessionInfo::bIsPasswordProtected' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bIsCompatibleBuild) == 0x00004A, "Member 'FBrickOnlineSessionInfo::bIsCompatibleBuild' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bHasMods) == 0x00004B, "Member 'FBrickOnlineSessionInfo::bHasMods' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bHasSameMods) == 0x00004C, "Member 'FBrickOnlineSessionInfo::bHasSameMods' has a wrong offset!");
static_assert(offsetof(FBrickOnlineSessionInfo, bAllowDifferentMods) == 0x00004D, "Member 'FBrickOnlineSessionInfo::bAllowDifferentMods' has a wrong offset!");

// ScriptStruct BrickRigs.BrickEditorObjectEditorParams
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FBrickEditorObjectEditorParams
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickEditorObjectEditorParams) == 0x000004, "Wrong alignment on FBrickEditorObjectEditorParams");
static_assert(sizeof(FBrickEditorObjectEditorParams) == 0x000010, "Wrong size on FBrickEditorObjectEditorParams");

// ScriptStruct BrickRigs.BrickEditorParams
// 0x0018 (0x0028 - 0x0010)
struct alignas(0x08) FBrickEditorParams : public FBrickEditorObjectEditorParams
{
public:
	uint8                                         Pad_10[0x18];                                      // 0x0010(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickEditorParams) == 0x000008, "Wrong alignment on FBrickEditorParams");
static_assert(sizeof(FBrickEditorParams) == 0x000028, "Wrong size on FBrickEditorParams");

// ScriptStruct BrickRigs.ScalableBrickBaseEditorParams
// 0x0008 (0x0030 - 0x0028)
struct FScalableBrickBaseEditorParams : public FBrickEditorParams
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableBrickBaseEditorParams) == 0x000008, "Wrong alignment on FScalableBrickBaseEditorParams");
static_assert(sizeof(FScalableBrickBaseEditorParams) == 0x000030, "Wrong size on FScalableBrickBaseEditorParams");

// ScriptStruct BrickRigs.ScalableBrickEditorParams
// 0x0008 (0x0038 - 0x0030)
struct FScalableBrickEditorParams : public FScalableBrickBaseEditorParams
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableBrickEditorParams) == 0x000008, "Wrong alignment on FScalableBrickEditorParams");
static_assert(sizeof(FScalableBrickEditorParams) == 0x000038, "Wrong size on FScalableBrickEditorParams");

// ScriptStruct BrickRigs.FlapBrickEditorParams
// 0x0008 (0x0040 - 0x0038)
struct FFlapBrickEditorParams final : public FScalableBrickEditorParams
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFlapBrickEditorParams) == 0x000008, "Wrong alignment on FFlapBrickEditorParams");
static_assert(sizeof(FFlapBrickEditorParams) == 0x000040, "Wrong size on FFlapBrickEditorParams");

// ScriptStruct BrickRigs.BrickUIColorStyle
// 0x00E0 (0x00E0 - 0x0000)
struct FBrickUIColorStyle final
{
public:
	struct FLinearColor                           Colors[0xE];                                       // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickUIColorStyle) == 0x000004, "Wrong alignment on FBrickUIColorStyle");
static_assert(sizeof(FBrickUIColorStyle) == 0x0000E0, "Wrong size on FBrickUIColorStyle");
static_assert(offsetof(FBrickUIColorStyle, Colors) == 0x000000, "Member 'FBrickUIColorStyle::Colors' has a wrong offset!");

// ScriptStruct BrickRigs.InteractionOption
// 0x0050 (0x0050 - 0x0000)
struct FInteractionOption final
{
public:
	TDelegate<void(class ABrickPlayerController* InPC)> OnInteractionDelegate;                       // 0x0000(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ABrickPlayerController* InPC)> OnReleasedDelegate;                          // 0x0010(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class ABrickPlayerController* InPC, float Val)> OnInteractionAxisDelegate;        // 0x0020(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0030(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionOption) == 0x000008, "Wrong alignment on FInteractionOption");
static_assert(sizeof(FInteractionOption) == 0x000050, "Wrong size on FInteractionOption");
static_assert(offsetof(FInteractionOption, OnInteractionDelegate) == 0x000000, "Member 'FInteractionOption::OnInteractionDelegate' has a wrong offset!");
static_assert(offsetof(FInteractionOption, OnReleasedDelegate) == 0x000010, "Member 'FInteractionOption::OnReleasedDelegate' has a wrong offset!");
static_assert(offsetof(FInteractionOption, OnInteractionAxisDelegate) == 0x000020, "Member 'FInteractionOption::OnInteractionAxisDelegate' has a wrong offset!");
static_assert(offsetof(FInteractionOption, DisplayText) == 0x000030, "Member 'FInteractionOption::DisplayText' has a wrong offset!");
static_assert(offsetof(FInteractionOption, bIsEnabled) == 0x000048, "Member 'FInteractionOption::bIsEnabled' has a wrong offset!");

// ScriptStruct BrickRigs.InteractionOptions
// 0x0068 (0x0068 - 0x0000)
struct FInteractionOptions final
{
public:
	EHUDIconDomain                                Domain;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInteractionOptionSlot, struct FInteractionOption> Options;                                 // 0x0008(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractionOption>             AdditionalOptions;                                 // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInteractionOptions) == 0x000008, "Wrong alignment on FInteractionOptions");
static_assert(sizeof(FInteractionOptions) == 0x000068, "Wrong size on FInteractionOptions");
static_assert(offsetof(FInteractionOptions, Domain) == 0x000000, "Member 'FInteractionOptions::Domain' has a wrong offset!");
static_assert(offsetof(FInteractionOptions, Options) == 0x000008, "Member 'FInteractionOptions::Options' has a wrong offset!");
static_assert(offsetof(FInteractionOptions, AdditionalOptions) == 0x000058, "Member 'FInteractionOptions::AdditionalOptions' has a wrong offset!");

// ScriptStruct BrickRigs.DragRaceLane
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDragRaceLane final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragRaceLane) == 0x000008, "Wrong alignment on FDragRaceLane");
static_assert(sizeof(FDragRaceLane) == 0x000018, "Wrong size on FDragRaceLane");

// ScriptStruct BrickRigs.TooltipContent
// 0x0040 (0x0040 - 0x0000)
struct FTooltipContent final
{
public:
	class FText                                   TitleText;                                         // 0x0000(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ContentText;                                       // 0x0018(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputActionTriggerType                       TriggerType;                                       // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickUIColorStyle                            ColorStyle;                                        // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTooltipContent) == 0x000008, "Wrong alignment on FTooltipContent");
static_assert(sizeof(FTooltipContent) == 0x000040, "Wrong size on FTooltipContent");
static_assert(offsetof(FTooltipContent, TitleText) == 0x000000, "Member 'FTooltipContent::TitleText' has a wrong offset!");
static_assert(offsetof(FTooltipContent, ContentText) == 0x000018, "Member 'FTooltipContent::ContentText' has a wrong offset!");
static_assert(offsetof(FTooltipContent, ActionName) == 0x000030, "Member 'FTooltipContent::ActionName' has a wrong offset!");
static_assert(offsetof(FTooltipContent, TriggerType) == 0x000038, "Member 'FTooltipContent::TriggerType' has a wrong offset!");
static_assert(offsetof(FTooltipContent, ColorStyle) == 0x000039, "Member 'FTooltipContent::ColorStyle' has a wrong offset!");

// ScriptStruct BrickRigs.BoneFlinchInfo
// 0x000C (0x000C - 0x0000)
struct FBoneFlinchInfo final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlinchAngle;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneFlinchInfo) == 0x000004, "Wrong alignment on FBoneFlinchInfo");
static_assert(sizeof(FBoneFlinchInfo) == 0x00000C, "Wrong size on FBoneFlinchInfo");
static_assert(offsetof(FBoneFlinchInfo, BoneName) == 0x000000, "Member 'FBoneFlinchInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FBoneFlinchInfo, MaxFlinchAngle) == 0x000008, "Member 'FBoneFlinchInfo::MaxFlinchAngle' has a wrong offset!");

// ScriptStruct BrickRigs.HUDIconProperties
// 0x0030 (0x0030 - 0x0000)
struct FHUDIconProperties final
{
public:
	TSoftClassPtr<class UClass>                   IconWidgetClass;                                   // 0x0000(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         VisibilityFlags;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHUDVisibility                                MaxHUDVisibility;                                  // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDrawDist;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHUDIconProperties) == 0x000008, "Wrong alignment on FHUDIconProperties");
static_assert(sizeof(FHUDIconProperties) == 0x000030, "Wrong size on FHUDIconProperties");
static_assert(offsetof(FHUDIconProperties, IconWidgetClass) == 0x000000, "Member 'FHUDIconProperties::IconWidgetClass' has a wrong offset!");
static_assert(offsetof(FHUDIconProperties, VisibilityFlags) == 0x000028, "Member 'FHUDIconProperties::VisibilityFlags' has a wrong offset!");
static_assert(offsetof(FHUDIconProperties, MaxHUDVisibility) == 0x000029, "Member 'FHUDIconProperties::MaxHUDVisibility' has a wrong offset!");
static_assert(offsetof(FHUDIconProperties, MaxDrawDist) == 0x00002C, "Member 'FHUDIconProperties::MaxDrawDist' has a wrong offset!");

// ScriptStruct BrickRigs.BrickUIIconSlot
// 0x0008 (0x0008 - 0x0000)
struct FBrickUIIconSlot final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ColumnSpan;                                        // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         RowSpan;                                           // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickUIIconSlot) == 0x000004, "Wrong alignment on FBrickUIIconSlot");
static_assert(sizeof(FBrickUIIconSlot) == 0x000008, "Wrong size on FBrickUIIconSlot");
static_assert(offsetof(FBrickUIIconSlot, Index) == 0x000000, "Member 'FBrickUIIconSlot::Index' has a wrong offset!");
static_assert(offsetof(FBrickUIIconSlot, ColumnSpan) == 0x000004, "Member 'FBrickUIIconSlot::ColumnSpan' has a wrong offset!");
static_assert(offsetof(FBrickUIIconSlot, RowSpan) == 0x000005, "Member 'FBrickUIIconSlot::RowSpan' has a wrong offset!");

// ScriptStruct BrickRigs.HUDIconContext
// 0x0008 (0x0008 - 0x0000)
struct FHUDIconContext final
{
public:
	EHUDIconDomain                                Domain;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHUDVisibility                                hudvisibility;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowInteraction;                                  // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDistanceScale;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FHUDIconContext) == 0x000004, "Wrong alignment on FHUDIconContext");
static_assert(sizeof(FHUDIconContext) == 0x000008, "Wrong size on FHUDIconContext");
static_assert(offsetof(FHUDIconContext, Domain) == 0x000000, "Member 'FHUDIconContext::Domain' has a wrong offset!");
static_assert(offsetof(FHUDIconContext, hudvisibility) == 0x000001, "Member 'FHUDIconContext::hudvisibility' has a wrong offset!");
static_assert(offsetof(FHUDIconContext, bShowInteraction) == 0x000002, "Member 'FHUDIconContext::bShowInteraction' has a wrong offset!");
static_assert(offsetof(FHUDIconContext, DrawDistanceScale) == 0x000004, "Member 'FHUDIconContext::DrawDistanceScale' has a wrong offset!");

// ScriptStruct BrickRigs.BrickEditorObjectFilterParams
// 0x0070 (0x0070 - 0x0000)
struct FBrickEditorObjectFilterParams final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         ThumbnailOverrideClass;                            // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FilterTags;                                        // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        BrickSizes;                                        // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickEditorObjectFilterParams) == 0x000008, "Wrong alignment on FBrickEditorObjectFilterParams");
static_assert(sizeof(FBrickEditorObjectFilterParams) == 0x000070, "Wrong size on FBrickEditorObjectFilterParams");
static_assert(offsetof(FBrickEditorObjectFilterParams, DisplayName) == 0x000010, "Member 'FBrickEditorObjectFilterParams::DisplayName' has a wrong offset!");
static_assert(offsetof(FBrickEditorObjectFilterParams, ThumbnailOverrideClass) == 0x000028, "Member 'FBrickEditorObjectFilterParams::ThumbnailOverrideClass' has a wrong offset!");
static_assert(offsetof(FBrickEditorObjectFilterParams, FilterTags) == 0x000040, "Member 'FBrickEditorObjectFilterParams::FilterTags' has a wrong offset!");
static_assert(offsetof(FBrickEditorObjectFilterParams, BrickSizes) == 0x000060, "Member 'FBrickEditorObjectFilterParams::BrickSizes' has a wrong offset!");

// ScriptStruct BrickRigs.BrickTickFunction
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FBrickTickFunction final
{
public:
	float                                         TickInterval;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanEverTick : 1;                                  // 0x0004(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowTickOnDedicatedServer : 1;                   // 0x0004(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAllowTickInEditor : 1;                            // 0x0004(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_5[0x13];                                       // 0x0005(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickTickFunction) == 0x000008, "Wrong alignment on FBrickTickFunction");
static_assert(sizeof(FBrickTickFunction) == 0x000018, "Wrong size on FBrickTickFunction");
static_assert(offsetof(FBrickTickFunction, TickInterval) == 0x000000, "Member 'FBrickTickFunction::TickInterval' has a wrong offset!");

// ScriptStruct BrickRigs.WorldSetupParams
// 0x0028 (0x0030 - 0x0008)
struct FWorldSetupParams final : public FBrickStructPropertyInterface
{
public:
	float                                         SunAngle;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SunYaw;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfDay;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              DayLength;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtmosphereDensity;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeatherCondition*                      Weather;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldSetupParams) == 0x000008, "Wrong alignment on FWorldSetupParams");
static_assert(sizeof(FWorldSetupParams) == 0x000030, "Wrong size on FWorldSetupParams");
static_assert(offsetof(FWorldSetupParams, SunAngle) == 0x000008, "Member 'FWorldSetupParams::SunAngle' has a wrong offset!");
static_assert(offsetof(FWorldSetupParams, SunYaw) == 0x00000C, "Member 'FWorldSetupParams::SunYaw' has a wrong offset!");
static_assert(offsetof(FWorldSetupParams, TimeOfDay) == 0x000010, "Member 'FWorldSetupParams::TimeOfDay' has a wrong offset!");
static_assert(offsetof(FWorldSetupParams, DayLength) == 0x000018, "Member 'FWorldSetupParams::DayLength' has a wrong offset!");
static_assert(offsetof(FWorldSetupParams, AtmosphereDensity) == 0x000020, "Member 'FWorldSetupParams::AtmosphereDensity' has a wrong offset!");
static_assert(offsetof(FWorldSetupParams, Weather) == 0x000028, "Member 'FWorldSetupParams::Weather' has a wrong offset!");

// ScriptStruct BrickRigs.BrickPropertySettings
// 0x0050 (0x0050 - 0x0000)
struct FBrickPropertySettings final
{
public:
	TMap<class FName, class FString>              Settings;                                          // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickPropertySettings) == 0x000008, "Wrong alignment on FBrickPropertySettings");
static_assert(sizeof(FBrickPropertySettings) == 0x000050, "Wrong size on FBrickPropertySettings");
static_assert(offsetof(FBrickPropertySettings, Settings) == 0x000000, "Member 'FBrickPropertySettings::Settings' has a wrong offset!");

// ScriptStruct BrickRigs.BrickEditorObjectID
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FBrickEditorObjectID final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickEditorObjectID) == 0x000002, "Wrong alignment on FBrickEditorObjectID");
static_assert(sizeof(FBrickEditorObjectID) == 0x000002, "Wrong size on FBrickEditorObjectID");

// ScriptStruct BrickRigs.DisplayInfo
// 0x0028 (0x0028 - 0x0000)
struct FDisplayInfo final
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBrickUIIconAtlas                             IconAtlas;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickUIIconSlot                       IconSlot;                                          // 0x001C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDisplayInfo) == 0x000008, "Wrong alignment on FDisplayInfo");
static_assert(sizeof(FDisplayInfo) == 0x000028, "Wrong size on FDisplayInfo");
static_assert(offsetof(FDisplayInfo, Name) == 0x000000, "Member 'FDisplayInfo::Name' has a wrong offset!");
static_assert(offsetof(FDisplayInfo, IconAtlas) == 0x000018, "Member 'FDisplayInfo::IconAtlas' has a wrong offset!");
static_assert(offsetof(FDisplayInfo, IconSlot) == 0x00001C, "Member 'FDisplayInfo::IconSlot' has a wrong offset!");

// ScriptStruct BrickRigs.BrickComboBoxItemParams
// 0x0140 (0x0140 - 0x0000)
struct FBrickComboBoxItemParams final
{
public:
	bool                                          bIsListItem;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDisplayInfo                           DisplayInfo;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x98];                                      // 0x0058(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IconSizeX;                                         // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconSizeY;                                         // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEmptyIcon;                                    // 0x00F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTooltipContent                        TooltipContent;                                    // 0x0100(0x0040)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickComboBoxItemParams) == 0x000008, "Wrong alignment on FBrickComboBoxItemParams");
static_assert(sizeof(FBrickComboBoxItemParams) == 0x000140, "Wrong size on FBrickComboBoxItemParams");
static_assert(offsetof(FBrickComboBoxItemParams, bIsListItem) == 0x000000, "Member 'FBrickComboBoxItemParams::bIsListItem' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, DisplayInfo) == 0x000008, "Member 'FBrickComboBoxItemParams::DisplayInfo' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, IconTexture) == 0x000030, "Member 'FBrickComboBoxItemParams::IconTexture' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, IconSizeX) == 0x0000F0, "Member 'FBrickComboBoxItemParams::IconSizeX' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, IconSizeY) == 0x0000F4, "Member 'FBrickComboBoxItemParams::IconSizeY' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, bShowEmptyIcon) == 0x0000F8, "Member 'FBrickComboBoxItemParams::bShowEmptyIcon' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, bIsEnabled) == 0x0000F9, "Member 'FBrickComboBoxItemParams::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FBrickComboBoxItemParams, TooltipContent) == 0x000100, "Member 'FBrickComboBoxItemParams::TooltipContent' has a wrong offset!");

// ScriptStruct BrickRigs.ChatMessagePlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct FChatMessagePlayerInfo final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChatMessagePlayerInfo) == 0x000008, "Wrong alignment on FChatMessagePlayerInfo");
static_assert(sizeof(FChatMessagePlayerInfo) == 0x000038, "Wrong size on FChatMessagePlayerInfo");
static_assert(offsetof(FChatMessagePlayerInfo, PlayerId) == 0x000000, "Member 'FChatMessagePlayerInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FChatMessagePlayerInfo, PlayerName) == 0x000028, "Member 'FChatMessagePlayerInfo::PlayerName' has a wrong offset!");

// ScriptStruct BrickRigs.BrickChatMessage
// 0x00A8 (0x00A8 - 0x0000)
struct FBrickChatMessage final
{
public:
	EChatMessageType                              Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChatMessagePlayerInfo                 Player;                                            // 0x0008(0x0038)(NativeAccessSpecifierPrivate)
	struct FChatMessagePlayerInfo                 OtherPlayer;                                       // 0x0040(0x0038)(NativeAccessSpecifierPrivate)
	class FText                                   TextOption;                                        // 0x0078(0x0018)(NativeAccessSpecifierPrivate)
	int32                                         IntOption;                                         // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGenericTeamId                         TeamOption;                                        // 0x0094(0x0001)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFluUGCItemIdWrapper                   OnlineUGCItemIdOption;                             // 0x0098(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBrickChatMessage) == 0x000008, "Wrong alignment on FBrickChatMessage");
static_assert(sizeof(FBrickChatMessage) == 0x0000A8, "Wrong size on FBrickChatMessage");
static_assert(offsetof(FBrickChatMessage, Type) == 0x000000, "Member 'FBrickChatMessage::Type' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, Player) == 0x000008, "Member 'FBrickChatMessage::Player' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, OtherPlayer) == 0x000040, "Member 'FBrickChatMessage::OtherPlayer' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, TextOption) == 0x000078, "Member 'FBrickChatMessage::TextOption' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, IntOption) == 0x000090, "Member 'FBrickChatMessage::IntOption' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, TeamOption) == 0x000094, "Member 'FBrickChatMessage::TeamOption' has a wrong offset!");
static_assert(offsetof(FBrickChatMessage, OnlineUGCItemIdOption) == 0x000098, "Member 'FBrickChatMessage::OnlineUGCItemIdOption' has a wrong offset!");

// ScriptStruct BrickRigs.UGCTags
// 0x0003 (0x0003 - 0x0000)
struct FUGCTags final
{
public:
	EUGCTypeTag                                   Type;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUGCEraTag                                    Era;                                               // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUGCDepartmentTag                             Department;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUGCTags) == 0x000001, "Wrong alignment on FUGCTags");
static_assert(sizeof(FUGCTags) == 0x000003, "Wrong size on FUGCTags");
static_assert(offsetof(FUGCTags, Type) == 0x000000, "Member 'FUGCTags::Type' has a wrong offset!");
static_assert(offsetof(FUGCTags, Era) == 0x000001, "Member 'FUGCTags::Era' has a wrong offset!");
static_assert(offsetof(FUGCTags, Department) == 0x000002, "Member 'FUGCTags::Department' has a wrong offset!");

// ScriptStruct BrickRigs.UGCFileInfo
// 0x00E0 (0x00E8 - 0x0008)
struct FUGCFileInfo final : public FPagedListEntry
{
public:
	EUGCFileType                                  FileType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUGCType                                      UGCType;                                           // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Version;                                           // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUGCContentVersion                            ContentVersion;                                    // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LocalItemId;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFluUGCItemIdWrapper                   OnlineItemId;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NumObjects;                                        // 0x0070(0x0002)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Dimensions;                                        // 0x0074(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              TimeCreated;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              TimeUpdated;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUGCTags                               Tags;                                              // 0x0098(0x0003)(Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x5];                                       // 0x009B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       AuthorId;                                          // 0x00A0(0x0028)(Edit, BlueprintVisible, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VotesUp;                                           // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VotesDown;                                         // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TimePlayedWeek;                                    // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TimePlayedTotal;                                   // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFluUGCVisibility                             Visibility;                                        // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUGCFileInfo) == 0x000008, "Wrong alignment on FUGCFileInfo");
static_assert(sizeof(FUGCFileInfo) == 0x0000E8, "Wrong size on FUGCFileInfo");
static_assert(offsetof(FUGCFileInfo, FileType) == 0x000008, "Member 'FUGCFileInfo::FileType' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, UGCType) == 0x000009, "Member 'FUGCFileInfo::UGCType' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Version) == 0x00000A, "Member 'FUGCFileInfo::Version' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, ContentVersion) == 0x00000B, "Member 'FUGCFileInfo::ContentVersion' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, LocalItemId) == 0x000010, "Member 'FUGCFileInfo::LocalItemId' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, OnlineItemId) == 0x000020, "Member 'FUGCFileInfo::OnlineItemId' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Title) == 0x000050, "Member 'FUGCFileInfo::Title' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Description) == 0x000060, "Member 'FUGCFileInfo::Description' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, NumObjects) == 0x000070, "Member 'FUGCFileInfo::NumObjects' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Dimensions) == 0x000074, "Member 'FUGCFileInfo::Dimensions' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Mass) == 0x000080, "Member 'FUGCFileInfo::Mass' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Price) == 0x000084, "Member 'FUGCFileInfo::Price' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, TimeCreated) == 0x000088, "Member 'FUGCFileInfo::TimeCreated' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, TimeUpdated) == 0x000090, "Member 'FUGCFileInfo::TimeUpdated' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Tags) == 0x000098, "Member 'FUGCFileInfo::Tags' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, AuthorId) == 0x0000A0, "Member 'FUGCFileInfo::AuthorId' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, VotesUp) == 0x0000C8, "Member 'FUGCFileInfo::VotesUp' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, VotesDown) == 0x0000CC, "Member 'FUGCFileInfo::VotesDown' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, TimePlayedWeek) == 0x0000D0, "Member 'FUGCFileInfo::TimePlayedWeek' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, TimePlayedTotal) == 0x0000D8, "Member 'FUGCFileInfo::TimePlayedTotal' has a wrong offset!");
static_assert(offsetof(FUGCFileInfo, Visibility) == 0x0000E0, "Member 'FUGCFileInfo::Visibility' has a wrong offset!");

// ScriptStruct BrickRigs.MatchSettings
// 0x00C0 (0x00C8 - 0x0008)
struct FMatchSettings final : public FBrickStructPropertyInterface
{
public:
	class FString                                 ServerName;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerDescription;                                 // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumPlayerSlots;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelInfo*                             Level;                                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameModeInfo*                          GameMode;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorldSetupParams                      WorldSetupParams;                                  // 0x0040(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTimespan                              RoundDuration;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBalanceTeams;                                 // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAITrains;                                   // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeIn;                                           // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x5];                                       // 0x007B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              RestartDelay;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExemptAdminsFromRestrictions;                     // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInvincibility;                               // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSpawnAnywhere;                               // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowWeapons;                                     // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowExplosions;                                  // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowBuildingDamage;                              // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEnterVehicleWithoutSeat;                     // 0x008E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowRemoveVehicleFromOtherPlayer;                // 0x008F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFreeCam;                                     // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInfiniteAmmo;                                // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowInfiniteFuel;                                // 0x0092(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxDummies;                                        // 0x0093(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMatchVehicleFilter                           VehicleFilter;                                     // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FUGCFileInfo>                   VehicleWhitelist;                                  // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint16                                        MaxBricksPerVehicle;                               // 0x00A8(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVehicleMass;                                    // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVehicleSize;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxVehiclesPerPlayer;                              // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VehiclePriceFactor;                                // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              VehicleRemovalDelay;                               // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchSettings) == 0x000008, "Wrong alignment on FMatchSettings");
static_assert(sizeof(FMatchSettings) == 0x0000C8, "Wrong size on FMatchSettings");
static_assert(offsetof(FMatchSettings, ServerName) == 0x000008, "Member 'FMatchSettings::ServerName' has a wrong offset!");
static_assert(offsetof(FMatchSettings, ServerDescription) == 0x000018, "Member 'FMatchSettings::ServerDescription' has a wrong offset!");
static_assert(offsetof(FMatchSettings, NumPlayerSlots) == 0x000028, "Member 'FMatchSettings::NumPlayerSlots' has a wrong offset!");
static_assert(offsetof(FMatchSettings, Level) == 0x000030, "Member 'FMatchSettings::Level' has a wrong offset!");
static_assert(offsetof(FMatchSettings, GameMode) == 0x000038, "Member 'FMatchSettings::GameMode' has a wrong offset!");
static_assert(offsetof(FMatchSettings, WorldSetupParams) == 0x000040, "Member 'FMatchSettings::WorldSetupParams' has a wrong offset!");
static_assert(offsetof(FMatchSettings, RoundDuration) == 0x000070, "Member 'FMatchSettings::RoundDuration' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAutoBalanceTeams) == 0x000078, "Member 'FMatchSettings::bAutoBalanceTeams' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bEnableAITrains) == 0x000079, "Member 'FMatchSettings::bEnableAITrains' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bFadeIn) == 0x00007A, "Member 'FMatchSettings::bFadeIn' has a wrong offset!");
static_assert(offsetof(FMatchSettings, RestartDelay) == 0x000080, "Member 'FMatchSettings::RestartDelay' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bExemptAdminsFromRestrictions) == 0x000088, "Member 'FMatchSettings::bExemptAdminsFromRestrictions' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowInvincibility) == 0x000089, "Member 'FMatchSettings::bAllowInvincibility' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowSpawnAnywhere) == 0x00008A, "Member 'FMatchSettings::bAllowSpawnAnywhere' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowWeapons) == 0x00008B, "Member 'FMatchSettings::bAllowWeapons' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowExplosions) == 0x00008C, "Member 'FMatchSettings::bAllowExplosions' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowBuildingDamage) == 0x00008D, "Member 'FMatchSettings::bAllowBuildingDamage' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowEnterVehicleWithoutSeat) == 0x00008E, "Member 'FMatchSettings::bAllowEnterVehicleWithoutSeat' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowRemoveVehicleFromOtherPlayer) == 0x00008F, "Member 'FMatchSettings::bAllowRemoveVehicleFromOtherPlayer' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowFreeCam) == 0x000090, "Member 'FMatchSettings::bAllowFreeCam' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowInfiniteAmmo) == 0x000091, "Member 'FMatchSettings::bAllowInfiniteAmmo' has a wrong offset!");
static_assert(offsetof(FMatchSettings, bAllowInfiniteFuel) == 0x000092, "Member 'FMatchSettings::bAllowInfiniteFuel' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MaxDummies) == 0x000093, "Member 'FMatchSettings::MaxDummies' has a wrong offset!");
static_assert(offsetof(FMatchSettings, VehicleFilter) == 0x000094, "Member 'FMatchSettings::VehicleFilter' has a wrong offset!");
static_assert(offsetof(FMatchSettings, VehicleWhitelist) == 0x000098, "Member 'FMatchSettings::VehicleWhitelist' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MaxBricksPerVehicle) == 0x0000A8, "Member 'FMatchSettings::MaxBricksPerVehicle' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MaxVehicleMass) == 0x0000AC, "Member 'FMatchSettings::MaxVehicleMass' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MaxVehicleSize) == 0x0000B0, "Member 'FMatchSettings::MaxVehicleSize' has a wrong offset!");
static_assert(offsetof(FMatchSettings, MaxVehiclesPerPlayer) == 0x0000B4, "Member 'FMatchSettings::MaxVehiclesPerPlayer' has a wrong offset!");
static_assert(offsetof(FMatchSettings, VehiclePriceFactor) == 0x0000B8, "Member 'FMatchSettings::VehiclePriceFactor' has a wrong offset!");
static_assert(offsetof(FMatchSettings, VehicleRemovalDelay) == 0x0000C0, "Member 'FMatchSettings::VehicleRemovalDelay' has a wrong offset!");

// ScriptStruct BrickRigs.LegacyBrickMaterialReplacement
// 0x0020 (0x0020 - 0x0000)
struct FLegacyBrickMaterialReplacement final
{
public:
	class UBrickMaterial*                         BrickMaterial;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickPattern>              Pattern;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyBrickMaterialReplacement) == 0x000008, "Wrong alignment on FLegacyBrickMaterialReplacement");
static_assert(sizeof(FLegacyBrickMaterialReplacement) == 0x000020, "Wrong size on FLegacyBrickMaterialReplacement");
static_assert(offsetof(FLegacyBrickMaterialReplacement, BrickMaterial) == 0x000000, "Member 'FLegacyBrickMaterialReplacement::BrickMaterial' has a wrong offset!");
static_assert(offsetof(FLegacyBrickMaterialReplacement, Pattern) == 0x000008, "Member 'FLegacyBrickMaterialReplacement::Pattern' has a wrong offset!");
static_assert(offsetof(FLegacyBrickMaterialReplacement, Color) == 0x000010, "Member 'FLegacyBrickMaterialReplacement::Color' has a wrong offset!");

// ScriptStruct BrickRigs.ActuatorBrickEditorParams
// 0x0010 (0x0038 - 0x0028)
struct FActuatorBrickEditorParams final : public FBrickEditorParams
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActuatorBrickEditorParams) == 0x000008, "Wrong alignment on FActuatorBrickEditorParams");
static_assert(sizeof(FActuatorBrickEditorParams) == 0x000038, "Wrong size on FActuatorBrickEditorParams");

// ScriptStruct BrickRigs.AnimNode_ItemBlend
// 0x0130 (0x0140 - 0x0010)
struct alignas(0x10) FAnimNode_ItemBlend final : public FAnimNode_Base
{
public:
	uint8                                         Pad_10[0x70];                                      // 0x0010(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              BasePose;                                          // 0x0080(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              ItemPose;                                          // 0x0090(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftHandBone;                                      // 0x00A0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftElbowBone;                                     // 0x00B0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightHandBone;                                     // 0x00C0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightElbowBone;                                    // 0x00D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HeadBone;                                          // 0x00E0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ItemBone;                                          // 0x00F0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         LeftClavicleBone;                                  // 0x0100(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RightClavicleBone;                                 // 0x0110(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AimCurveExponent;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimTransitionLocationOffset;                       // 0x0124(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AimTransitionRotationOffset;                       // 0x0130(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ItemBlend) == 0x000010, "Wrong alignment on FAnimNode_ItemBlend");
static_assert(sizeof(FAnimNode_ItemBlend) == 0x000140, "Wrong size on FAnimNode_ItemBlend");
static_assert(offsetof(FAnimNode_ItemBlend, BasePose) == 0x000080, "Member 'FAnimNode_ItemBlend::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, ItemPose) == 0x000090, "Member 'FAnimNode_ItemBlend::ItemPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, LeftHandBone) == 0x0000A0, "Member 'FAnimNode_ItemBlend::LeftHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, LeftElbowBone) == 0x0000B0, "Member 'FAnimNode_ItemBlend::LeftElbowBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, RightHandBone) == 0x0000C0, "Member 'FAnimNode_ItemBlend::RightHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, RightElbowBone) == 0x0000D0, "Member 'FAnimNode_ItemBlend::RightElbowBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, HeadBone) == 0x0000E0, "Member 'FAnimNode_ItemBlend::HeadBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, ItemBone) == 0x0000F0, "Member 'FAnimNode_ItemBlend::ItemBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, LeftClavicleBone) == 0x000100, "Member 'FAnimNode_ItemBlend::LeftClavicleBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, RightClavicleBone) == 0x000110, "Member 'FAnimNode_ItemBlend::RightClavicleBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, AimCurveExponent) == 0x000120, "Member 'FAnimNode_ItemBlend::AimCurveExponent' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, AimTransitionLocationOffset) == 0x000124, "Member 'FAnimNode_ItemBlend::AimTransitionLocationOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_ItemBlend, AimTransitionRotationOffset) == 0x000130, "Member 'FAnimNode_ItemBlend::AimTransitionRotationOffset' has a wrong offset!");

// ScriptStruct BrickRigs.InventorySlotID
// 0x0004 (0x0004 - 0x0000)
struct FInventorySlotID final
{
public:
	int32                                         ID;                                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInventorySlotID) == 0x000004, "Wrong alignment on FInventorySlotID");
static_assert(sizeof(FInventorySlotID) == 0x000004, "Wrong size on FInventorySlotID");
static_assert(offsetof(FInventorySlotID, ID) == 0x000000, "Member 'FInventorySlotID::ID' has a wrong offset!");

// ScriptStruct BrickRigs.MoveInventoryItemParams
// 0x0028 (0x0028 - 0x0000)
struct FMoveInventoryItemParams final
{
public:
	TWeakObjectPtr<class UInventoryComponent>     FromInventory;                                     // 0x0000(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventorySlotID                       FromSlotID;                                        // 0x0008(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UInventoryComponent>     ToInventory;                                       // 0x000C(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInventorySlotID                       ToSlotID;                                          // 0x0014(0x0004)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInventoryItem*                         PickedUpItem;                                      // 0x0020(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveInventoryItemParams) == 0x000008, "Wrong alignment on FMoveInventoryItemParams");
static_assert(sizeof(FMoveInventoryItemParams) == 0x000028, "Wrong size on FMoveInventoryItemParams");
static_assert(offsetof(FMoveInventoryItemParams, FromInventory) == 0x000000, "Member 'FMoveInventoryItemParams::FromInventory' has a wrong offset!");
static_assert(offsetof(FMoveInventoryItemParams, FromSlotID) == 0x000008, "Member 'FMoveInventoryItemParams::FromSlotID' has a wrong offset!");
static_assert(offsetof(FMoveInventoryItemParams, ToInventory) == 0x00000C, "Member 'FMoveInventoryItemParams::ToInventory' has a wrong offset!");
static_assert(offsetof(FMoveInventoryItemParams, ToSlotID) == 0x000014, "Member 'FMoveInventoryItemParams::ToSlotID' has a wrong offset!");
static_assert(offsetof(FMoveInventoryItemParams, Amount) == 0x000018, "Member 'FMoveInventoryItemParams::Amount' has a wrong offset!");
static_assert(offsetof(FMoveInventoryItemParams, PickedUpItem) == 0x000020, "Member 'FMoveInventoryItemParams::PickedUpItem' has a wrong offset!");

// ScriptStruct BrickRigs.BoneDamageGroup
// 0x0018 (0x0018 - 0x0000)
struct FBoneDamageGroup final
{
public:
	TArray<class FName>                           BoneNames;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DamageScale;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeChildBones;                                // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneDamageGroup) == 0x000008, "Wrong alignment on FBoneDamageGroup");
static_assert(sizeof(FBoneDamageGroup) == 0x000018, "Wrong size on FBoneDamageGroup");
static_assert(offsetof(FBoneDamageGroup, BoneNames) == 0x000000, "Member 'FBoneDamageGroup::BoneNames' has a wrong offset!");
static_assert(offsetof(FBoneDamageGroup, DamageScale) == 0x000010, "Member 'FBoneDamageGroup::DamageScale' has a wrong offset!");
static_assert(offsetof(FBoneDamageGroup, bIncludeChildBones) == 0x000014, "Member 'FBoneDamageGroup::bIncludeChildBones' has a wrong offset!");

// ScriptStruct BrickRigs.RepBrickConnectionDamageItem
// 0x0034 (0x0040 - 0x000C)
struct alignas(0x08) FRepBrickConnectionDamageItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x34];                                       // 0x000C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepBrickConnectionDamageItem) == 0x000008, "Wrong alignment on FRepBrickConnectionDamageItem");
static_assert(sizeof(FRepBrickConnectionDamageItem) == 0x000040, "Wrong size on FRepBrickConnectionDamageItem");

// ScriptStruct BrickRigs.TrainTrack
// 0x0040 (0x0040 - 0x0000)
struct FTrainTrack final
{
public:
	struct FInterpCurveVector                     PositionCurve;                                     // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RollCurve;                                         // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInterpCurveFloat                      TimeCurve;                                         // 0x0028(0x0018)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainTrack) == 0x000008, "Wrong alignment on FTrainTrack");
static_assert(sizeof(FTrainTrack) == 0x000040, "Wrong size on FTrainTrack");
static_assert(offsetof(FTrainTrack, PositionCurve) == 0x000000, "Member 'FTrainTrack::PositionCurve' has a wrong offset!");
static_assert(offsetof(FTrainTrack, RollCurve) == 0x000018, "Member 'FTrainTrack::RollCurve' has a wrong offset!");
static_assert(offsetof(FTrainTrack, TimeCurve) == 0x000028, "Member 'FTrainTrack::TimeCurve' has a wrong offset!");

// ScriptStruct BrickRigs.RepActuatorState
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FRepActuatorState final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepActuatorState) == 0x000004, "Wrong alignment on FRepActuatorState");
static_assert(sizeof(FRepActuatorState) == 0x000018, "Wrong size on FRepActuatorState");

// ScriptStruct BrickRigs.ActuatorState
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FActuatorState final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActuatorState) == 0x000004, "Wrong alignment on FActuatorState");
static_assert(sizeof(FActuatorState) == 0x000010, "Wrong size on FActuatorState");

// ScriptStruct BrickRigs.VehicleOutputChannel
// 0x0020 (0x0028 - 0x0008)
struct FVehicleOutputChannel : public FBrickStructPropertyInterface
{
public:
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleOutputChannel) == 0x000008, "Wrong alignment on FVehicleOutputChannel");
static_assert(sizeof(FVehicleOutputChannel) == 0x000028, "Wrong size on FVehicleOutputChannel");

// ScriptStruct BrickRigs.SensorOutputChannel
// 0x0010 (0x0038 - 0x0028)
struct FSensorOutputChannel final : public FVehicleOutputChannel
{
public:
	float                                         MinIn;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIn;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinOut;                                            // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOut;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSensorOutputChannel) == 0x000008, "Wrong alignment on FSensorOutputChannel");
static_assert(sizeof(FSensorOutputChannel) == 0x000038, "Wrong size on FSensorOutputChannel");
static_assert(offsetof(FSensorOutputChannel, MinIn) == 0x000028, "Member 'FSensorOutputChannel::MinIn' has a wrong offset!");
static_assert(offsetof(FSensorOutputChannel, MaxIn) == 0x00002C, "Member 'FSensorOutputChannel::MaxIn' has a wrong offset!");
static_assert(offsetof(FSensorOutputChannel, MinOut) == 0x000030, "Member 'FSensorOutputChannel::MinOut' has a wrong offset!");
static_assert(offsetof(FSensorOutputChannel, MaxOut) == 0x000034, "Member 'FSensorOutputChannel::MaxOut' has a wrong offset!");

// ScriptStruct BrickRigs.AmmoInfo
// 0x000C (0x000C - 0x0000)
struct FAmmoInfo final
{
public:
	struct FGameplayTag                           Caliber;                                           // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoType                                     Type;                                              // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAmmoInfo) == 0x000004, "Wrong alignment on FAmmoInfo");
static_assert(sizeof(FAmmoInfo) == 0x00000C, "Wrong size on FAmmoInfo");
static_assert(offsetof(FAmmoInfo, Caliber) == 0x000000, "Member 'FAmmoInfo::Caliber' has a wrong offset!");
static_assert(offsetof(FAmmoInfo, Type) == 0x000008, "Member 'FAmmoInfo::Type' has a wrong offset!");

// ScriptStruct BrickRigs.AnimNode_ViewRotation
// 0x0080 (0x0090 - 0x0010)
struct alignas(0x10) FAnimNode_ViewRotation final : public FAnimNode_Base
{
public:
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseLink                              InPose;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArmsAlpha;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRootPitchAdjustement;                          // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootPitchAdjustmentRate;                           // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         RootBone;                                          // 0x0048(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HeadBone;                                          // 0x0058(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 NeckBoneChain;                                     // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBoneReference>                 ArmBones;                                          // 0x0078(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ViewRotation) == 0x000010, "Wrong alignment on FAnimNode_ViewRotation");
static_assert(sizeof(FAnimNode_ViewRotation) == 0x000090, "Wrong size on FAnimNode_ViewRotation");
static_assert(offsetof(FAnimNode_ViewRotation, InPose) == 0x000020, "Member 'FAnimNode_ViewRotation::InPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, ViewRotation) == 0x000030, "Member 'FAnimNode_ViewRotation::ViewRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, ArmsAlpha) == 0x00003C, "Member 'FAnimNode_ViewRotation::ArmsAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, bUseRootPitchAdjustement) == 0x000040, "Member 'FAnimNode_ViewRotation::bUseRootPitchAdjustement' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, RootPitchAdjustmentRate) == 0x000044, "Member 'FAnimNode_ViewRotation::RootPitchAdjustmentRate' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, RootBone) == 0x000048, "Member 'FAnimNode_ViewRotation::RootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, HeadBone) == 0x000058, "Member 'FAnimNode_ViewRotation::HeadBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, NeckBoneChain) == 0x000068, "Member 'FAnimNode_ViewRotation::NeckBoneChain' has a wrong offset!");
static_assert(offsetof(FAnimNode_ViewRotation, ArmBones) == 0x000078, "Member 'FAnimNode_ViewRotation::ArmBones' has a wrong offset!");

// ScriptStruct BrickRigs.AxleBrickEditorParams
// 0x0010 (0x0038 - 0x0028)
struct FAxleBrickEditorParams final : public FBrickEditorParams
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAxleBrickEditorParams) == 0x000008, "Wrong alignment on FAxleBrickEditorParams");
static_assert(sizeof(FAxleBrickEditorParams) == 0x000038, "Wrong size on FAxleBrickEditorParams");

// ScriptStruct BrickRigs.CameraFadeParams
// 0x001C (0x001C - 0x0000)
struct FCameraFadeParams final
{
public:
	float                                         FadeInTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeHUD;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           FadeColor;                                         // 0x000C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraFadeParams) == 0x000004, "Wrong alignment on FCameraFadeParams");
static_assert(sizeof(FCameraFadeParams) == 0x00001C, "Wrong size on FCameraFadeParams");
static_assert(offsetof(FCameraFadeParams, FadeInTime) == 0x000000, "Member 'FCameraFadeParams::FadeInTime' has a wrong offset!");
static_assert(offsetof(FCameraFadeParams, FadeOutTime) == 0x000004, "Member 'FCameraFadeParams::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FCameraFadeParams, bFadeHUD) == 0x000008, "Member 'FCameraFadeParams::bFadeHUD' has a wrong offset!");
static_assert(offsetof(FCameraFadeParams, FadeColor) == 0x00000C, "Member 'FCameraFadeParams::FadeColor' has a wrong offset!");

// ScriptStruct BrickRigs.BrickCarryInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FBrickCarryInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickCarryInfo) == 0x000004, "Wrong alignment on FBrickCarryInfo");
static_assert(sizeof(FBrickCarryInfo) == 0x000030, "Wrong size on FBrickCarryInfo");

// ScriptStruct BrickRigs.CharacterAnimInstanceProxy
// 0x00D0 (0x0840 - 0x0770)
struct FCharacterAnimInstanceProxy : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x64];                                     // 0x0770(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ViewRotation;                                      // 0x07D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsViewTarget;                                     // 0x07E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConscious;                                      // 0x07E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E2[0x2];                                      // 0x07E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementDirection;                                 // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedRatio;                                    // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchSpeedRatio;                                  // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintRatio;                                       // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyRotationOffset;                                // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving;                                         // 0x0800(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprinting;                                      // 0x0801(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCrouched;                                       // 0x0802(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBodyRotating;                                   // 0x0803(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMovingOrRotating;                               // 0x0804(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWalking;                                        // 0x0805(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0806(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwimming;                                       // 0x0807(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RootTransform;                                     // 0x0810(0x0030)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FCharacterAnimInstanceProxy");
static_assert(sizeof(FCharacterAnimInstanceProxy) == 0x000840, "Wrong size on FCharacterAnimInstanceProxy");
static_assert(offsetof(FCharacterAnimInstanceProxy, ViewRotation) == 0x0007D4, "Member 'FCharacterAnimInstanceProxy::ViewRotation' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsViewTarget) == 0x0007E0, "Member 'FCharacterAnimInstanceProxy::bIsViewTarget' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsConscious) == 0x0007E1, "Member 'FCharacterAnimInstanceProxy::bIsConscious' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, MovementDirection) == 0x0007E4, "Member 'FCharacterAnimInstanceProxy::MovementDirection' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, Speed) == 0x0007E8, "Member 'FCharacterAnimInstanceProxy::Speed' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, MaxSpeed) == 0x0007EC, "Member 'FCharacterAnimInstanceProxy::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, WalkSpeedRatio) == 0x0007F0, "Member 'FCharacterAnimInstanceProxy::WalkSpeedRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, CrouchSpeedRatio) == 0x0007F4, "Member 'FCharacterAnimInstanceProxy::CrouchSpeedRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, SprintRatio) == 0x0007F8, "Member 'FCharacterAnimInstanceProxy::SprintRatio' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, BodyRotationOffset) == 0x0007FC, "Member 'FCharacterAnimInstanceProxy::BodyRotationOffset' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsMoving) == 0x000800, "Member 'FCharacterAnimInstanceProxy::bIsMoving' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsSprinting) == 0x000801, "Member 'FCharacterAnimInstanceProxy::bIsSprinting' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsCrouched) == 0x000802, "Member 'FCharacterAnimInstanceProxy::bIsCrouched' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsBodyRotating) == 0x000803, "Member 'FCharacterAnimInstanceProxy::bIsBodyRotating' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsMovingOrRotating) == 0x000804, "Member 'FCharacterAnimInstanceProxy::bIsMovingOrRotating' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsWalking) == 0x000805, "Member 'FCharacterAnimInstanceProxy::bIsWalking' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsFalling) == 0x000806, "Member 'FCharacterAnimInstanceProxy::bIsFalling' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, bIsSwimming) == 0x000807, "Member 'FCharacterAnimInstanceProxy::bIsSwimming' has a wrong offset!");
static_assert(offsetof(FCharacterAnimInstanceProxy, RootTransform) == 0x000810, "Member 'FCharacterAnimInstanceProxy::RootTransform' has a wrong offset!");

// ScriptStruct BrickRigs.ItemAimParams
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FItemAimParams final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeDistance;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinEyeDistance;                                    // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnification;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemAimParams) == 0x000010, "Wrong alignment on FItemAimParams");
static_assert(sizeof(FItemAimParams) == 0x000040, "Wrong size on FItemAimParams");
static_assert(offsetof(FItemAimParams, EyeDistance) == 0x000030, "Member 'FItemAimParams::EyeDistance' has a wrong offset!");
static_assert(offsetof(FItemAimParams, MinEyeDistance) == 0x000034, "Member 'FItemAimParams::MinEyeDistance' has a wrong offset!");
static_assert(offsetof(FItemAimParams, Magnification) == 0x000038, "Member 'FItemAimParams::Magnification' has a wrong offset!");

// ScriptStruct BrickRigs.BrickCharacterAnimInstanceProxy
// 0x0200 (0x0A40 - 0x0840)
struct FBrickCharacterAnimInstanceProxy final : public FCharacterAnimInstanceProxy
{
public:
	uint8                                         Pad_840[0xD8];                                     // 0x0840(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimRatio;                                          // 0x0918(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDepthOffset;                                 // 0x091C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmsViewRotationAlpha;                             // 0x0920(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemBlendRatio;                                    // 0x0924(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_928[0x8];                                      // 0x0928(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FItemAimParams                         ItemAimParams;                                     // 0x0930(0x0040)(Edit, BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ItemSwayRotation;                                  // 0x0970(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                WalkSwayOffset;                                    // 0x097C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               WalkSwayRotation;                                  // 0x0988(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeaponSupportRatio;                                // 0x0994(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_998[0x8];                                      // 0x0998(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ItemIdlePoseOffset;                                // 0x09A0(0x0030)(Edit, BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemSprintRatio;                                   // 0x09D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWeaponBlocked;                                  // 0x09D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCarryingBrick;                                  // 0x09D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInVehicle;                                      // 0x09D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D7[0x1];                                      // 0x09D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          VehicleIdleSequence;                               // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimInstance*                          VehicleAnimInstance;                               // 0x09E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E8[0x18];                                     // 0x09E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HandsIKAlpha;                                      // 0x0A00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftHandIKOffset;                                  // 0x0A04(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandIKOffset;                                 // 0x0A10(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandsRotationOffset;                               // 0x0A1C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ItemIdleSequence;                                  // 0x0A28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      ItemSprintSequence;                                // 0x0A30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A38[0x8];                                      // 0x0A38(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickCharacterAnimInstanceProxy) == 0x000010, "Wrong alignment on FBrickCharacterAnimInstanceProxy");
static_assert(sizeof(FBrickCharacterAnimInstanceProxy) == 0x000A40, "Wrong size on FBrickCharacterAnimInstanceProxy");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, AimRatio) == 0x000918, "Member 'FBrickCharacterAnimInstanceProxy::AimRatio' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, CameraDepthOffset) == 0x00091C, "Member 'FBrickCharacterAnimInstanceProxy::CameraDepthOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ArmsViewRotationAlpha) == 0x000920, "Member 'FBrickCharacterAnimInstanceProxy::ArmsViewRotationAlpha' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemBlendRatio) == 0x000924, "Member 'FBrickCharacterAnimInstanceProxy::ItemBlendRatio' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemAimParams) == 0x000930, "Member 'FBrickCharacterAnimInstanceProxy::ItemAimParams' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemSwayRotation) == 0x000970, "Member 'FBrickCharacterAnimInstanceProxy::ItemSwayRotation' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, WalkSwayOffset) == 0x00097C, "Member 'FBrickCharacterAnimInstanceProxy::WalkSwayOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, WalkSwayRotation) == 0x000988, "Member 'FBrickCharacterAnimInstanceProxy::WalkSwayRotation' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, WeaponSupportRatio) == 0x000994, "Member 'FBrickCharacterAnimInstanceProxy::WeaponSupportRatio' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemIdlePoseOffset) == 0x0009A0, "Member 'FBrickCharacterAnimInstanceProxy::ItemIdlePoseOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemSprintRatio) == 0x0009D0, "Member 'FBrickCharacterAnimInstanceProxy::ItemSprintRatio' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, bIsWeaponBlocked) == 0x0009D4, "Member 'FBrickCharacterAnimInstanceProxy::bIsWeaponBlocked' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, bIsCarryingBrick) == 0x0009D5, "Member 'FBrickCharacterAnimInstanceProxy::bIsCarryingBrick' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, bIsInVehicle) == 0x0009D6, "Member 'FBrickCharacterAnimInstanceProxy::bIsInVehicle' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, VehicleIdleSequence) == 0x0009D8, "Member 'FBrickCharacterAnimInstanceProxy::VehicleIdleSequence' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, VehicleAnimInstance) == 0x0009E0, "Member 'FBrickCharacterAnimInstanceProxy::VehicleAnimInstance' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, HandsIKAlpha) == 0x000A00, "Member 'FBrickCharacterAnimInstanceProxy::HandsIKAlpha' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, LeftHandIKOffset) == 0x000A04, "Member 'FBrickCharacterAnimInstanceProxy::LeftHandIKOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, RightHandIKOffset) == 0x000A10, "Member 'FBrickCharacterAnimInstanceProxy::RightHandIKOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, HandsRotationOffset) == 0x000A1C, "Member 'FBrickCharacterAnimInstanceProxy::HandsRotationOffset' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemIdleSequence) == 0x000A28, "Member 'FBrickCharacterAnimInstanceProxy::ItemIdleSequence' has a wrong offset!");
static_assert(offsetof(FBrickCharacterAnimInstanceProxy, ItemSprintSequence) == 0x000A30, "Member 'FBrickCharacterAnimInstanceProxy::ItemSprintSequence' has a wrong offset!");

// ScriptStruct BrickRigs.BrickConnectionParams
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x02) FBrickConnectionParams final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickConnectionParams) == 0x000002, "Wrong alignment on FBrickConnectionParams");
static_assert(sizeof(FBrickConnectionParams) == 0x000008, "Wrong size on FBrickConnectionParams");

// ScriptStruct BrickRigs.LegacyBrickEditorObjectClass
// 0x0010 (0x0010 - 0x0000)
struct FLegacyBrickEditorObjectClass final
{
public:
	class FString                                 Suffix;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyBrickEditorObjectClass) == 0x000008, "Wrong alignment on FLegacyBrickEditorObjectClass");
static_assert(sizeof(FLegacyBrickEditorObjectClass) == 0x000010, "Wrong size on FLegacyBrickEditorObjectClass");
static_assert(offsetof(FLegacyBrickEditorObjectClass, Suffix) == 0x000000, "Member 'FLegacyBrickEditorObjectClass::Suffix' has a wrong offset!");

// ScriptStruct BrickRigs.LegacyBrickEditorObjectClassCategory
// 0x0028 (0x0028 - 0x0000)
struct FLegacyBrickEditorObjectClassCategory final
{
public:
	class FString                                 Prefix;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBrickEditorObjectStaticInfo> ReplacementClass;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLegacyBrickEditorObjectClass>  LegacyClasses;                                     // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegacyBrickEditorObjectClassCategory) == 0x000008, "Wrong alignment on FLegacyBrickEditorObjectClassCategory");
static_assert(sizeof(FLegacyBrickEditorObjectClassCategory) == 0x000028, "Wrong size on FLegacyBrickEditorObjectClassCategory");
static_assert(offsetof(FLegacyBrickEditorObjectClassCategory, Prefix) == 0x000000, "Member 'FLegacyBrickEditorObjectClassCategory::Prefix' has a wrong offset!");
static_assert(offsetof(FLegacyBrickEditorObjectClassCategory, ReplacementClass) == 0x000010, "Member 'FLegacyBrickEditorObjectClassCategory::ReplacementClass' has a wrong offset!");
static_assert(offsetof(FLegacyBrickEditorObjectClassCategory, LegacyClasses) == 0x000018, "Member 'FLegacyBrickEditorObjectClassCategory::LegacyClasses' has a wrong offset!");

// ScriptStruct BrickRigs.BrickEditorObjectPtr
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FBrickEditorObjectPtr final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickEditorObjectPtr) == 0x000004, "Wrong alignment on FBrickEditorObjectPtr");
static_assert(sizeof(FBrickEditorObjectPtr) == 0x00000C, "Wrong size on FBrickEditorObjectPtr");

// ScriptStruct BrickRigs.ProjectileParams
// 0x0018 (0x0018 - 0x0000)
struct FProjectileParams final
{
public:
	float                                         InitialSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDamage;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDamage;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropoffStart;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropoffEnd;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileParams) == 0x000004, "Wrong alignment on FProjectileParams");
static_assert(sizeof(FProjectileParams) == 0x000018, "Wrong size on FProjectileParams");
static_assert(offsetof(FProjectileParams, InitialSpeed) == 0x000000, "Member 'FProjectileParams::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FProjectileParams, MaxDamage) == 0x000004, "Member 'FProjectileParams::MaxDamage' has a wrong offset!");
static_assert(offsetof(FProjectileParams, MinDamage) == 0x000008, "Member 'FProjectileParams::MinDamage' has a wrong offset!");
static_assert(offsetof(FProjectileParams, DropoffStart) == 0x00000C, "Member 'FProjectileParams::DropoffStart' has a wrong offset!");
static_assert(offsetof(FProjectileParams, DropoffEnd) == 0x000010, "Member 'FProjectileParams::DropoffEnd' has a wrong offset!");
static_assert(offsetof(FProjectileParams, MaxRange) == 0x000014, "Member 'FProjectileParams::MaxRange' has a wrong offset!");

// ScriptStruct BrickRigs.BrickPropertyReflectionFilter
// 0x0020 (0x0020 - 0x0000)
struct FBrickPropertyReflectionFilter final
{
public:
	struct FGameplayTagContainer                  Tags;                                              // 0x0000(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBrickPropertyReflectionFilter) == 0x000008, "Wrong alignment on FBrickPropertyReflectionFilter");
static_assert(sizeof(FBrickPropertyReflectionFilter) == 0x000020, "Wrong size on FBrickPropertyReflectionFilter");
static_assert(offsetof(FBrickPropertyReflectionFilter, Tags) == 0x000000, "Member 'FBrickPropertyReflectionFilter::Tags' has a wrong offset!");

// ScriptStruct BrickRigs.TrainTrackSplineMeshInfo
// 0x0018 (0x0018 - 0x0000)
struct FTrainTrackSplineMeshInfo final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RailOffset;                                        // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainTrackSplineMeshInfo) == 0x000008, "Wrong alignment on FTrainTrackSplineMeshInfo");
static_assert(sizeof(FTrainTrackSplineMeshInfo) == 0x000018, "Wrong size on FTrainTrackSplineMeshInfo");
static_assert(offsetof(FTrainTrackSplineMeshInfo, StaticMesh) == 0x000000, "Member 'FTrainTrackSplineMeshInfo::StaticMesh' has a wrong offset!");
static_assert(offsetof(FTrainTrackSplineMeshInfo, RailOffset) == 0x000008, "Member 'FTrainTrackSplineMeshInfo::RailOffset' has a wrong offset!");

// ScriptStruct BrickRigs.TrainSpawnInfo
// 0x0010 (0x0010 - 0x0000)
struct FTrainSpawnInfo final
{
public:
	int32                                         TrackIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATrain>                     TrainClass;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainSpawnInfo) == 0x000008, "Wrong alignment on FTrainSpawnInfo");
static_assert(sizeof(FTrainSpawnInfo) == 0x000010, "Wrong size on FTrainSpawnInfo");
static_assert(offsetof(FTrainSpawnInfo, TrackIndex) == 0x000000, "Member 'FTrainSpawnInfo::TrackIndex' has a wrong offset!");
static_assert(offsetof(FTrainSpawnInfo, TrainClass) == 0x000008, "Member 'FTrainSpawnInfo::TrainClass' has a wrong offset!");

// ScriptStruct BrickRigs.CharacterDamageInfo
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FCharacterDamageInfo final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDamageInfo) == 0x000004, "Wrong alignment on FCharacterDamageInfo");
static_assert(sizeof(FCharacterDamageInfo) == 0x00000C, "Wrong size on FCharacterDamageInfo");

// ScriptStruct BrickRigs.WalkSwayParams
// 0x0080 (0x0080 - 0x0000)
struct FWalkSwayParams final
{
public:
	struct FVector                                OffsetDelay;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetAmplitude;                                   // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationDelay;                                     // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotationAmplitude;                                 // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ForwardOffset;                                     // 0x0030(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StrafeOffset;                                      // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ForwardRotation;                                   // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               StrafeRotation;                                    // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OffsetInterpSpeed;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationInterpSpeed;                               // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AimOffsetScale;                                    // 0x0068(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AimRotationScale;                                  // 0x0074(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWalkSwayParams) == 0x000004, "Wrong alignment on FWalkSwayParams");
static_assert(sizeof(FWalkSwayParams) == 0x000080, "Wrong size on FWalkSwayParams");
static_assert(offsetof(FWalkSwayParams, OffsetDelay) == 0x000000, "Member 'FWalkSwayParams::OffsetDelay' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, OffsetAmplitude) == 0x00000C, "Member 'FWalkSwayParams::OffsetAmplitude' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, RotationDelay) == 0x000018, "Member 'FWalkSwayParams::RotationDelay' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, RotationAmplitude) == 0x000024, "Member 'FWalkSwayParams::RotationAmplitude' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, ForwardOffset) == 0x000030, "Member 'FWalkSwayParams::ForwardOffset' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, StrafeOffset) == 0x00003C, "Member 'FWalkSwayParams::StrafeOffset' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, ForwardRotation) == 0x000048, "Member 'FWalkSwayParams::ForwardRotation' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, StrafeRotation) == 0x000054, "Member 'FWalkSwayParams::StrafeRotation' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, OffsetInterpSpeed) == 0x000060, "Member 'FWalkSwayParams::OffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, RotationInterpSpeed) == 0x000064, "Member 'FWalkSwayParams::RotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, AimOffsetScale) == 0x000068, "Member 'FWalkSwayParams::AimOffsetScale' has a wrong offset!");
static_assert(offsetof(FWalkSwayParams, AimRotationScale) == 0x000074, "Member 'FWalkSwayParams::AimRotationScale' has a wrong offset!");

// ScriptStruct BrickRigs.ClientDamageInfo
// 0x000C (0x000C - 0x0000)
struct FClientDamageInfo final
{
public:
	ETeamAttitude                                 TeamAttitude;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHeadshot;                                       // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKillshot;                                       // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientDamageInfo) == 0x000004, "Wrong alignment on FClientDamageInfo");
static_assert(sizeof(FClientDamageInfo) == 0x00000C, "Wrong size on FClientDamageInfo");
static_assert(offsetof(FClientDamageInfo, TeamAttitude) == 0x000000, "Member 'FClientDamageInfo::TeamAttitude' has a wrong offset!");
static_assert(offsetof(FClientDamageInfo, Damage) == 0x000004, "Member 'FClientDamageInfo::Damage' has a wrong offset!");
static_assert(offsetof(FClientDamageInfo, bIsHeadshot) == 0x000008, "Member 'FClientDamageInfo::bIsHeadshot' has a wrong offset!");
static_assert(offsetof(FClientDamageInfo, bIsKillshot) == 0x000009, "Member 'FClientDamageInfo::bIsKillshot' has a wrong offset!");

// ScriptStruct BrickRigs.DestructibleInstance
// 0x0040 (0x0040 - 0x0000)
struct FDestructibleInstance final
{
public:
	struct FTransform                             InstanceTransform;                                 // 0x0000(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleInstance) == 0x000010, "Wrong alignment on FDestructibleInstance");
static_assert(sizeof(FDestructibleInstance) == 0x000040, "Wrong size on FDestructibleInstance");
static_assert(offsetof(FDestructibleInstance, InstanceTransform) == 0x000000, "Member 'FDestructibleInstance::InstanceTransform' has a wrong offset!");

// ScriptStruct BrickRigs.DestructibleInstanceArray
// 0x0038 (0x0038 - 0x0000)
struct FDestructibleInstanceArray final
{
public:
	class UDestructibleInstanceTemplate*          Template;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             MaterialOverrides;                                 // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDestructibleInstance>          Instances;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleInstanceArray) == 0x000008, "Wrong alignment on FDestructibleInstanceArray");
static_assert(sizeof(FDestructibleInstanceArray) == 0x000038, "Wrong size on FDestructibleInstanceArray");
static_assert(offsetof(FDestructibleInstanceArray, Template) == 0x000000, "Member 'FDestructibleInstanceArray::Template' has a wrong offset!");
static_assert(offsetof(FDestructibleInstanceArray, MaterialOverrides) == 0x000008, "Member 'FDestructibleInstanceArray::MaterialOverrides' has a wrong offset!");
static_assert(offsetof(FDestructibleInstanceArray, Instances) == 0x000028, "Member 'FDestructibleInstanceArray::Instances' has a wrong offset!");

// ScriptStruct BrickRigs.DestructibleInstanceDamageItem
// 0x0010 (0x001C - 0x000C)
struct FDestructibleInstanceDamageItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x10];                                       // 0x000C(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleInstanceDamageItem) == 0x000004, "Wrong alignment on FDestructibleInstanceDamageItem");
static_assert(sizeof(FDestructibleInstanceDamageItem) == 0x00001C, "Wrong size on FDestructibleInstanceDamageItem");

// ScriptStruct BrickRigs.DestructibleInstanceDamageArray
// 0x0018 (0x0120 - 0x0108)
struct FDestructibleInstanceDamageArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDestructibleInstanceDamageItem> Items;                                            // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructibleInstanceDamageArray) == 0x000008, "Wrong alignment on FDestructibleInstanceDamageArray");
static_assert(sizeof(FDestructibleInstanceDamageArray) == 0x000120, "Wrong size on FDestructibleInstanceDamageArray");
static_assert(offsetof(FDestructibleInstanceDamageArray, Items) == 0x000110, "Member 'FDestructibleInstanceDamageArray::Items' has a wrong offset!");

// ScriptStruct BrickRigs.RepBrickMovement
// 0x0054 (0x0060 - 0x000C)
struct alignas(0x10) FRepBrickMovement final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x54];                                       // 0x000C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepBrickMovement) == 0x000010, "Wrong alignment on FRepBrickMovement");
static_assert(sizeof(FRepBrickMovement) == 0x000060, "Wrong size on FRepBrickMovement");

// ScriptStruct BrickRigs.RepVehicleMovement
// 0x0018 (0x0120 - 0x0108)
struct FRepVehicleMovement final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepBrickMovement>              Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepVehicleMovement) == 0x000008, "Wrong alignment on FRepVehicleMovement");
static_assert(sizeof(FRepVehicleMovement) == 0x000120, "Wrong size on FRepVehicleMovement");
static_assert(offsetof(FRepVehicleMovement, Items) == 0x000110, "Member 'FRepVehicleMovement::Items' has a wrong offset!");

// ScriptStruct BrickRigs.DistanceConstraint
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FDistanceConstraint final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringStiffness;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpringDampening;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingForce;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvMassScale0;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvMassScale1;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x8C];                                      // 0x0024(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceConstraint) == 0x000010, "Wrong alignment on FDistanceConstraint");
static_assert(sizeof(FDistanceConstraint) == 0x0000B0, "Wrong size on FDistanceConstraint");
static_assert(offsetof(FDistanceConstraint, MinDistance) == 0x000008, "Member 'FDistanceConstraint::MinDistance' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, MaxDistance) == 0x00000C, "Member 'FDistanceConstraint::MaxDistance' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, SpringStiffness) == 0x000010, "Member 'FDistanceConstraint::SpringStiffness' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, SpringDampening) == 0x000014, "Member 'FDistanceConstraint::SpringDampening' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, BreakingForce) == 0x000018, "Member 'FDistanceConstraint::BreakingForce' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, InvMassScale0) == 0x00001C, "Member 'FDistanceConstraint::InvMassScale0' has a wrong offset!");
static_assert(offsetof(FDistanceConstraint, InvMassScale1) == 0x000020, "Member 'FDistanceConstraint::InvMassScale1' has a wrong offset!");

// ScriptStruct BrickRigs.RestartTransformVersion
// 0x0001 (0x0001 - 0x0000)
struct FRestartTransformVersion final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestartTransformVersion) == 0x000001, "Wrong alignment on FRestartTransformVersion");
static_assert(sizeof(FRestartTransformVersion) == 0x000001, "Wrong size on FRestartTransformVersion");

// ScriptStruct BrickRigs.PawnRestartTransform
// 0x001C (0x001C - 0x0000)
struct FPawnRestartTransform final
{
public:
	struct FRestartTransformVersion               ComparisonIndex;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 Location;                                          // 0x0004(0x000C)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPawnRestartTransform) == 0x000004, "Wrong alignment on FPawnRestartTransform");
static_assert(sizeof(FPawnRestartTransform) == 0x00001C, "Wrong size on FPawnRestartTransform");
static_assert(offsetof(FPawnRestartTransform, ComparisonIndex) == 0x000000, "Member 'FPawnRestartTransform::ComparisonIndex' has a wrong offset!");
static_assert(offsetof(FPawnRestartTransform, Location) == 0x000004, "Member 'FPawnRestartTransform::Location' has a wrong offset!");
static_assert(offsetof(FPawnRestartTransform, Rotation) == 0x000010, "Member 'FPawnRestartTransform::Rotation' has a wrong offset!");

// ScriptStruct BrickRigs.PlayerSpawnRequest
// 0x0118 (0x0118 - 0x0000)
struct FPlayerSpawnRequest final
{
public:
	EPlayerSpawnType                              Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPawnRestartTransform                  SpawnTransform;                                    // 0x0004(0x001C)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  SpawnPoint;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUGCFileInfo                           VehicleFileInfo;                                   // 0x0028(0x00E8)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EPlayerVehicleSpawnType                       VehicleSpawnType;                                  // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerVehicleSpawnInvincibility              VehicleInvincibility;                              // 0x0111(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSpawnRequest) == 0x000008, "Wrong alignment on FPlayerSpawnRequest");
static_assert(sizeof(FPlayerSpawnRequest) == 0x000118, "Wrong size on FPlayerSpawnRequest");
static_assert(offsetof(FPlayerSpawnRequest, Type) == 0x000000, "Member 'FPlayerSpawnRequest::Type' has a wrong offset!");
static_assert(offsetof(FPlayerSpawnRequest, SpawnTransform) == 0x000004, "Member 'FPlayerSpawnRequest::SpawnTransform' has a wrong offset!");
static_assert(offsetof(FPlayerSpawnRequest, SpawnPoint) == 0x000020, "Member 'FPlayerSpawnRequest::SpawnPoint' has a wrong offset!");
static_assert(offsetof(FPlayerSpawnRequest, VehicleFileInfo) == 0x000028, "Member 'FPlayerSpawnRequest::VehicleFileInfo' has a wrong offset!");
static_assert(offsetof(FPlayerSpawnRequest, VehicleSpawnType) == 0x000110, "Member 'FPlayerSpawnRequest::VehicleSpawnType' has a wrong offset!");
static_assert(offsetof(FPlayerSpawnRequest, VehicleInvincibility) == 0x000111, "Member 'FPlayerSpawnRequest::VehicleInvincibility' has a wrong offset!");

// ScriptStruct BrickRigs.DragRaceTime
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDragRaceTime final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragRaceTime) == 0x000004, "Wrong alignment on FDragRaceTime");
static_assert(sizeof(FDragRaceTime) == 0x000008, "Wrong size on FDragRaceTime");

// ScriptStruct BrickRigs.ElevatorState
// 0x000C (0x000C - 0x0000)
struct FElevatorState final
{
public:
	EElevatorDirection                            Direction;                                         // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FElevatorState) == 0x000004, "Wrong alignment on FElevatorState");
static_assert(sizeof(FElevatorState) == 0x00000C, "Wrong size on FElevatorState");
static_assert(offsetof(FElevatorState, Direction) == 0x000000, "Member 'FElevatorState::Direction' has a wrong offset!");
static_assert(offsetof(FElevatorState, Height) == 0x000004, "Member 'FElevatorState::Height' has a wrong offset!");
static_assert(offsetof(FElevatorState, Speed) == 0x000008, "Member 'FElevatorState::Speed' has a wrong offset!");

// ScriptStruct BrickRigs.ItemAnimInstanceProxy
// 0x0020 (0x0790 - 0x0770)
struct FItemAnimInstanceProxy : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x20];                                     // 0x0770(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemAnimInstanceProxy) == 0x000010, "Wrong alignment on FItemAnimInstanceProxy");
static_assert(sizeof(FItemAnimInstanceProxy) == 0x000790, "Wrong size on FItemAnimInstanceProxy");

// ScriptStruct BrickRigs.FirearmAnimInstanceProxy
// 0x0080 (0x0810 - 0x0790)
struct FFirearmAnimInstanceProxy final : public FItemAnimInstanceProxy
{
public:
	uint8                                         Pad_790[0x80];                                     // 0x0790(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFirearmAnimInstanceProxy) == 0x000010, "Wrong alignment on FFirearmAnimInstanceProxy");
static_assert(sizeof(FFirearmAnimInstanceProxy) == 0x000810, "Wrong size on FFirearmAnimInstanceProxy");

// ScriptStruct BrickRigs.MuzzleEffect
// 0x0050 (0x0050 - 0x0000)
struct FMuzzleEffect final
{
public:
	TSoftObjectPtr<class UParticleSystem>         Emitter;                                           // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMuzzleEffect) == 0x000008, "Wrong alignment on FMuzzleEffect");
static_assert(sizeof(FMuzzleEffect) == 0x000050, "Wrong size on FMuzzleEffect");
static_assert(offsetof(FMuzzleEffect, Emitter) == 0x000000, "Member 'FMuzzleEffect::Emitter' has a wrong offset!");
static_assert(offsetof(FMuzzleEffect, Sound) == 0x000028, "Member 'FMuzzleEffect::Sound' has a wrong offset!");

// ScriptStruct BrickRigs.FirearmProperties
// 0x0090 (0x0090 - 0x0000)
struct FFirearmProperties final
{
public:
	int32                                         AmmoCapacity;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Caliber;                                           // 0x0004(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAmmoType                                     DefaultAmmoType;                                   // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABrickProjectile>           ProjectileClass;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectileParams                      ProjectileParams;                                  // 0x0018(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NumProjectilesPerShot;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpreadRadius;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoltCycleTime;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasSemiMode : 1;                                  // 0x003C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHasAutoMode : 1;                                  // 0x003C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BurstRounds;                                       // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMuzzleEffect                          MuzzleEffect;                                      // 0x0040(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFirearmProperties) == 0x000008, "Wrong alignment on FFirearmProperties");
static_assert(sizeof(FFirearmProperties) == 0x000090, "Wrong size on FFirearmProperties");
static_assert(offsetof(FFirearmProperties, AmmoCapacity) == 0x000000, "Member 'FFirearmProperties::AmmoCapacity' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, Caliber) == 0x000004, "Member 'FFirearmProperties::Caliber' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, DefaultAmmoType) == 0x00000C, "Member 'FFirearmProperties::DefaultAmmoType' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, ProjectileClass) == 0x000010, "Member 'FFirearmProperties::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, ProjectileParams) == 0x000018, "Member 'FFirearmProperties::ProjectileParams' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, NumProjectilesPerShot) == 0x000030, "Member 'FFirearmProperties::NumProjectilesPerShot' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, SpreadRadius) == 0x000034, "Member 'FFirearmProperties::SpreadRadius' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, BoltCycleTime) == 0x000038, "Member 'FFirearmProperties::BoltCycleTime' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, BurstRounds) == 0x00003D, "Member 'FFirearmProperties::BurstRounds' has a wrong offset!");
static_assert(offsetof(FFirearmProperties, MuzzleEffect) == 0x000040, "Member 'FFirearmProperties::MuzzleEffect' has a wrong offset!");

// ScriptStruct BrickRigs.FirearmState
// 0x0006 (0x0006 - 0x0000)
struct alignas(0x02) FFirearmState final
{
public:
	EChamberState ChamberState;   // 0x0000 (1 byte)
	SDK::EAmmoType AmmoType;               // 0x0001 (1 byte)
	uint16 RoundsFired;           // 0x0002 (2 bytes)
	bool bIsAutoFiring;           // 0x0004 (1 byte)
	uint8 Pad_0;
};
static_assert(alignof(FFirearmState) == 0x000002, "Wrong alignment on FFirearmState");
static_assert(sizeof(FFirearmState) == 0x000006, "Wrong size on FFirearmState");

// ScriptStruct BrickRigs.FireExtinguisherProperties
// 0x0068 (0x0068 - 0x0000)
struct FFireExtinguisherProperties final
{
public:
	TSoftObjectPtr<class UParticleSystem>         Emitter;                                           // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Sound;                                             // 0x0028(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExtinguishSound;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinguishRadius;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinguishDistance;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtinguishProbability;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFireExtinguisherProperties) == 0x000008, "Wrong alignment on FFireExtinguisherProperties");
static_assert(sizeof(FFireExtinguisherProperties) == 0x000068, "Wrong size on FFireExtinguisherProperties");
static_assert(offsetof(FFireExtinguisherProperties, Emitter) == 0x000000, "Member 'FFireExtinguisherProperties::Emitter' has a wrong offset!");
static_assert(offsetof(FFireExtinguisherProperties, Sound) == 0x000028, "Member 'FFireExtinguisherProperties::Sound' has a wrong offset!");
static_assert(offsetof(FFireExtinguisherProperties, ExtinguishSound) == 0x000050, "Member 'FFireExtinguisherProperties::ExtinguishSound' has a wrong offset!");
static_assert(offsetof(FFireExtinguisherProperties, ExtinguishRadius) == 0x000058, "Member 'FFireExtinguisherProperties::ExtinguishRadius' has a wrong offset!");
static_assert(offsetof(FFireExtinguisherProperties, ExtinguishDistance) == 0x00005C, "Member 'FFireExtinguisherProperties::ExtinguishDistance' has a wrong offset!");
static_assert(offsetof(FFireExtinguisherProperties, ExtinguishProbability) == 0x000060, "Member 'FFireExtinguisherProperties::ExtinguishProbability' has a wrong offset!");

// ScriptStruct BrickRigs.FluTeamIdStatics
// 0x0001 (0x0001 - 0x0000)
struct FFluTeamIdStatics final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFluTeamIdStatics) == 0x000001, "Wrong alignment on FFluTeamIdStatics");
static_assert(sizeof(FFluTeamIdStatics) == 0x000001, "Wrong size on FFluTeamIdStatics");

// ScriptStruct BrickRigs.FuelTankParams
// 0x0010 (0x0010 - 0x0000)
struct FFuelTankParams final
{
public:
	float                                         FuelCapacity;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UExplosiveMaterial>         FuelType;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFuelTankParams) == 0x000008, "Wrong alignment on FFuelTankParams");
static_assert(sizeof(FFuelTankParams) == 0x000010, "Wrong size on FFuelTankParams");
static_assert(offsetof(FFuelTankParams, FuelCapacity) == 0x000000, "Member 'FFuelTankParams::FuelCapacity' has a wrong offset!");
static_assert(offsetof(FFuelTankParams, FuelType) == 0x000008, "Member 'FFuelTankParams::FuelType' has a wrong offset!");

// ScriptStruct BrickRigs.GrenadeAnimInstanceProxy
// 0x0050 (0x07E0 - 0x0790)
struct FGrenadeAnimInstanceProxy final : public FItemAnimInstanceProxy
{
public:
	uint8                                         Pad_790[0x50];                                     // 0x0790(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrenadeAnimInstanceProxy) == 0x000010, "Wrong alignment on FGrenadeAnimInstanceProxy");
static_assert(sizeof(FGrenadeAnimInstanceProxy) == 0x0007E0, "Wrong size on FGrenadeAnimInstanceProxy");

// ScriptStruct BrickRigs.DefaultInputMapping
// 0x0028 (0x0028 - 0x0000)
struct FDefaultInputMapping final
{
public:
	uint8                                         bShift : 1;                                        // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCmd : 1;                                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDefaultInputMapping) == 0x000008, "Wrong alignment on FDefaultInputMapping");
static_assert(sizeof(FDefaultInputMapping) == 0x000028, "Wrong size on FDefaultInputMapping");
static_assert(offsetof(FDefaultInputMapping, Key) == 0x000008, "Member 'FDefaultInputMapping::Key' has a wrong offset!");
static_assert(offsetof(FDefaultInputMapping, Scale) == 0x000020, "Member 'FDefaultInputMapping::Scale' has a wrong offset!");

// ScriptStruct BrickRigs.InputTableRow
// 0x00D8 (0x00E0 - 0x0008)
struct FInputTableRow final : public FTableRowBase
{
public:
	struct FDisplayInfo                           DisplayInfo;                                       // 0x0008(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   PrimaryActionName;                                 // 0x0030(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   SecondaryActionName;                               // 0x0048(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   PrimaryActionDescription;                          // 0x0060(0x0018)(Edit, NativeAccessSpecifierPrivate)
	class FText                                   SecondaryActionDescription;                        // 0x0078(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         ActionIndex;                                       // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputRowType                                 Type;                                              // 0x0091(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ContextTags;                                       // 0x0098(0x0020)(Edit, NativeAccessSpecifierPublic)
	class UObject*                                InputMenuCategory;                                 // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InputContextCategory;                              // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInQuickAccess;                                // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInEditorTopBar;                               // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumeInput;                                     // 0x00CA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDefaultInputMapping>           DefaultMappings;                                   // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputTableRow) == 0x000008, "Wrong alignment on FInputTableRow");
static_assert(sizeof(FInputTableRow) == 0x0000E0, "Wrong size on FInputTableRow");
static_assert(offsetof(FInputTableRow, DisplayInfo) == 0x000008, "Member 'FInputTableRow::DisplayInfo' has a wrong offset!");
static_assert(offsetof(FInputTableRow, PrimaryActionName) == 0x000030, "Member 'FInputTableRow::PrimaryActionName' has a wrong offset!");
static_assert(offsetof(FInputTableRow, SecondaryActionName) == 0x000048, "Member 'FInputTableRow::SecondaryActionName' has a wrong offset!");
static_assert(offsetof(FInputTableRow, PrimaryActionDescription) == 0x000060, "Member 'FInputTableRow::PrimaryActionDescription' has a wrong offset!");
static_assert(offsetof(FInputTableRow, SecondaryActionDescription) == 0x000078, "Member 'FInputTableRow::SecondaryActionDescription' has a wrong offset!");
static_assert(offsetof(FInputTableRow, ActionIndex) == 0x000090, "Member 'FInputTableRow::ActionIndex' has a wrong offset!");
static_assert(offsetof(FInputTableRow, Type) == 0x000091, "Member 'FInputTableRow::Type' has a wrong offset!");
static_assert(offsetof(FInputTableRow, ContextTags) == 0x000098, "Member 'FInputTableRow::ContextTags' has a wrong offset!");
static_assert(offsetof(FInputTableRow, InputMenuCategory) == 0x0000B8, "Member 'FInputTableRow::InputMenuCategory' has a wrong offset!");
static_assert(offsetof(FInputTableRow, InputContextCategory) == 0x0000C0, "Member 'FInputTableRow::InputContextCategory' has a wrong offset!");
static_assert(offsetof(FInputTableRow, bShowInQuickAccess) == 0x0000C8, "Member 'FInputTableRow::bShowInQuickAccess' has a wrong offset!");
static_assert(offsetof(FInputTableRow, bShowInEditorTopBar) == 0x0000C9, "Member 'FInputTableRow::bShowInEditorTopBar' has a wrong offset!");
static_assert(offsetof(FInputTableRow, bConsumeInput) == 0x0000CA, "Member 'FInputTableRow::bConsumeInput' has a wrong offset!");
static_assert(offsetof(FInputTableRow, DefaultMappings) == 0x0000D0, "Member 'FInputTableRow::DefaultMappings' has a wrong offset!");

// ScriptStruct BrickRigs.InventoryItemRef
// 0x0010 (0x0010 - 0x0000)
struct FInventoryItemRef final
{
public:
	class AInventoryItem*                         Item;                                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 ItemClass;                                         // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInventoryItemRef) == 0x000008, "Wrong alignment on FInventoryItemRef");
static_assert(sizeof(FInventoryItemRef) == 0x000010, "Wrong size on FInventoryItemRef");
static_assert(offsetof(FInventoryItemRef, Item) == 0x000000, "Member 'FInventoryItemRef::Item' has a wrong offset!");
static_assert(offsetof(FInventoryItemRef, ItemClass) == 0x000008, "Member 'FInventoryItemRef::ItemClass' has a wrong offset!");

// ScriptStruct BrickRigs.InventorySlot
// 0x0024 (0x0030 - 0x000C)
struct FInventorySlot final : public FFastArraySerializerItem
{
public:
	struct FInventorySlotID                       SlotID;                                            // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInventoryItemRef                      ItemRef;                                           // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AInventoryItem*                         LocalItem;                                         // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Amount;                                            // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventorySlot) == 0x000008, "Wrong alignment on FInventorySlot");
static_assert(sizeof(FInventorySlot) == 0x000030, "Wrong size on FInventorySlot");
static_assert(offsetof(FInventorySlot, SlotID) == 0x00000C, "Member 'FInventorySlot::SlotID' has a wrong offset!");
static_assert(offsetof(FInventorySlot, ItemRef) == 0x000010, "Member 'FInventorySlot::ItemRef' has a wrong offset!");
static_assert(offsetof(FInventorySlot, LocalItem) == 0x000020, "Member 'FInventorySlot::LocalItem' has a wrong offset!");
static_assert(offsetof(FInventorySlot, Amount) == 0x000028, "Member 'FInventorySlot::Amount' has a wrong offset!");

// ScriptStruct BrickRigs.Inventory
// 0x0018 (0x0120 - 0x0108)
struct FInventory final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInventorySlot>                 Items;                                             // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventory) == 0x000008, "Wrong alignment on FInventory");
static_assert(sizeof(FInventory) == 0x000120, "Wrong size on FInventory");
static_assert(offsetof(FInventory, Items) == 0x000110, "Member 'FInventory::Items' has a wrong offset!");

// ScriptStruct BrickRigs.InventorySpecialSlot
// 0x0040 (0x0040 - 0x0000)
struct FInventorySpecialSlot final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0018(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FInventorySpecialSlot) == 0x000008, "Wrong alignment on FInventorySpecialSlot");
static_assert(sizeof(FInventorySpecialSlot) == 0x000040, "Wrong size on FInventorySpecialSlot");
static_assert(offsetof(FInventorySpecialSlot, DisplayName) == 0x000000, "Member 'FInventorySpecialSlot::DisplayName' has a wrong offset!");
static_assert(offsetof(FInventorySpecialSlot, ItemTags) == 0x000018, "Member 'FInventorySpecialSlot::ItemTags' has a wrong offset!");
static_assert(offsetof(FInventorySpecialSlot, SocketName) == 0x000038, "Member 'FInventorySpecialSlot::SocketName' has a wrong offset!");

// ScriptStruct BrickRigs.InventoryProperties
// 0x0060 (0x0060 - 0x0000)
struct FInventoryProperties final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              ItemAddedSound;                                    // 0x0018(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumWildcardSlots;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInventorySpecialSlot>          SpecialSlots;                                      // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxAmountPerSlot;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryProperties) == 0x000008, "Wrong alignment on FInventoryProperties");
static_assert(sizeof(FInventoryProperties) == 0x000060, "Wrong size on FInventoryProperties");
static_assert(offsetof(FInventoryProperties, DisplayName) == 0x000000, "Member 'FInventoryProperties::DisplayName' has a wrong offset!");
static_assert(offsetof(FInventoryProperties, ItemAddedSound) == 0x000018, "Member 'FInventoryProperties::ItemAddedSound' has a wrong offset!");
static_assert(offsetof(FInventoryProperties, NumWildcardSlots) == 0x000040, "Member 'FInventoryProperties::NumWildcardSlots' has a wrong offset!");
static_assert(offsetof(FInventoryProperties, SpecialSlots) == 0x000048, "Member 'FInventoryProperties::SpecialSlots' has a wrong offset!");
static_assert(offsetof(FInventoryProperties, MaxAmountPerSlot) == 0x000058, "Member 'FInventoryProperties::MaxAmountPerSlot' has a wrong offset!");

// ScriptStruct BrickRigs.InventoryLoadoutSlot
// 0x0020 (0x0020 - 0x0000)
struct FInventoryLoadoutSlot final
{
public:
	class UClass*                                 ItemClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         Attachments;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryLoadoutSlot) == 0x000008, "Wrong alignment on FInventoryLoadoutSlot");
static_assert(sizeof(FInventoryLoadoutSlot) == 0x000020, "Wrong size on FInventoryLoadoutSlot");
static_assert(offsetof(FInventoryLoadoutSlot, ItemClass) == 0x000000, "Member 'FInventoryLoadoutSlot::ItemClass' has a wrong offset!");
static_assert(offsetof(FInventoryLoadoutSlot, Amount) == 0x000008, "Member 'FInventoryLoadoutSlot::Amount' has a wrong offset!");
static_assert(offsetof(FInventoryLoadoutSlot, Attachments) == 0x000010, "Member 'FInventoryLoadoutSlot::Attachments' has a wrong offset!");

// ScriptStruct BrickRigs.InventoryLoadout
// 0x0010 (0x0010 - 0x0000)
struct FInventoryLoadout final
{
public:
	TArray<struct FInventoryLoadoutSlot>          Slots;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryLoadout) == 0x000008, "Wrong alignment on FInventoryLoadout");
static_assert(sizeof(FInventoryLoadout) == 0x000010, "Wrong size on FInventoryLoadout");
static_assert(offsetof(FInventoryLoadout, Slots) == 0x000000, "Member 'FInventoryLoadout::Slots' has a wrong offset!");

// ScriptStruct BrickRigs.ItemAnimation
// 0x00C8 (0x00C8 - 0x0000)
struct FItemAnimation
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CharacterMontage;                                  // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ItemMontage;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FoleySoundPtr;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       CharacterSequence;                                 // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       ItemSequence;                                      // 0x0068(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              FoleySound;                                        // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemAnimation) == 0x000008, "Wrong alignment on FItemAnimation");
static_assert(sizeof(FItemAnimation) == 0x0000C8, "Wrong size on FItemAnimation");
static_assert(offsetof(FItemAnimation, CharacterMontage) == 0x000028, "Member 'FItemAnimation::CharacterMontage' has a wrong offset!");
static_assert(offsetof(FItemAnimation, ItemMontage) == 0x000030, "Member 'FItemAnimation::ItemMontage' has a wrong offset!");
static_assert(offsetof(FItemAnimation, FoleySoundPtr) == 0x000038, "Member 'FItemAnimation::FoleySoundPtr' has a wrong offset!");
static_assert(offsetof(FItemAnimation, CharacterSequence) == 0x000040, "Member 'FItemAnimation::CharacterSequence' has a wrong offset!");
static_assert(offsetof(FItemAnimation, ItemSequence) == 0x000068, "Member 'FItemAnimation::ItemSequence' has a wrong offset!");
static_assert(offsetof(FItemAnimation, FoleySound) == 0x000090, "Member 'FItemAnimation::FoleySound' has a wrong offset!");
static_assert(offsetof(FItemAnimation, Length) == 0x0000B8, "Member 'FItemAnimation::Length' has a wrong offset!");
static_assert(offsetof(FItemAnimation, PlayRate) == 0x0000BC, "Member 'FItemAnimation::PlayRate' has a wrong offset!");
static_assert(offsetof(FItemAnimation, BlendInTime) == 0x0000C0, "Member 'FItemAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(FItemAnimation, BlendOutTime) == 0x0000C4, "Member 'FItemAnimation::BlendOutTime' has a wrong offset!");

// ScriptStruct BrickRigs.ExtinguishAnimation
// 0x0010 (0x00D8 - 0x00C8)
struct FExtinguishAnimation final : public FItemAnimation
{
public:
	float                                         StartExtinguishTime;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             StopExtinguishSound;                               // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExtinguishAnimation) == 0x000008, "Wrong alignment on FExtinguishAnimation");
static_assert(sizeof(FExtinguishAnimation) == 0x0000D8, "Wrong size on FExtinguishAnimation");
static_assert(offsetof(FExtinguishAnimation, StartExtinguishTime) == 0x0000C8, "Member 'FExtinguishAnimation::StartExtinguishTime' has a wrong offset!");
static_assert(offsetof(FExtinguishAnimation, StopExtinguishSound) == 0x0000D0, "Member 'FExtinguishAnimation::StopExtinguishSound' has a wrong offset!");

// ScriptStruct BrickRigs.SprayAnimation
// 0x0008 (0x00D0 - 0x00C8)
struct FSprayAnimation final : public FItemAnimation
{
public:
	float                                         SprayTime;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSprayAnimation) == 0x000008, "Wrong alignment on FSprayAnimation");
static_assert(sizeof(FSprayAnimation) == 0x0000D0, "Wrong size on FSprayAnimation");
static_assert(offsetof(FSprayAnimation, SprayTime) == 0x0000C8, "Member 'FSprayAnimation::SprayTime' has a wrong offset!");

// ScriptStruct BrickRigs.ThrowAnimation
// 0x0008 (0x00D0 - 0x00C8)
struct FThrowAnimation final : public FItemAnimation
{
public:
	float                                         ThrowTime;                                         // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThrowAnimation) == 0x000008, "Wrong alignment on FThrowAnimation");
static_assert(sizeof(FThrowAnimation) == 0x0000D0, "Wrong size on FThrowAnimation");
static_assert(offsetof(FThrowAnimation, ThrowTime) == 0x0000C8, "Member 'FThrowAnimation::ThrowTime' has a wrong offset!");

// ScriptStruct BrickRigs.HealAnimation
// 0x0000 (0x00C8 - 0x00C8)
struct FHealAnimation final : public FItemAnimation
{
};
static_assert(alignof(FHealAnimation) == 0x000008, "Wrong alignment on FHealAnimation");
static_assert(sizeof(FHealAnimation) == 0x0000C8, "Wrong size on FHealAnimation");

// ScriptStruct BrickRigs.ReloadAnimation
// 0x0008 (0x00D0 - 0x00C8)
struct FReloadAnimation final : public FItemAnimation
{
public:
	float                                         GrabMagTime;                                       // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InsertedTime;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReloadAnimation) == 0x000008, "Wrong alignment on FReloadAnimation");
static_assert(sizeof(FReloadAnimation) == 0x0000D0, "Wrong size on FReloadAnimation");
static_assert(offsetof(FReloadAnimation, GrabMagTime) == 0x0000C8, "Member 'FReloadAnimation::GrabMagTime' has a wrong offset!");
static_assert(offsetof(FReloadAnimation, InsertedTime) == 0x0000CC, "Member 'FReloadAnimation::InsertedTime' has a wrong offset!");

// ScriptStruct BrickRigs.CockAnimation
// 0x0008 (0x00D0 - 0x00C8)
struct FCockAnimation final : public FItemAnimation
{
public:
	float                                         PulledTime;                                        // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleasedTime;                                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCockAnimation) == 0x000008, "Wrong alignment on FCockAnimation");
static_assert(sizeof(FCockAnimation) == 0x0000D0, "Wrong size on FCockAnimation");
static_assert(offsetof(FCockAnimation, PulledTime) == 0x0000C8, "Member 'FCockAnimation::PulledTime' has a wrong offset!");
static_assert(offsetof(FCockAnimation, ReleasedTime) == 0x0000CC, "Member 'FCockAnimation::ReleasedTime' has a wrong offset!");

// ScriptStruct BrickRigs.FireAnimation
// 0x0030 (0x00F8 - 0x00C8)
struct FFireAnimation final : public FItemAnimation
{
public:
	class UAnimMontage*                           FireEmptyMontage;                                  // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequenceBase>       FireEmptySequence;                                 // 0x00D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireAnimation) == 0x000008, "Wrong alignment on FFireAnimation");
static_assert(sizeof(FFireAnimation) == 0x0000F8, "Wrong size on FFireAnimation");
static_assert(offsetof(FFireAnimation, FireEmptyMontage) == 0x0000C8, "Member 'FFireAnimation::FireEmptyMontage' has a wrong offset!");
static_assert(offsetof(FFireAnimation, FireEmptySequence) == 0x0000D0, "Member 'FFireAnimation::FireEmptySequence' has a wrong offset!");

// ScriptStruct BrickRigs.UnequipAnimation
// 0x0000 (0x00C8 - 0x00C8)
struct FUnequipAnimation final : public FItemAnimation
{
};
static_assert(alignof(FUnequipAnimation) == 0x000008, "Wrong alignment on FUnequipAnimation");
static_assert(sizeof(FUnequipAnimation) == 0x0000C8, "Wrong size on FUnequipAnimation");

// ScriptStruct BrickRigs.EquipAnimation
// 0x0000 (0x00C8 - 0x00C8)
struct FEquipAnimation final : public FItemAnimation
{
};
static_assert(alignof(FEquipAnimation) == 0x000008, "Wrong alignment on FEquipAnimation");
static_assert(sizeof(FEquipAnimation) == 0x0000C8, "Wrong size on FEquipAnimation");

// ScriptStruct BrickRigs.ItemRefPoseOverride
// 0x0040 (0x0040 - 0x0000)
struct FItemRefPoseOverride final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemRefPoseOverride) == 0x000010, "Wrong alignment on FItemRefPoseOverride");
static_assert(sizeof(FItemRefPoseOverride) == 0x000040, "Wrong size on FItemRefPoseOverride");
static_assert(offsetof(FItemRefPoseOverride, BoneName) == 0x000000, "Member 'FItemRefPoseOverride::BoneName' has a wrong offset!");
static_assert(offsetof(FItemRefPoseOverride, RelativeTransform) == 0x000010, "Member 'FItemRefPoseOverride::RelativeTransform' has a wrong offset!");

// ScriptStruct BrickRigs.KeyDisplayTableRow
// 0x0020 (0x0028 - 0x0008)
struct FKeyDisplayTableRow final : public FTableRowBase
{
public:
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         IconIndex;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyDisplayTableRow) == 0x000008, "Wrong alignment on FKeyDisplayTableRow");
static_assert(sizeof(FKeyDisplayTableRow) == 0x000028, "Wrong size on FKeyDisplayTableRow");
static_assert(offsetof(FKeyDisplayTableRow, DisplayName) == 0x000008, "Member 'FKeyDisplayTableRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FKeyDisplayTableRow, IconIndex) == 0x000020, "Member 'FKeyDisplayTableRow::IconIndex' has a wrong offset!");

// ScriptStruct BrickRigs.KickedPlayerListRequest
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FKickedPlayerListRequest final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKickedPlayerListRequest) == 0x000008, "Wrong alignment on FKickedPlayerListRequest");
static_assert(sizeof(FKickedPlayerListRequest) == 0x000030, "Wrong size on FKickedPlayerListRequest");

// ScriptStruct BrickRigs.KickedPlayerList
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FKickedPlayerList final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKickedPlayerList) == 0x000008, "Wrong alignment on FKickedPlayerList");
static_assert(sizeof(FKickedPlayerList) == 0x000018, "Wrong size on FKickedPlayerList");

// ScriptStruct BrickRigs.KickedPlayer
// 0x0058 (0x0060 - 0x0008)
struct FKickedPlayer final : public FPagedListEntry
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              KickTime;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              KickDuration;                                      // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KickReason;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKickedPlayer) == 0x000008, "Wrong alignment on FKickedPlayer");
static_assert(sizeof(FKickedPlayer) == 0x000060, "Wrong size on FKickedPlayer");
static_assert(offsetof(FKickedPlayer, PlayerId) == 0x000008, "Member 'FKickedPlayer::PlayerId' has a wrong offset!");
static_assert(offsetof(FKickedPlayer, PlayerName) == 0x000030, "Member 'FKickedPlayer::PlayerName' has a wrong offset!");
static_assert(offsetof(FKickedPlayer, KickTime) == 0x000040, "Member 'FKickedPlayer::KickTime' has a wrong offset!");
static_assert(offsetof(FKickedPlayer, KickDuration) == 0x000048, "Member 'FKickedPlayer::KickDuration' has a wrong offset!");
static_assert(offsetof(FKickedPlayer, KickReason) == 0x000050, "Member 'FKickedPlayer::KickReason' has a wrong offset!");

// ScriptStruct BrickRigs.BuildingMaterialOverride
// 0x0010 (0x0010 - 0x0000)
struct FBuildingMaterialOverride final
{
public:
	class UMaterialInterface*                     FromMaterial;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ToMaterial;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildingMaterialOverride) == 0x000008, "Wrong alignment on FBuildingMaterialOverride");
static_assert(sizeof(FBuildingMaterialOverride) == 0x000010, "Wrong size on FBuildingMaterialOverride");
static_assert(offsetof(FBuildingMaterialOverride, FromMaterial) == 0x000000, "Member 'FBuildingMaterialOverride::FromMaterial' has a wrong offset!");
static_assert(offsetof(FBuildingMaterialOverride, ToMaterial) == 0x000008, "Member 'FBuildingMaterialOverride::ToMaterial' has a wrong offset!");

// ScriptStruct BrickRigs.BuildingMesh
// 0x0008 (0x0008 - 0x0000)
struct FBuildingMesh final
{
public:
	class UDestructibleInstanceTemplate*          Template;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuildingMesh) == 0x000008, "Wrong alignment on FBuildingMesh");
static_assert(sizeof(FBuildingMesh) == 0x000008, "Wrong size on FBuildingMesh");
static_assert(offsetof(FBuildingMesh, Template) == 0x000000, "Member 'FBuildingMesh::Template' has a wrong offset!");

// ScriptStruct BrickRigs.LightBrickEditorParams
// 0x0010 (0x0048 - 0x0038)
struct FLightBrickEditorParams final : public FScalableBrickEditorParams
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLightBrickEditorParams) == 0x000008, "Wrong alignment on FLightBrickEditorParams");
static_assert(sizeof(FLightBrickEditorParams) == 0x000048, "Wrong size on FLightBrickEditorParams");

// ScriptStruct BrickRigs.MatchWinner
// 0x0001 (0x0001 - 0x0000)
struct FMatchWinner final
{
public:
	struct FGenericTeamId                         WinnerTeamId;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FMatchWinner) == 0x000001, "Wrong alignment on FMatchWinner");
static_assert(sizeof(FMatchWinner) == 0x000001, "Wrong size on FMatchWinner");
static_assert(offsetof(FMatchWinner, WinnerTeamId) == 0x000000, "Member 'FMatchWinner::WinnerTeamId' has a wrong offset!");

// ScriptStruct BrickRigs.MenuSequenceProperties
// 0x0020 (0x0020 - 0x0000)
struct FMenuSequenceProperties final
{
public:
	float                                         ProbabilityWeight;                                 // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayOnDayOfMonth;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayDuringMonth;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayOnDayOfWeek;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWorldSetupParams>              WorldSetupParamsOverrides;                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMenuSequenceProperties) == 0x000008, "Wrong alignment on FMenuSequenceProperties");
static_assert(sizeof(FMenuSequenceProperties) == 0x000020, "Wrong size on FMenuSequenceProperties");
static_assert(offsetof(FMenuSequenceProperties, ProbabilityWeight) == 0x000000, "Member 'FMenuSequenceProperties::ProbabilityWeight' has a wrong offset!");
static_assert(offsetof(FMenuSequenceProperties, PlayOnDayOfMonth) == 0x000004, "Member 'FMenuSequenceProperties::PlayOnDayOfMonth' has a wrong offset!");
static_assert(offsetof(FMenuSequenceProperties, PlayDuringMonth) == 0x000008, "Member 'FMenuSequenceProperties::PlayDuringMonth' has a wrong offset!");
static_assert(offsetof(FMenuSequenceProperties, PlayOnDayOfWeek) == 0x00000C, "Member 'FMenuSequenceProperties::PlayOnDayOfWeek' has a wrong offset!");
static_assert(offsetof(FMenuSequenceProperties, WorldSetupParamsOverrides) == 0x000010, "Member 'FMenuSequenceProperties::WorldSetupParamsOverrides' has a wrong offset!");

// ScriptStruct BrickRigs.VehicleSpawnProperties
// 0x0018 (0x0018 - 0x0000)
struct FVehicleSpawnProperties final
{
public:
	uint16                                        NumBricks;                                         // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Dimensions;                                        // 0x0004(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Price;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleSpawnProperties) == 0x000004, "Wrong alignment on FVehicleSpawnProperties");
static_assert(sizeof(FVehicleSpawnProperties) == 0x000018, "Wrong size on FVehicleSpawnProperties");
static_assert(offsetof(FVehicleSpawnProperties, NumBricks) == 0x000000, "Member 'FVehicleSpawnProperties::NumBricks' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnProperties, Dimensions) == 0x000004, "Member 'FVehicleSpawnProperties::Dimensions' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnProperties, Mass) == 0x000010, "Member 'FVehicleSpawnProperties::Mass' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnProperties, Price) == 0x000014, "Member 'FVehicleSpawnProperties::Price' has a wrong offset!");

// ScriptStruct BrickRigs.PlayerViewPoint
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FPlayerViewPoint final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerViewPoint) == 0x000004, "Wrong alignment on FPlayerViewPoint");
static_assert(sizeof(FPlayerViewPoint) == 0x000018, "Wrong size on FPlayerViewPoint");

// ScriptStruct BrickRigs.PopupHandle
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FPopupHandle final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPopupHandle) == 0x000004, "Wrong alignment on FPopupHandle");
static_assert(sizeof(FPopupHandle) == 0x000004, "Wrong size on FPopupHandle");

// ScriptStruct BrickRigs.RepHitInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FRepHitInfo
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepHitInfo) == 0x000004, "Wrong alignment on FRepHitInfo");
static_assert(sizeof(FRepHitInfo) == 0x000038, "Wrong size on FRepHitInfo");

// ScriptStruct BrickRigs.ProjectileHitInfo
// 0x0010 (0x0048 - 0x0038)
struct FProjectileHitInfo final : public FRepHitInfo
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileHitInfo) == 0x000004, "Wrong alignment on FProjectileHitInfo");
static_assert(sizeof(FProjectileHitInfo) == 0x000048, "Wrong size on FProjectileHitInfo");

// ScriptStruct BrickRigs.RepBrickMovementState
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FRepBrickMovementState final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepBrickMovementState) == 0x000010, "Wrong alignment on FRepBrickMovementState");
static_assert(sizeof(FRepBrickMovementState) == 0x000040, "Wrong size on FRepBrickMovementState");

// ScriptStruct BrickRigs.ScalableBrickReplacementMesh
// 0x0018 (0x0018 - 0x0000)
struct FScalableBrickReplacementMesh final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinSize;                                           // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableBrickReplacementMesh) == 0x000008, "Wrong alignment on FScalableBrickReplacementMesh");
static_assert(sizeof(FScalableBrickReplacementMesh) == 0x000018, "Wrong size on FScalableBrickReplacementMesh");
static_assert(offsetof(FScalableBrickReplacementMesh, Mesh) == 0x000000, "Member 'FScalableBrickReplacementMesh::Mesh' has a wrong offset!");
static_assert(offsetof(FScalableBrickReplacementMesh, MinSize) == 0x000008, "Member 'FScalableBrickReplacementMesh::MinSize' has a wrong offset!");

// ScriptStruct BrickRigs.ScalableBrickConnectorSpacing
// 0x0002 (0x0002 - 0x0000)
struct alignas(0x02) FScalableBrickConnectorSpacing final
{
public:
	uint8                                         Pad_0[0x2];                                        // 0x0000(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FScalableBrickConnectorSpacing) == 0x000002, "Wrong alignment on FScalableBrickConnectorSpacing");
static_assert(sizeof(FScalableBrickConnectorSpacing) == 0x000002, "Wrong size on FScalableBrickConnectorSpacing");

// ScriptStruct BrickRigs.SeatBrickEditorParams
// 0x0018 (0x0040 - 0x0028)
struct FSeatBrickEditorParams final : public FBrickEditorParams
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeatBrickEditorParams) == 0x000008, "Wrong alignment on FSeatBrickEditorParams");
static_assert(sizeof(FSeatBrickEditorParams) == 0x000040, "Wrong size on FSeatBrickEditorParams");

// ScriptStruct BrickRigs.SensorBrickEditorParams
// 0x0020 (0x0058 - 0x0038)
struct FSensorBrickEditorParams final : public FScalableBrickEditorParams
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSensorBrickEditorParams) == 0x000008, "Wrong alignment on FSensorBrickEditorParams");
static_assert(sizeof(FSensorBrickEditorParams) == 0x000058, "Wrong size on FSensorBrickEditorParams");

// ScriptStruct BrickRigs.SirenSequenceChannel
// 0x0018 (0x0018 - 0x0000)
struct FSirenSequenceChannel final
{
public:
	bool                                          bStartActivated;                                   // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Timings;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSirenSequenceChannel) == 0x000008, "Wrong alignment on FSirenSequenceChannel");
static_assert(sizeof(FSirenSequenceChannel) == 0x000018, "Wrong size on FSirenSequenceChannel");
static_assert(offsetof(FSirenSequenceChannel, bStartActivated) == 0x000000, "Member 'FSirenSequenceChannel::bStartActivated' has a wrong offset!");
static_assert(offsetof(FSirenSequenceChannel, Timings) == 0x000008, "Member 'FSirenSequenceChannel::Timings' has a wrong offset!");

// ScriptStruct BrickRigs.SurfaceTypeEffects
// 0x0038 (0x0038 - 0x0000)
struct FSurfaceTypeEffects final
{
public:
	class USoundBase*                             FootstepSound;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ImpactEmitter;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ImpactSound;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        SlidingEmitter;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SlidingSound;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ImpactDecalMaterial;                               // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ImpactDecalSizeRange;                              // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceTypeEffects) == 0x000008, "Wrong alignment on FSurfaceTypeEffects");
static_assert(sizeof(FSurfaceTypeEffects) == 0x000038, "Wrong size on FSurfaceTypeEffects");
static_assert(offsetof(FSurfaceTypeEffects, FootstepSound) == 0x000000, "Member 'FSurfaceTypeEffects::FootstepSound' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, ImpactEmitter) == 0x000008, "Member 'FSurfaceTypeEffects::ImpactEmitter' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, ImpactSound) == 0x000010, "Member 'FSurfaceTypeEffects::ImpactSound' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, SlidingEmitter) == 0x000018, "Member 'FSurfaceTypeEffects::SlidingEmitter' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, SlidingSound) == 0x000020, "Member 'FSurfaceTypeEffects::SlidingSound' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, ImpactDecalMaterial) == 0x000028, "Member 'FSurfaceTypeEffects::ImpactDecalMaterial' has a wrong offset!");
static_assert(offsetof(FSurfaceTypeEffects, ImpactDecalSizeRange) == 0x000030, "Member 'FSurfaceTypeEffects::ImpactDecalSizeRange' has a wrong offset!");

// ScriptStruct BrickRigs.TrainSegment
// 0x0018 (0x0018 - 0x0000)
struct FTrainSegment final
{
public:
	class UStaticMesh*                            Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MaterialOverride;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontCouplingOffset;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackCouplingOffset;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainSegment) == 0x000008, "Wrong alignment on FTrainSegment");
static_assert(sizeof(FTrainSegment) == 0x000018, "Wrong size on FTrainSegment");
static_assert(offsetof(FTrainSegment, Mesh) == 0x000000, "Member 'FTrainSegment::Mesh' has a wrong offset!");
static_assert(offsetof(FTrainSegment, MaterialOverride) == 0x000008, "Member 'FTrainSegment::MaterialOverride' has a wrong offset!");
static_assert(offsetof(FTrainSegment, FrontCouplingOffset) == 0x000010, "Member 'FTrainSegment::FrontCouplingOffset' has a wrong offset!");
static_assert(offsetof(FTrainSegment, BackCouplingOffset) == 0x000014, "Member 'FTrainSegment::BackCouplingOffset' has a wrong offset!");

// ScriptStruct BrickRigs.WidgetPathWrapper
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FWidgetPathWrapper final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetPathWrapper) == 0x000008, "Wrong alignment on FWidgetPathWrapper");
static_assert(sizeof(FWidgetPathWrapper) == 0x000008, "Wrong size on FWidgetPathWrapper");

// ScriptStruct BrickRigs.RepBrickDamageItem
// 0x0034 (0x0040 - 0x000C)
struct alignas(0x08) FRepBrickDamageItem final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x34];                                       // 0x000C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRepBrickDamageItem) == 0x000008, "Wrong alignment on FRepBrickDamageItem");
static_assert(sizeof(FRepBrickDamageItem) == 0x000040, "Wrong size on FRepBrickDamageItem");

// ScriptStruct BrickRigs.RepBrickDamage
// 0x0018 (0x0120 - 0x0108)
struct FRepBrickDamage final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepBrickDamageItem>            Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepBrickDamage) == 0x000008, "Wrong alignment on FRepBrickDamage");
static_assert(sizeof(FRepBrickDamage) == 0x000120, "Wrong size on FRepBrickDamage");
static_assert(offsetof(FRepBrickDamage, Items) == 0x000110, "Member 'FRepBrickDamage::Items' has a wrong offset!");

// ScriptStruct BrickRigs.BrickConnectionDamageBitfield
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBrickConnectionDamageBitfield final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBrickConnectionDamageBitfield) == 0x000008, "Wrong alignment on FBrickConnectionDamageBitfield");
static_assert(sizeof(FBrickConnectionDamageBitfield) == 0x000010, "Wrong size on FBrickConnectionDamageBitfield");

// ScriptStruct BrickRigs.RepBrickConnectionDamage
// 0x0018 (0x0120 - 0x0108)
struct FRepBrickConnectionDamage final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRepBrickConnectionDamageItem>  Items;                                             // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRepBrickConnectionDamage) == 0x000008, "Wrong alignment on FRepBrickConnectionDamage");
static_assert(sizeof(FRepBrickConnectionDamage) == 0x000120, "Wrong size on FRepBrickConnectionDamage");
static_assert(offsetof(FRepBrickConnectionDamage, Items) == 0x000110, "Member 'FRepBrickConnectionDamage::Items' has a wrong offset!");

// ScriptStruct BrickRigs.VehicleDataRepl
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FVehicleDataRepl final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleDataRepl) == 0x000008, "Wrong alignment on FVehicleDataRepl");
static_assert(sizeof(FVehicleDataRepl) == 0x000018, "Wrong size on FVehicleDataRepl");

// ScriptStruct BrickRigs.VehicleInput
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FVehicleInput final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleInput) == 0x000004, "Wrong alignment on FVehicleInput");
static_assert(sizeof(FVehicleInput) == 0x000020, "Wrong size on FVehicleInput");

// ScriptStruct BrickRigs.VehicleInputChannel
// 0x0020 (0x0028 - 0x0008)
struct FVehicleInputChannel final : public FBrickStructPropertyInterface
{
public:
	EVehicleInputAxis                             InputAxis;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrickEditorObjectPtr>          SourceBricks;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleInputChannel) == 0x000008, "Wrong alignment on FVehicleInputChannel");
static_assert(sizeof(FVehicleInputChannel) == 0x000028, "Wrong size on FVehicleInputChannel");
static_assert(offsetof(FVehicleInputChannel, InputAxis) == 0x000008, "Member 'FVehicleInputChannel::InputAxis' has a wrong offset!");
static_assert(offsetof(FVehicleInputChannel, SourceBricks) == 0x000010, "Member 'FVehicleInputChannel::SourceBricks' has a wrong offset!");
static_assert(offsetof(FVehicleInputChannel, Value) == 0x000020, "Member 'FVehicleInputChannel::Value' has a wrong offset!");

// ScriptStruct BrickRigs.ViewTargetSharedParams
// 0x0010 (0x0010 - 0x0000)
struct FViewTargetSharedParams
{
public:
	float                                         InputRate;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Step;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewTargetSharedParams) == 0x000004, "Wrong alignment on FViewTargetSharedParams");
static_assert(sizeof(FViewTargetSharedParams) == 0x000010, "Wrong size on FViewTargetSharedParams");
static_assert(offsetof(FViewTargetSharedParams, InputRate) == 0x000000, "Member 'FViewTargetSharedParams::InputRate' has a wrong offset!");
static_assert(offsetof(FViewTargetSharedParams, Step) == 0x000004, "Member 'FViewTargetSharedParams::Step' has a wrong offset!");
static_assert(offsetof(FViewTargetSharedParams, Exponent) == 0x000008, "Member 'FViewTargetSharedParams::Exponent' has a wrong offset!");
static_assert(offsetof(FViewTargetSharedParams, InterpSpeed) == 0x00000C, "Member 'FViewTargetSharedParams::InterpSpeed' has a wrong offset!");

// ScriptStruct BrickRigs.ViewTargetZoomParams
// 0x0008 (0x0018 - 0x0010)
struct FViewTargetZoomParams final : public FViewTargetSharedParams
{
public:
	struct FFloatInterval                         ZoomRange;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewTargetZoomParams) == 0x000004, "Wrong alignment on FViewTargetZoomParams");
static_assert(sizeof(FViewTargetZoomParams) == 0x000018, "Wrong size on FViewTargetZoomParams");
static_assert(offsetof(FViewTargetZoomParams, ZoomRange) == 0x000010, "Member 'FViewTargetZoomParams::ZoomRange' has a wrong offset!");

// ScriptStruct BrickRigs.ViewTargetCameraSpeedParams
// 0x0008 (0x0018 - 0x0010)
struct FViewTargetCameraSpeedParams final : public FViewTargetSharedParams
{
public:
	struct FFloatInterval                         SpeedRange;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FViewTargetCameraSpeedParams) == 0x000004, "Wrong alignment on FViewTargetCameraSpeedParams");
static_assert(sizeof(FViewTargetCameraSpeedParams) == 0x000018, "Wrong size on FViewTargetCameraSpeedParams");
static_assert(offsetof(FViewTargetCameraSpeedParams, SpeedRange) == 0x000010, "Member 'FViewTargetCameraSpeedParams::SpeedRange' has a wrong offset!");

// ScriptStruct BrickRigs.WeatherConditionParams
// 0x0060 (0x0060 - 0x0000)
struct FWeatherConditionParams final
{
public:
	TSoftObjectPtr<class USoundBase>              AmbientSound;                                      // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Temperature;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeed;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeedVariance;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindDirectionVariance;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindPeriod;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudDensity;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudHeight;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFogOpacity;                                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPrecipitationType                            PrecipitationType;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrecipitationIntensity;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnowCoverage;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainCoverage;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightningFrequency;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLightningDelay;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeatherConditionParams) == 0x000008, "Wrong alignment on FWeatherConditionParams");
static_assert(sizeof(FWeatherConditionParams) == 0x000060, "Wrong size on FWeatherConditionParams");
static_assert(offsetof(FWeatherConditionParams, AmbientSound) == 0x000000, "Member 'FWeatherConditionParams::AmbientSound' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, Temperature) == 0x000028, "Member 'FWeatherConditionParams::Temperature' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, WindSpeed) == 0x00002C, "Member 'FWeatherConditionParams::WindSpeed' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, WindSpeedVariance) == 0x000030, "Member 'FWeatherConditionParams::WindSpeedVariance' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, WindDirectionVariance) == 0x000034, "Member 'FWeatherConditionParams::WindDirectionVariance' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, WindPeriod) == 0x000038, "Member 'FWeatherConditionParams::WindPeriod' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, CloudDensity) == 0x00003C, "Member 'FWeatherConditionParams::CloudDensity' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, CloudHeight) == 0x000040, "Member 'FWeatherConditionParams::CloudHeight' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, MaxFogOpacity) == 0x000044, "Member 'FWeatherConditionParams::MaxFogOpacity' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, PrecipitationType) == 0x000048, "Member 'FWeatherConditionParams::PrecipitationType' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, PrecipitationIntensity) == 0x00004C, "Member 'FWeatherConditionParams::PrecipitationIntensity' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, SnowCoverage) == 0x000050, "Member 'FWeatherConditionParams::SnowCoverage' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, RainCoverage) == 0x000054, "Member 'FWeatherConditionParams::RainCoverage' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, LightningFrequency) == 0x000058, "Member 'FWeatherConditionParams::LightningFrequency' has a wrong offset!");
static_assert(offsetof(FWeatherConditionParams, MinLightningDelay) == 0x00005C, "Member 'FWeatherConditionParams::MinLightningDelay' has a wrong offset!");

// ScriptStruct BrickRigs.WinchAttachTarget
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FWinchAttachTarget final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWinchAttachTarget) == 0x000004, "Wrong alignment on FWinchAttachTarget");
static_assert(sizeof(FWinchAttachTarget) == 0x00001C, "Wrong size on FWinchAttachTarget");

// ScriptStruct BrickRigs.ZombieAnimInstanceProxy
// 0x0000 (0x0840 - 0x0840)
struct FZombieAnimInstanceProxy final : public FCharacterAnimInstanceProxy
{
};
static_assert(alignof(FZombieAnimInstanceProxy) == 0x000010, "Wrong alignment on FZombieAnimInstanceProxy");
static_assert(sizeof(FZombieAnimInstanceProxy) == 0x000840, "Wrong size on FZombieAnimInstanceProxy");

}

